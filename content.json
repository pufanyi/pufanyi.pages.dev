{"meta":{"title":"PuFanyi's Blog","subtitle":"","description":"","author":"pufanyi","url":"https://pufanyi.pages.dev","root":"/"},"pages":[{"title":"","date":"2021-08-26T02:17:12.928Z","updated":"2021-08-26T02:17:12.928Z","comments":true,"path":"README.html","permalink":"https://pufanyi.pages.dev/README.html","excerpt":"","text":"pufanyi.pages.dev"},{"title":"关于我","date":"2021-08-17T00:57:52.183Z","updated":"2021-08-17T00:57:52.183Z","comments":true,"path":"about/index.html","permalink":"https://pufanyi.pages.dev/about/index.html","excerpt":"","text":"一只 ZJ 小蒟蒻 qaq。 老年退役选手。qq: 1980270322"},{"title":"归档","date":"2021-08-17T00:57:52.207Z","updated":"2021-08-17T00:57:52.207Z","comments":true,"path":"archives/index.html","permalink":"https://pufanyi.pages.dev/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-08-17T00:57:52.193Z","updated":"2021-08-17T00:57:52.193Z","comments":true,"path":"categories/index.html","permalink":"https://pufanyi.pages.dev/categories/index.html","excerpt":"","text":""},{"title":"朋友们","date":"2021-08-26T12:55:24.169Z","updated":"2021-08-26T12:55:24.169Z","comments":true,"path":"friends/index.html","permalink":"https://pufanyi.pages.dev/friends/index.html","excerpt":"","text":""},{"title":"schedule","date":"2021-08-17T00:57:52.830Z","updated":"2021-08-17T00:57:52.830Z","comments":true,"path":"schedule/index.html","permalink":"https://pufanyi.pages.dev/schedule/index.html","excerpt":"","text":""},{"title":"sitemap","date":"2021-08-17T00:57:52.833Z","updated":"2021-08-17T00:57:52.833Z","comments":true,"path":"sitemap/index.html","permalink":"https://pufanyi.pages.dev/sitemap/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-08-17T00:57:52.213Z","updated":"2021-08-17T00:57:52.213Z","comments":true,"path":"tags/index.html","permalink":"https://pufanyi.pages.dev/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CodeForces 1562D Two Hundred Twenty One","slug":"CF1562D","date":"2021-08-28T08:05:23.590Z","updated":"2021-08-28T08:05:23.590Z","comments":true,"path":"CF1562D/","link":"","permalink":"https://pufanyi.pages.dev/CF1562D/","excerpt":"给定一个长度为 nnn 的字符串表示一个序列 aia_iai​，字符串中只有 '+'、'-'，第 iii 个字符为 '+' 表示 ai=1a_i = 1ai​=1，为 '-' 表示 ai=−1a_i = -1ai​=−1。qqq 组询问，每组询问给定两个整数 l,r (1≤l≤r≤n)l, r\\,(1\\le l\\le r\\le n)l,r(1≤l≤r≤n)，将 al∼ra_{l\\sim r}al∼r​ 单独取出后，求最少删除多少个数字，使得所成长度为 mmm 的序列 {bi}\\left\\{b_{i}\\right\\}{bi​} 满足 ∑i=1m(−1)i−1bi=0\\sum_{i=1}^m(-1)^{i-1}b_i=0∑i=1m​(−1)i−1bi​=0。D1 仅要求出最少删除多少个数字，D2 需要求出删除哪些数字（多解输出任意一组即可）。TTT 组数据，1≤T≤103,1≤n,q≤3⋅1051\\le T\\le 10^3, 1\\le n, q\\le 3\\cdot 10^51≤T≤103,1≤n,q≤3⋅105。","text":"给定一个长度为 nnn 的字符串表示一个序列 aia_iai​，字符串中只有 '+'、'-'，第 iii 个字符为 '+' 表示 ai=1a_i = 1ai​=1，为 '-' 表示 ai=−1a_i = -1ai​=−1。qqq 组询问，每组询问给定两个整数 l,r (1≤l≤r≤n)l, r\\,(1\\le l\\le r\\le n)l,r(1≤l≤r≤n)，将 al∼ra_{l\\sim r}al∼r​ 单独取出后，求最少删除多少个数字，使得所成长度为 mmm 的序列 {bi}\\left\\{b_{i}\\right\\}{bi​} 满足 ∑i=1m(−1)i−1bi=0\\sum_{i=1}^m(-1)^{i-1}b_i=0∑i=1m​(−1)i−1bi​=0。D1 仅要求出最少删除多少个数字，D2 需要求出删除哪些数字（多解输出任意一组即可）。TTT 组数据，1≤T≤103,1≤n,q≤3⋅1051\\le T\\le 10^3, 1\\le n, q\\le 3\\cdot 10^51≤T≤103,1≤n,q≤3⋅105。 先考虑没有多组询问。 窝萌首先发现一个性质，那就是如果有两个连续的相同字符，那么这两个字符对答案无贡献，我们可以直接删掉。那我们一次删掉之后，最后得到的序列只能是正负交替的了。于是我们只要考虑此种情况即可。我们发现如果删完的序列长度为奇数的话，我们只要删除最中间那个数就可以了。我们考虑偶数，如果长度已经为 000，那显然就不用删除了，如果不为 000 的话，考虑到们此相同字符消除一定是两个两个删的，所以至少要删两个数，有考虑到如果随便删一个数，那么序列长度就变成奇数了，所以我们只需要删两个数即可。 于是我们发现，如果是询问系列长度为奇数，那答案最多是 111，如果是偶数，我们可以维护前缀和 Si=∑j=1i(−1)j−1ajS_i=\\sum_{j=1}^i(-1)^{j-1}a_jSi​=∑j=1i​(−1)j−1aj​，如果 Sr−Sl−1S_r-S_{l-1}Sr​−Sl−1​ 是 000，那答案就是 000，否则是 222。 这样 D1 就做完了。 我们考虑 D2，我们先考虑奇数的情况，我们假设要删掉的数是第 kkk 个，那我们有 ∑i=lk−1(−1)i−1ai+(−1)⋅∑i=k+1r(−1)i−1ai=0\\sum_{i=l}^{k - 1}(-1)^{i-1}a_{i}+(-1)\\cdot\\sum_{i=k+1}^r(-1)^{i-1}a_i=0∑i=lk−1​(−1)i−1ai​+(−1)⋅∑i=k+1r​(−1)i−1ai​=0 也即 Sk−1−Sl−1=Sr−SkS_{k-1}-S_{l-1}=S_{r}-S_{k}Sk−1​−Sl−1​=Sr​−Sk​ 也即 Sk−1+Sk=Sl−1+SrS_{k-1}+S_k=S_{l-1}+S_rSk−1​+Sk​=Sl−1​+Sr​，于是我们对每个 Sk−1+SkS_{k-1}+S_kSk−1​+Sk​ 相同的开个 set，之后对每组询问 &lt;l,r&gt;\\left&lt;l,r\\right&gt;⟨l,r⟩，我们只要在所有 Sk−1+Sk=Sl−1+SrS_{k-1}+S_k=S_{l-1}+S_rSk−1​+Sk​=Sl−1​+Sr​ 数中 lower_bound 出一个在 [l,r][l,r][l,r] 中的答案即可。 长度为偶数就直接随便删掉最左边或是最右边的数，然后按照奇数的方法做即可。123456789101112131415161718192021222324252627282930313233343536373839const int maxn = 300005;int qzh[maxn];char s[maxn];void solve() &#123; int n, q; scanf(\"%d%d%s\", &amp;n, &amp;q, s + 1); std::map&lt;int, std::set&lt;int&gt;&gt; mp; for (int i = 1; i &lt;= n; ++i) &#123; qzh[i] = qzh[i - 1] + (((i &amp; 1) == (s[i] == '+')) ? 1 : -1); mp[qzh[i - 1] + qzh[i]].insert(i); &#125; while (q--) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); if (qzh[r] - qzh[l - 1]) &#123; if ((r - l) &amp; 1) &#123; puts(\"2\"); writesp(r); r--; &#125; else &#123; puts(\"1\"); &#125; writeln(*mp[qzh[l - 1] + qzh[r]].lower_bound(l)); &#125; else &#123; puts(\"0\"); &#125; &#125;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; solve(); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"}]},{"title":"CodeForces 1562B Scenes From a Memory","slug":"CF1562B","date":"2021-08-28T08:05:23.590Z","updated":"2021-08-28T08:05:23.590Z","comments":true,"path":"CF1562B/","link":"","permalink":"https://pufanyi.pages.dev/CF1562B/","excerpt":"有 T (1≤T≤103)T\\,(1\\le T\\le 10^3)T(1≤T≤103) 组数据，每组给一个长度为 k (1≤k≤50)k\\,(1\\le k\\le 50)k(1≤k≤50) 的十进制正整数 nnn，其中 nnn 在十进制下不存在 000（同样不存在前导 000），让你求一个整数 mmm，使得 mmm 在十进制下为 nnn 在十进制下的子序列，且 mmm 为非素数（111 也是非素数）。子序列不要求连续。","text":"有 T (1≤T≤103)T\\,(1\\le T\\le 10^3)T(1≤T≤103) 组数据，每组给一个长度为 k (1≤k≤50)k\\,(1\\le k\\le 50)k(1≤k≤50) 的十进制正整数 nnn，其中 nnn 在十进制下不存在 000（同样不存在前导 000），让你求一个整数 mmm，使得 mmm 在十进制下为 nnn 在十进制下的子序列，且 mmm 为 非素数 （111 也是非素数）。子序列不要求连续。 窝萌考虑尽量批量解决一些能解决数。考虑到如果一个数字含有 1,4,6,8,91, 4, 6, 8, 91,4,6,8,9，那么这个数只要保留这一位即可，而其余情况均需保留两位。如果没有这些数，也就是只有 2,3,5,72, 3, 5, 72,3,5,7，如果存在两个数字相同，那么只要保留这两个数字就一定被 111111 整除，于是位数大于等于 555 位的数字都解决了。然后考虑到只要 222 和 777、555 和 777 在一起，那么取这两个数就一定被 333 整除，于是 444 位数也解决了。然后如果 222 和 555 不放在第一位，那么就可以整出一个尾数是 222 或尾数 555 的两位数，分别被 555 和 222 整除。也就是说现在窝萌还不能解决的应该是个三位数，又因为 222 和 555 至少会有一个数被选进这个三位数（2,3,5,72, 3, 5, 72,3,5,7 四个数里选三个嘛），所以 777 就不能来了，这样 2,3,52, 3, 52,3,5 一定要进场，但是 222 和 555 又都要在开头，所以是不可能的。于是窝萌发现其实两位及以上的数字窝萌都只需要上面说的 444 个特判就可以了。总结一下，先判有没有 1,4,6,8,91, 4, 6, 8, 91,4,6,8,9，如果没有看有没有同时出现 222 和 777、555 和 777，如果还没有，那我看一下有没有不放在开头的 222 和 555。这样就能覆盖到所有可行的数字了。","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E5%AD%A6/"},{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"}]},{"title":"又一个镜像","slug":"cloudflare镜像","date":"2021-08-26T03:35:23.508Z","updated":"2021-08-26T03:35:23.508Z","comments":true,"path":"cloudflare镜像/","link":"","permalink":"https://pufanyi.pages.dev/cloudflare%E9%95%9C%E5%83%8F/","excerpt":"","text":"由于一些原因删除了 gitee 镜像，但由于 github 镜像国内实在有些不稳定，于是又搭了一个 镜像。虽然也是国外的，但稳定一些。","categories":[{"name":"公告","slug":"公告","permalink":"https://pufanyi.pages.dev/categories/%E5%85%AC%E5%91%8A/"}],"tags":[]},{"title":"CodeForces 1558B Up the Strip","slug":"CF1558B","date":"2021-08-26T02:15:55.511Z","updated":"2021-08-26T02:15:55.511Z","comments":true,"path":"CF1558B/","link":"","permalink":"https://pufanyi.pages.dev/CF1558B/","excerpt":"有 n (2≤n≤4⋅106)n\\,(2\\le n\\le 4\\cdot 10^6)n(2≤n≤4⋅106) 个节点，编号 1∼n1\\sim n1∼n，你一开始在节点 nnn，想要到节点 111。假设你现在在节点 xxx，你可以进行以下两种操作：选择一个正整数 y∈[1,x−1]y\\in \\left[1, x - 1\\right]y∈[1,x−1]，并移动到节点 x−yx-yx−y。选择一个正整数 z∈[2,x]z\\in \\left[2, x\\right]z∈[2,x]，并移动到节点 ⌊xz⌋\\left\\lfloor\\frac{x}{z}\\right\\rfloor⌊zx​⌋。求有多少种方案到达节点 111，只要有一次选择的 xxx 或 zzz 不同就算方案不同。答案对 mmm 取模，其中 m∈(108,109)m\\in \\left(10^8, 10^9\\right)m∈(108,109) 且 mmm 是素数。","text":"有 n (2≤n≤4⋅106)n\\,(2\\le n\\le 4\\cdot 10^6)n(2≤n≤4⋅106) 个节点，编号 1∼n1\\sim n1∼n，你一开始在节点 nnn，想要到节点 111。假设你现在在节点 xxx，你可以进行以下两种操作：选择一个正整数 y∈[1,x−1]y\\in \\left[1, x - 1\\right]y∈[1,x−1]，并移动到节点 x−yx-yx−y。选择一个正整数 z∈[2,x]z\\in \\left[2, x\\right]z∈[2,x]，并移动到节点 ⌊xz⌋\\left\\lfloor\\frac{x}{z}\\right\\rfloor⌊zx​⌋。求有多少种方案到达节点 111，只要有一次选择的 xxx 或 zzz 不同就算方案不同。答案对 mmm 取模，其中 m∈(108,109)m\\in \\left(10^8, 10^9\\right)m∈(108,109) 且 mmm 是素数。令 fif_ifi​ 表示 n=in=in=i 时的答案，我们有：fi=∑j=1i−1fj+∑d=2if⌊id⌋f_i=\\sum_{j=1}^{i-1}f_j+\\sum_{d=2}^{i}f_{\\left\\lfloor\\frac{i}{d}\\right\\rfloor}fi​=j=1∑i−1​fj​+d=2∑i​f⌊di​⌋​前一部分表示用减法，后一部分表示用除法。考虑优化，第一部分直接前缀和，我们直接考虑第二部分。一种很直接的优化是将小于 i\\sqrt{i}i​ 的 ddd 直接拿出来算，大于 i\\sqrt{i}i​ 的 ddd 拿出来算贡献， fkf_{k}fk​ 能转移到 fif_ifi​ 的 ddd 应该满足 k≤id&lt;k+1k\\le \\frac{i}{d} &lt; k + 1k≤di​&lt;k+1，也即 ik+1&lt;d≤ik\\frac{i}{k+1}&lt;d\\le\\frac{i}{k}k+1i​&lt;d≤ki​，于是 fkf_kfk​ 对 fif_ifi​ 的贡献应该为 ⌊nk⌋−⌊nk+1⌋\\left\\lfloor\\frac{n}{k}\\right\\rfloor-\\left\\lfloor\\frac{n}{k+1}\\right\\rfloor⌊kn​⌋−⌊k+1n​⌋。这样做复杂度是 O(nn)\\mathcal{O}(n\\sqrt{n})O(nn​)，过不去，但是如果你打 Div. 2 的话就能过一个 easy 版 。 我们考虑换一种方式，考虑 fif_ifi​ 转移到 fi+1f_{i+1}fi+1​，我们比较 ∑d=2if⌊id⌋\\sum_{d=2}^{i}f_{\\left\\lfloor\\frac{i}{d}\\right\\rfloor}∑d=2i​f⌊di​⌋​ 与 ∑d=2i+1f⌊i+1d⌋\\sum_{d=2}^{i+1}f_{\\left\\lfloor\\frac{i+1}{d}\\right\\rfloor}∑d=2i+1​f⌊di+1​⌋​，有如下变化：多了一个 f1f_1f1​，因为 ddd 可以等于 i+1i+1i+1。对于所有 d∣i+1d\\mid i+1d∣i+1，⌊i+1d⌋=⌊id⌋+1\\left\\lfloor\\frac{i+1}{d}\\right\\rfloor=\\left\\lfloor\\frac{i}{d}\\right\\rfloor+1⌊di+1​⌋=⌊di​⌋+1，所以 fi+1f_{i+1}fi+1​ 比 fif_ifi​ 多了一个 f⌊i+1d⌋f_{\\left\\lfloor\\frac{i+1}{d}\\right\\rfloor}f⌊di+1​⌋​，少了一个 f⌊id⌋f_{\\left\\lfloor\\frac{i}{d}\\right\\rfloor}f⌊di​⌋​。也就是说：fi+1=∑j=1ifj+∑d=2i+1f⌊i+1d⌋=fi+∑j=1i−1fj+∑d=2i+1f⌊i+1d⌋=fi+fi+f1+∑d∣i+1(f⌊i+1d⌋−f⌊id⌋)=2fi+f1+∑d∣i+1(f⌊i+1d⌋−f⌊id⌋)\\begin{aligned} f_{i+1}&amp;=\\sum_{j=1}^{i}f_j+\\sum_{d=2}^{i+1}f_{\\left\\lfloor\\frac{i+1}{d}\\right\\rfloor}\\\\&amp;=f_i+\\sum_{j=1}^{i-1}f_j+\\sum_{d=2}^{i+1}f_{\\left\\lfloor\\frac{i+1}{d}\\right\\rfloor}\\\\&amp;=f_i+f_i+f_1+\\sum_{d\\mid i+1}\\left(f_{\\left\\lfloor\\frac{i+1}{d}\\right\\rfloor}-f_{\\left\\lfloor\\frac{i}{d}\\right\\rfloor}\\right)\\\\&amp;=2f_i+f_1+\\sum_{d\\mid i+1}\\left(f_{\\left\\lfloor\\frac{i+1}{d}\\right\\rfloor}-f_{\\left\\lfloor\\frac{i}{d}\\right\\rfloor}\\right) \\end{aligned}fi+1​​=j=1∑i​fj​+d=2∑i+1​f⌊di+1​⌋​=fi​+j=1∑i−1​fj​+d=2∑i+1​f⌊di+1​⌋​=fi​+fi​+f1​+d∣i+1∑​(f⌊di+1​⌋​−f⌊di​⌋​)=2fi​+f1​+d∣i+1∑​(f⌊di+1​⌋​−f⌊di​⌋​)​我们发现对于所有 iii，总的约数个数为 ∑i=1nni=O(nlog⁡n)\\sum_{i=1}^n\\frac{n}{i}=\\mathcal{O}(n\\log n)∑i=1n​in​=O(nlogn)。其余转移为 O(n)\\mathcal{O}(n)O(n)，故总复杂度为 O(nlog⁡n)\\mathcal{O}(n\\log n)O(nlogn)。考虑实现，在每次计算出 fif_{i}fi​ 的时候，将所有的 fkif_{ki}fki​ 都加上 fi−fi−1f_i-f_{i-1}fi​−fi−1​，这样空间复杂度就是 O(n)\\mathcal{O}(n)O(n)。1234567891011121314151617181920212223242526272829303132333435const int maxn = 4000005;int n, mod;void add(int&amp; x, int y) &#123; x += y; if (x &gt;= mod) &#123; x -= mod; &#125; else if (x &lt; 0) &#123; x += mod; &#125;&#125;int f[maxn];int main() &#123; read(n), read(mod); f[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; int tmp = f[i - 1] &lt;&lt; 1 | 1; if (tmp &gt;= mod) &#123; tmp -= mod; &#125; add(f[i], tmp); if (i == 2) &#123; f[i] = 2; &#125; for (int j = i &lt;&lt; 1; j &lt;= n; j += i) &#123; add(f[j], f[i]); add(f[j], -f[i - 1]); &#125; &#125; writeln(f[n]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E5%AD%A6/"},{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"DP","slug":"DP","permalink":"https://pufanyi.pages.dev/tags/DP/"}]},{"title":"2021 浙江高考数学圆锥曲线","slug":"2021浙江高考数学圆锥曲线","date":"2021-08-26T02:15:55.508Z","updated":"2021-08-26T02:15:55.508Z","comments":true,"path":"2021浙江高考数学圆锥曲线/","link":"","permalink":"https://pufanyi.pages.dev/2021%E6%B5%99%E6%B1%9F%E9%AB%98%E8%80%83%E6%95%B0%E5%AD%A6%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF/","excerpt":"高考数学挂了圆锥曲线最后几步了忘了开根 qaq这里订正一下","text":"高考数学挂了 圆锥曲线最后几步了忘了开根 qaq这里订正一下 如图，已知 FFF 是抛物线 y2=2px (p&gt;0)y^2=2px\\,(p&gt;0)y2=2px(p&gt;0) 的焦点，MMM 是抛物线的准线与 xxx 轴的交点，且 ∣MF∣=2\\left|MF\\right|=2∣MF∣=2（1）求抛物线的方程；解：p=2⇒y2=4xp=2\\Rightarrow y^2=4xp=2⇒y2=4x（2）设过点 FFF 的直线交抛物线与 AAA､BBB 两点，斜率为 222 的直线 lll 与直线 MA, MB, ABMA,\\,MB,\\,ABMA,MB,AB，xxx 轴依次交于点 P，Q，R，NP，Q，R，NP，Q，R，N，且 ∣RN∣2=∣PN∣⋅∣QN∣\\left|RN\\right|^2=\\left|PN\\right|\\cdot\\left|QN\\right|∣RN∣2=∣PN∣⋅∣QN∣，求直线 lll 在 xxx 轴上截距的范围。解：设 A(a2,2a), B(b2,2b)A(a^2,2a),\\ B(b^2,2b)A(a2,2a), B(b2,2b)。有 AB: (a+b)y=2x+2abAB:\\,(a+b)y=2x+2abAB:(a+b)y=2x+2ab。将 F(1,0)F(1,0)F(1,0) 代入得：ab=−1ab=-1ab=−1，即 AB: (a+b)y=2x−2AB:\\,(a+b)y=2x-2AB:(a+b)y=2x−2。设 l: x=12y+tl:\\,x=\\frac{1}{2}y+tl:x=21​y+t，代入 ABABAB，有：yR=2t−2a+b−1y_R=\\frac{2t-2}{a+b-1}yR​=a+b−12t−2​。考虑到 M(−1,0)M(-1,0)M(−1,0)，于是 MA: y−2ax−a2=2aa2+1MA:\\,\\frac{y-2a}{x-a^2}=\\frac{2a}{a^2+1}MA:x−a2y−2a​=a2+12a​。MAMAMA 与 lll 联立：yP=2a(t+1)a2−a+1y_P=\\frac{2a(t+1)}{a^2-a+1}yP​=a2−a+12a(t+1)​。同理 yQ=2b(t+1)b2−b+1y_Q=\\frac{2b(t+1)}{b^2-b+1}yQ​=b2−b+12b(t+1)​。又 ∣PN∣⋅∣QN∣=∣RN∣2⇒yR2=−yPyQ\\left|PN\\right|\\cdot\\left|QN\\right|=\\left|RN\\right|^2\\Rightarrow y_R^2=-y_Py_Q∣PN∣⋅∣QN∣=∣RN∣2⇒yR2​=−yP​yQ​。考虑到 −yPyQ=−4ab(t+1)2(a2−a+1)(b2−b+1)=4(t+1)2a2+b2+1-y_Py_Q=-\\frac{4ab(t+1)^2}{(a^2-a+1)(b^2-b+1)}=\\frac{4(t+1)^2}{a^2+b^2+1}−yP​yQ​=−(a2−a+1)(b2−b+1)4ab(t+1)2​=a2+b2+14(t+1)2​，yR2=4(t−1)2a2+b2−2a−2b−1y_R^2=\\frac{4(t-1)^2}{a^2+b^2-2a-2b-1}yR2​=a2+b2−2a−2b−14(t−1)2​。当 t≠±1t\\not=\\pm 1t​=±1 时：我们有：∣PN∣⋅∣QN∣=∣RN∣2⇒(t−1t+1)2=a2+b2−2a−2b−1a2+b2+1\\left|PN\\right|\\cdot\\left|QN\\right|=\\left|RN\\right|^2\\Rightarrow\\left(\\frac{t-1}{t+1}\\right)^2=\\frac{a^2+b^2-2a-2b-1}{a^2+b^2+1}∣PN∣⋅∣QN∣=∣RN∣2⇒(t+1t−1​)2=a2+b2+1a2+b2−2a−2b−1​。令 s=a+bs=a+bs=a+b，则 s=a−1a∈Rs=a-\\frac{1}{a}\\in\\Rs=a−a1​∈R，a2+b2=s2−2ab=s2+2a^2+b^2=s^2-2ab=s^2+2a2+b2=s2−2ab=s2+2。那么我们有 (t−1t+1)2=(s−1)2s2+3\\left(\\frac{t-1}{t+1}\\right)^2=\\frac{(s-1)^2}{s^2+3}(t+1t−1​)2=s2+3(s−1)2​取 r=(s−1)2s2+3r=\\frac{(s-1)^2}{s^2+3}r=s2+3(s−1)2​，我们有 (r−1)s2+2s+(3r−1)=0(r-1)s^2+2s+(3r-1)=0(r−1)s2+2s+(3r−1)=0，Δ=4−4(r−1)(3r−1)≥0\\Delta=4-4(r-1)(3r-1)\\ge 0Δ=4−4(r−1)(3r−1)≥0。于是 r∈[0,43]r\\in \\left[0, \\frac{4}{3}\\right]r∈[0,34​]，也即 t−1t+1∈[−43,43]\\frac{t-1}{t+1}\\in\\left[-\\sqrt{\\frac{4}{3}}, \\sqrt{\\frac{4}{3}}\\right]t+1t−1​∈[−34​​,34​​]，故 t≤−43−7t\\le -4\\sqrt{3}-7t≤−43​−7 或 t≥43−7t\\ge 4\\sqrt{3}-7t≥43​−7 且 t≠1t\\not= 1t​=1。当 t=±1t=\\pm 1t=±1 时：∣RN∣2=0\\left|RN\\right|^2=0∣RN∣2=0，但 ∣PN∣⋅∣QN∣\\left|PN\\right|\\cdot\\left|QN\\right|∣PN∣⋅∣QN∣ 不可能为 000，故不成立。综上，t∈(−∞,−43−7]∪[43−7,1)∪(1,+∞)t\\in\\left(-\\infty, -4\\sqrt{3}-7\\right]\\cup\\left[4\\sqrt{3}-7,1\\right)\\cup\\left(1,+\\infty\\right)t∈(−∞,−43​−7]∪[43​−7,1)∪(1,+∞)。","categories":[{"name":"文化课","slug":"文化课","permalink":"https://pufanyi.pages.dev/categories/%E6%96%87%E5%8C%96%E8%AF%BE/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E5%AD%A6/"},{"name":"文化课","slug":"文化课","permalink":"https://pufanyi.pages.dev/tags/%E6%96%87%E5%8C%96%E8%AF%BE/"}]},{"title":"关闭 gitee 镜像","slug":"关闭gitee镜像","date":"2021-08-26T02:15:55.508Z","updated":"2021-08-26T02:15:55.508Z","comments":true,"path":"关闭gitee镜像/","link":"","permalink":"https://pufanyi.pages.dev/%E5%85%B3%E9%97%ADgitee%E9%95%9C%E5%83%8F/","excerpt":"","text":"gitee 被封了，说是有一些违规内容。找了半天找不到，那就算了不更镜像了。","categories":[{"name":"公告","slug":"公告","permalink":"https://pufanyi.pages.dev/categories/%E5%85%AC%E5%91%8A/"}],"tags":[]},{"title":"退役啦！","slug":"AFO","date":"2020-06-21T16:00:00.000Z","updated":"2020-06-21T16:00:00.000Z","comments":true,"path":"AFO/","link":"","permalink":"https://pufanyi.pages.dev/AFO/","excerpt":"嘴里说着退役，不知不觉就真的退役了。","text":"嘴里说着退役，不知不觉就真的退役了。想起来已经两年半了。从弃了文化课来搞 OI，到现在又得滚回去搞文化课，真是一段有意思的经历。两年前，打字还要看着键盘，然而现在还是不会背键盘 ；场场模拟赛爆蛋， 然而现在还是只会爆蛋 。NOIP2018 初赛直接挂了，险些退役。回想起来那种自闭的感觉确实挺有意思的。CSP2019 好不容易过了初赛，结果复赛爆炸，Day1T3 写不出来，Day2T1 有被卡常。 考完 CSP 去打 CodeForces，好不容易要上 IM 了，连续几场 fst 直接一夜回到解放前。后来文化课压力逐渐重了起来，毕竟是要高考了。不管怎么说，总算是 AFO 了。还有几篇博客没填完的，就让她们鸽这吧（不知道以后再有没有机会打 CF 了：不知道以后再有没有机会刷洛谷了：","categories":[{"name":"随笔","slug":"随笔","permalink":"https://pufanyi.pages.dev/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"Pollard Rho 入门","slug":"Rho","date":"2020-04-18T02:16:23.000Z","updated":"2020-04-18T02:16:23.000Z","comments":true,"path":"Rho/","link":"","permalink":"https://pufanyi.pages.dev/Rho/","excerpt":"要开学了 qaq，看起来不能再鸽下去了，来水一篇。","text":"要开学了 qaq，看起来不能再鸽下去了，来水一篇。 考虑到自己 too naive，感觉之前不是很会 Pollard Rho，就只好重新拿起算导看了一遍。看完发现自己果然菜。 首先是一个叫生日悖论的东西。这玩意儿好像每一篇将 Pollard Rho 的文章都会有所提及。假设一年有 nnn 天，期望有多少个人才能使有两个人生日相同。 答案当然是 O(n)\\mathcal{O}(\\sqrt{n})O(n​) 的了，其实说实在的，初看还是挺反直觉的，但仔细推一下就发现确实是这样。因为假设有 kkk 个人，就有 (k2)\\binom{k}{2}(2k​) 对比较关系嘛，而我们可以近似的认为每对关系是独立的，即相等的概率是 1n\\frac{1}{n}n1​，也就是期望相等的个数约为 (k2)1n\\binom{k}{2}\\frac{1}{n}(2k​)n1​，要使其大于等于 111，可以解得 kkk 是 O(n)\\mathcal{O}(\\sqrt{n})O(n​) 的。 然后就是 rho 算法了，他解决的是一个质因子分解的问题。 一个 naive 的想法，就是就与一个数 nnn，先判断他是不是质数，如果是的话，其分解就是自己了，否则每次随机一个数 xxx，看看是不是 nnn 的质因子，如果是的话，就递归 nx\\frac{n}{x}xn​ 和 xxx。然而这个复杂度显然是不对的。 而根据生日悖论，我们有会有一个想法，那就是多随机几个数，两两作差，每个都与 nnn 取一下 gcd 来看一看是不是等于 111，但这样的复杂度显然和前面的算法一样。 我们考虑构造函数 fn(x)=(x2+c) mod nf_{n}(x)=(x^2+c)\\bmod nfn​(x)=(x2+c)modn，ccc 是事先选择的一个数。首先我们需要知道一点的是，在本文中，我们认为 fn(x)f_{n}(x)fn​(x) 是在 [0,n][0,n][0,n] 下的一个随机函数，而事实可能并不是这样。 我们考虑构造一个序列 {a}\\{a\\}{a}，a1a_{1}a1​ 是一个预先给出的随机数，ai=fn(ai−1)a_{i}=f_{n}(a_{i-1})ai​=fn​(ai−1​)，不难发现，这个 {a}\\{a\\}{a} 序列是一个 ρ\\rhoρ 字形： 然后我们考虑，加入 ppp 是 nnn 的一个约数，对于一个长度 ℓ\\ellℓ，对于任意的 x,yx,yx,y，我们发现：fn(x+ℓ)−fn(x)≡fn(y+ℓ)−fn(y)(modp)f_{n}(x+\\ell)-f_{n}(x)\\equiv f_{n}(y+\\ell)-f_{n}(y)\\pmod pfn​(x+ℓ)−fn​(x)≡fn​(y+ℓ)−fn​(y)(modp) 那么也就是说，如果我们试了 &lt;x,x+ℓ&gt;\\left&lt;x,x+\\ell\\right&gt;⟨x,x+ℓ⟩，那就不需要试 &lt;y,y+ℓ&gt;\\left&lt;y,y+\\ell\\right&gt;⟨y,y+ℓ⟩，因为如果 fn(x+ℓ)−fn(x)f_{n}(x+\\ell)-f_{n}(x)fn​(x+ℓ)−fn​(x) 不是 ppp 的倍数，那 fn(y+ℓ)−fn(y)f_{n}(y+\\ell)-f_{n}(y)fn​(y+ℓ)−fn​(y) 肯定也不是 ppp 的倍数。","categories":[{"name":"小小结","slug":"小小结","permalink":"https://pufanyi.pages.dev/categories/%E5%B0%8F%E5%B0%8F%E7%BB%93/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"AGC043C Giant Graph","slug":"agc043_c","date":"2020-04-07T01:55:04.000Z","updated":"2020-04-07T01:55:04.000Z","comments":true,"path":"agc043_c/","link":"","permalink":"https://pufanyi.pages.dev/agc043_c/","excerpt":"构造一个 n3n^3n3 个点的无向图 GGG，方法如下：给定 333 张 nnn 个点的无向图 G1,G2,G3G_1,G_2,G_3G1​,G2​,G3​。构造 n3n^3n3 个点，标号是一个三元组 &lt;i,j,k&gt;\\left&lt;i,j,k\\right&gt;⟨i,j,k⟩。对于 G1G_1G1​ 中的边 &lt;u,v&gt;\\left&lt;u,v\\right&gt;⟨u,v⟩，连边 &lt;u,j,k&gt;\\left&lt;u,j,k\\right&gt;⟨u,j,k⟩ 和 &lt;v,j,k&gt;\\left&lt;v,j,k\\right&gt;⟨v,j,k⟩。对于 G2G_2G2​ 中的边 &lt;u,v&gt;\\left&lt;u,v\\right&gt;⟨u,v⟩，连边 &lt;i,u,k&gt;\\left&lt;i,u,k\\right&gt;⟨i,u,k⟩ 和 &lt;i,v,k&gt;\\left&lt;i,v,k\\right&gt;⟨i,v,k⟩。对于 G3G_3G3​ 中的边 &lt;u,v&gt;\\left&lt;u,v\\right&gt;⟨u,v⟩，连边 &lt;i,j,u&gt;\\left&lt;i,j,u\\right&gt;⟨i,j,u⟩ 和 &lt;i,j,v&gt;\\left&lt;i,j,v\\right&gt;⟨i,j,v⟩。对于 GGG 上的一个点 &lt;i,j,k&gt;\\left&lt;i,j,k\\right&gt;⟨i,j,k⟩，其点权为 1018(i+j+k){10}^{18(i+j+k)}1018(i+j+k)。现在，要你求出 GGG 的最大独立集大小膜 998244353998244353998244353 以后的值。2≤n≤105,1≤m1,m2,m3≤1052\\le n\\le 10^5,1\\le m_1,m_2,m_3\\le 10^52≤n≤105,1≤m1​,m2​,m3​≤105","text":"构造一个 n3n^3n3 个点的无向图 GGG，方法如下： 给定 333 张 nnn 个点的无向图 G1,G2,G3G_1,G_2,G_3G1​,G2​,G3​。 构造 n3n^3n3 个点，标号是一个三元组 &lt;i,j,k&gt;\\left&lt;i,j,k\\right&gt;⟨i,j,k⟩。 对于 G1G_1G1​ 中的边 &lt;u,v&gt;\\left&lt;u,v\\right&gt;⟨u,v⟩，连边 &lt;u,j,k&gt;\\left&lt;u,j,k\\right&gt;⟨u,j,k⟩ 和 &lt;v,j,k&gt;\\left&lt;v,j,k\\right&gt;⟨v,j,k⟩。 对于 G2G_2G2​ 中的边 &lt;u,v&gt;\\left&lt;u,v\\right&gt;⟨u,v⟩，连边 &lt;i,u,k&gt;\\left&lt;i,u,k\\right&gt;⟨i,u,k⟩ 和 &lt;i,v,k&gt;\\left&lt;i,v,k\\right&gt;⟨i,v,k⟩。 对于 G3G_3G3​ 中的边 &lt;u,v&gt;\\left&lt;u,v\\right&gt;⟨u,v⟩，连边 &lt;i,j,u&gt;\\left&lt;i,j,u\\right&gt;⟨i,j,u⟩ 和 &lt;i,j,v&gt;\\left&lt;i,j,v\\right&gt;⟨i,j,v⟩。 对于 GGG 上的一个点 &lt;i,j,k&gt;\\left&lt;i,j,k\\right&gt;⟨i,j,k⟩，其点权为 1018(i+j+k){10}^{18(i+j+k)}1018(i+j+k)。 现在，要你求出 GGG 的最大独立集大小膜 998244353998244353998244353 以后的值。2≤n≤105,1≤m1,m2,m3≤1052\\le n\\le 10^5,1\\le m_1,m_2,m_3\\le 10^52≤n≤105,1≤m1​,m2​,m3​≤105 考虑到是点权是一个大数的幂次，那肯定是选的数越大越好。 考虑如果你知道了图 GGG 之后你会怎么做。 首先 &lt;n,n,n&gt;\\left&lt;n,n,n\\right&gt;⟨n,n,n⟩ 这个点必须得选，然后其跟她连边的点就不能选了。 然后如果一个点已经确定了旁边已经比她大的点都不选了，那么她才会选。 那会不会有两个相邻的点点权相等呢？显然不会。因为相邻的点必须有两个权值相等，那么另外一个肯定相等，这是不合法的。 然后我们就考虑这个过程，就是我们考虑如何判断一个点选不选，那就要看与之相邻的比她大的点选不选，就是如果那些点都是不合法的，那么这个点合法，否则不合法。 我们发现这跟博弈问题很像，就是有 333 颗棋子，每个人每次可以把一个棋子移动到一个比她大的格子里，不能走的就输了。而先手必输态的点就是合法的。 于是我们只要计算每个点的 sg 值即可。 考虑到每张图 sg 值只会有 O(n)\\mathcal{O}(\\sqrt n)O(n​) 个，我们只要计算出之后暴力合并即可，于是合并复杂度是 O(n)\\mathcal{O}(n)O(n) 的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394namespace dfcmd &#123; typedef long long LL; const int maxn = 100005; const int mod = 998244353; const int di = 1000000000000000000LL % mod; int bin[maxn]; inline void add(int&amp; x, int y) &#123; x += y; if (x &gt;= mod) &#123; x -= mod; &#125; &#125; int n; struct myhnb &#123; int m; int sg[maxn]; int ss[maxn]; struct Edge &#123; int to, nxt; &#125; e[maxn]; int first[maxn]; int cnt = 0; inline void add_edge(int u, int v) &#123; if (u &gt; v) &#123; swap(u, v); &#125; e[++cnt].nxt = first[u]; first[u] = cnt; e[cnt].to = v; &#125; int vis[maxn]; myhnb() &#123; memset(first, 0, sizeof(first)); memset(ss, 0, sizeof(ss)); memset(vis, 0, sizeof(vis)); &#125; inline void Dfs() &#123; for (int now = n; now; --now) &#123; vis[now] = true; set&lt;int&gt; sgg; sgg.clear(); for (int i = first[now]; i; i = e[i].nxt) &#123; sgg.insert(sg[e[i].to]); &#125; sg[now] = 0; while (sgg.count(sg[now])) &#123; sg[now]++; &#125; add(ss[sg[now]], bin[now]); &#125; &#125; inline int&amp; operator [] (int x) &#123; return ss[x]; &#125; &#125; d[3]; int main() &#123; read(n); bin[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; bin[i] = (LL) bin[i - 1] * di % mod; &#125; for (int i = 0; i &lt; 3; ++i) &#123; read(d[i].m); for (int j = 1; j &lt;= d[i].m; ++j) &#123; int u, v; read(u), read(v); d[i].add_edge(u, v); &#125; d[i].Dfs(); &#125; int ans = 0; for (int i = 0; i &lt;= 1000; ++i) &#123; for (int j = 0; j &lt;= 1000; ++j) &#123; add(ans, (LL) d[0][i] * d[1][j] % mod * d[2][i ^ j] % mod); &#125; &#125; writeln(ans); return 0; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://pufanyi.pages.dev/tags/DP/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"},{"name":"博弈","slug":"博弈","permalink":"https://pufanyi.pages.dev/tags/%E5%8D%9A%E5%BC%88/"}]},{"title":"AGC043D Merge Triplets","slug":"agc043_d","date":"2020-03-31T01:59:58.000Z","updated":"2020-03-31T01:59:58.000Z","comments":true,"path":"agc043_d/","link":"","permalink":"https://pufanyi.pages.dev/agc043_d/","excerpt":"给出一种生成长度为 3n3n3n 的排列 PPP 的方法：先生成一个长度为 3n3n3n 的排列 AAA，然后对于 ∀k∈[0,n−1]\\forall k\\in [0,n-1]∀k∈[0,n−1]，将 3n+1,3n+2,3n+33n + 1, 3n + 2, 3n + 33n+1,3n+2,3n+3 分成一块。有 nnn 个指针，开始指向这 nnn 个块的开头。每次选择这 nnn 个指针指向的数中最小的并将其放在 PPP 的末尾，将这个指针向后移一位，如果移出块了，将指针删除。回到 2 操作直到所有指针均被删除。现在要你求出，这样的方式共能生成多少种本质不同的排列 AAA，答案对 mmm 取模。1≤n≤2×103,108≤m≤109+71\\le n\\le 2\\times 10^3,10^8\\le m\\le 10^9+71≤n≤2×103,108≤m≤109+7","text":"给出一种生成长度为 3n3n3n 的排列 PPP 的方法：先生成一个长度为 3n3n3n 的排列 AAA，然后对于 ∀k∈[0,n−1]\\forall k\\in [0,n-1]∀k∈[0,n−1]，将 3n+1,3n+2,3n+33n + 1, 3n + 2, 3n + 33n+1,3n+2,3n+3 分成一块。有 nnn 个指针，开始指向这 nnn 个块的开头。每次选择这 nnn 个指针指向的数中最小的并将其放在 PPP 的末尾，将这个指针向后移一位，如果移出块了，将指针删除。回到 2 操作直到所有指针均被删除。现在要你求出，这样的方式共能生成多少种本质不同的排列 AAA，答案对 mmm 取模。1≤n≤2×103,108≤m≤109+71\\le n\\le 2\\times 10^3,10^8\\le m\\le 10^9+71≤n≤2×103,108≤m≤109+7首先我们不难发现这个序列在一定程度上肯定是有单调性的，因为本身这个生成的方式就是一个单调的过程。我们发现对于一个块 {a,b,c}\\{a,b,c\\}{a,b,c}，如果 a&gt;ba&gt;ba&gt;b，那 bbb 一定是紧跟在 aaa 后面的。而如果 a&lt;ba&lt;ba&lt;b，那么我们不难发现这个快可以分裂成两个，也就是 {a},{b,c}\\{a\\},\\{b,c\\}{a},{b,c}，因为 bbb 肯定在 aaa 之后选。那么也就是说，我们现在的情况是，有一些长度为 1,2,31,2,31,2,3 的块，每个块都是的开头都是最大的。这给我们了一个提示，因为这样的东西给了我们一个将构造方法和序列连结起来的桥梁。因为这个东西与序列一一对应，这个只要将首字母排序一下就可以了。那么我们现在就只要考虑把划分后的块和划分前的块一一对应就可以了。也就是说我们需要找到其充要条件。我们发现，其实长度为 333 的块再多也不要紧，因为本来的块就是长度 333 的，我们考虑划分后的块。不难发现每次划分要么就是去掉一个长度为 333 的块，加上一个长度为 222 的块和一个 111 的块，要么就是将一个 222 的块划分成两个 111 的块。我们考虑这件事情，就不难发现这个条件了：222 的块数小于等于 111 的块数。现在我们只要将划分完的块拼起来就可以了。也就是说，一个序列合法的充要条件是：存在一种划分方案，使得划分后每个块大小小于等于 333，而且每个块的开头是块中最大的，且比其之前的数都要大。经过之前的推导，我们也知道了这种划分方案是唯一的。我们思考这东西怎么计算，我们先考虑如果划分方案已经给出，数字随便填，这样有几种方案。我们发现，一些限制就是：aia_iai​ 在 [1,r][1,r][1,r] 中是最大的。如果长度为 nnn，那么答案就是 n!∏r\\frac{n!}{\\prod r}∏rn!​。于是我们用这个性质就可以 dp 了。我们令 fi,jf_{i,j}fi,j​ 表示如果排列的长度为 iii（只能填前 iii 个数），长度为 111 的块的个数减去长度为 222 的块的个数为 jjj 的方案数。其实就是考虑右面加一个什么样的块。根据上面的式子，我们不难得到：{fi+1,j+1←fi,ji+1 被除掉了 fi+2,j−1←fi,j⋅(i+1)i+2 被除掉了fi+3,j←fi,j⋅(i+1)⋅(i+2)i+3 被除掉了\\begin{cases} f_{i+1,j+1}&amp;\\leftarrow&amp;f_{i,j}&amp;\\text{$i+1$ 被除掉了}\\\\ f_{i+2,j-1}&amp;\\leftarrow&amp;f_{i,j}\\cdot(i+1)&amp;\\text{$i+2$ 被除掉了}\\\\ f_{i+3,j}&amp;\\leftarrow&amp;f_{i,j}\\cdot(i+1)\\cdot(i+2)&amp;\\text{$i+3$ 被除掉了} \\end{cases}⎩⎪⎨⎪⎧​fi+1,j+1​fi+2,j−1​fi+3,j​​←←←​fi,j​fi,j​⋅(i+1)fi,j​⋅(i+1)⋅(i+2)​i+1 被除掉了 i+2 被除掉了 i+3 被除掉了 ​ 然后就可以愉快地转移啦！1234567891011121314151617181920212223242526272829303132333435namespace dfcmd &#123; typedef long long LL; const int maxn = 2000; const int base = maxn * 3 + 2; int n, mod; int f[maxn * 3 + 5][maxn * 6 + 5]; inline void add(int&amp; x, int y) &#123; x += y; if (x &gt;= mod) &#123; x -= mod; &#125; &#125; int main() &#123; read(n), read(mod); n *= 3; f[0][base] = 1; for (register int i = 0; i &lt; n; ++i) &#123; for (register int j = 1; j &lt;= base &lt;&lt; 1; ++j) &#123; add(f[i + 1][j + 1], f[i][j]); add(f[i + 2][j - 1], (LL) f[i][j] * (i + 1) % mod); add(f[i + 3][j], (LL) f[i][j] * (i + 1) * (i + 2) % mod); &#125; &#125; int ans = 0; for (int i = base; i &lt;= base &lt;&lt; 1; ++i) &#123; add(ans, f[n][i]); &#125; writeln(ans); return 0; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://pufanyi.pages.dev/tags/DP/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"}]},{"title":"AGC041F Histogram Rooks","slug":"agc041_f","date":"2020-03-18T16:00:00.000Z","updated":"2020-03-18T16:00:00.000Z","comments":true,"path":"agc041_f/","link":"","permalink":"https://pufanyi.pages.dev/agc041_f/","excerpt":"有一个 n×nn\\times nn×n 的棋盘（n≤300n\\le 300n≤300），然后对于每一列，考虑将所有该列纵坐标大于等于 aia_iai​ 的格子全部删掉。在剩余期盼中，问有多少种放车的方案能使每个格子都能被至少一个车攻击到。","text":"有一个 n×nn\\times nn×n 的棋盘（n≤300n\\le 300n≤300），然后对于每一列，考虑将所有该列纵坐标大于等于 aia_iai​ 的格子全部删掉。在剩余期盼中，问有多少种放车的方案能使每个格子都能被至少一个车攻击到。首先考虑到这样一件事情，就是如果用 &lt;l,r,h&gt;\\left&lt;l,r,h\\right&gt;⟨l,r,h⟩ 表示的是 [l,r][l,r][l,r] 区间内，纵坐标大于 hhh 的格子，我们定义一个这样的三元组为一个状态。然后我们考虑对于每个状态，它里面的格子，如果要合法的话，每一列一定是下面三种中的其中一种：这一列中至少有一个车。这时候的话，这一列中的每个格子就一定合法。这一列没有车，但是这些格子都被一个车覆盖到了，也就是说这个二元组所包含的格子中没有。这一列没有车，而且部分格子并没有被车覆盖到，这时候，就这一列只能在 hhh 下面有车才能合法。现在我们考虑 dp，ft,i,jf_{t,i,j}ft,i,j​ 表示状态为 ttt 的时候，现在有 iii 个 222 类点，jjj 个 333 类点，那么显然 111 类点就是 r−l+1−i−jr-l+1-i-jr−l+1−i−j 个。然后我们考虑转移，我们考虑 ttt 所表示的方格是否完全被分成了两块，也就是 hhh 是否跟 [l,r][l,r][l,r] 中最小的 aaa 相等。如果是的话，那么我们就将其分成两半进行 dp，记左边那个状态为 l(t)l(t)l(t)，右边为 r(t)r(t)r(t)，那么我们可以得到转移 ft,i,j+1=∑a,bfl(t),a,b⋅fr(t),i−a,j−bf_{t,i,j+1}=\\sum_{a,b}f_{l(t),a,b}\\cdot f_{r(t),i-a,j-b}ft,i,j+1​=∑a,b​fl(t),a,b​⋅fr(t),i−a,j−b​，因为两块是不相干的。然后我们如果没有，也就是说我们要从 &lt;l,r,h+1&gt;\\left&lt;l,r,h+1\\right&gt;⟨l,r,h+1⟩ 向 &lt;l,r,h&gt;\\left&lt;l,r,h\\right&gt;⟨l,r,h⟩ 转移。我们令 u=&lt;l,r,h+1&gt;u=\\left&lt;l,r,h+1\\right&gt;u=⟨l,r,h+1⟩，k,i,jk,i,jk,i,j 分别表示三类列的数量。这个转移需要分 222 中情况讨论： 如果这一行不放车：ft,0,i+j←fu,i,jf_{t,0,i+j}\\leftarrow f_{u,i,j}ft,0,i+j​←fu,i,j​。如果这一行的车只放在一类列上：ft,i,j←fu,i,j⋅(2k1−1)f_{t,i,j}\\leftarrow f_{u,i,j}\\cdot (2^{k_1}-1)ft,i,j​←fu,i,j​⋅(2k1​−1)。如果 xxx 个车放在 222 类列，yyy 个车放在 333 类列：ft,i−x,j−y←fu,i,j⋅(ix)(jy)⋅2kf_{t,i-x,j-y}\\leftarrow f_{u,i,j}\\cdot\\binom{i}{x}\\binom{j}{y}\\cdot2^{k}ft,i−x,j−y​←fu,i,j​⋅(xi​)(yj​)⋅2k。我们考虑优化这个 dp。我们发现对于一个状态 ttt，有两种形式：每一行都至少有一辆车。有一行没有车。为什么要把这两种分开来讨论呢？我们考虑这两种有什么不一样。第一种形式，都有一个车，那么就没有第 333 类列了，否则如果是第二种形式，那就最终就没有第 222 类列了。这样子，其实我们就相当于分两种情况，把 222 类列和 333 类列看成是一个东西一起转移了，可以把她们放在同一维里，然后加一维 0/10/10/1 即可。这样第二种转移的时候，我们也只要枚举一维 xxx 表示 2,32,32,3 类列总的放车个数，考虑到复杂度为 ∑ℓ2\\sum \\ell^2∑ℓ2，ℓ\\ellℓ 表示的是每个有用状态的长度，不难发现复杂度为 O(n3)\\mathcal{O}(n^3)O(n3)。upd：啥听说这题 std 被艹了？算了先鸽着，丢个 链接，应该会补的（","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://pufanyi.pages.dev/tags/DP/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"}]},{"title":"AGC041E Balancing Network","slug":"agc041_e","date":"2020-03-10T16:00:00.000Z","updated":"2020-03-10T16:00:00.000Z","comments":true,"path":"agc041_e/","link":"","permalink":"https://pufanyi.pages.dev/agc041_e/","excerpt":"有 nnn 条线 mmm 个平衡器，从左往右第 iii 个平衡器连接了 xi,yix_i,y_ixi​,yi​ 条电线（1≤xi&lt;yi≤n1\\le x_i&lt;y_i\\le n1≤xi​&lt;yi​≤n），每个平衡器都有一个状态：向上或向下。考虑一个令牌，从最左边的某一条导线开始，如果在第 iii 个位置，如果他在 xix_ixi​ 导线上且平衡器状态向下，那么就到 yiy_iyi​，同理如果在 yiy_iyi​ 且状态向上，则到 xix_ixi​。记 kik_iki​ 表示令牌从导线 iii 开始到无穷远处是他在哪条导线上。让你构造两种解，每种解用一个字符串表示，表示每个平衡器的状态。第一组解要求所有的 kik_iki​ 相等，第二组接要求至少有两个 kik_iki​ 不相等。无解输出 −1-1−1。数据范围 2≤n≤5×104, 1≤m≤1052\\le n\\le 5\\times 10^4,\\,1\\le m\\le 10^52≤n≤5×104,1≤m≤105。","text":"有 nnn 条线 mmm 个平衡器，从左往右第 iii 个平衡器连接了 xi,yix_i,y_ixi​,yi​ 条电线（1≤xi&lt;yi≤n1\\le x_i&lt;y_i\\le n1≤xi​&lt;yi​≤n），每个平衡器都有一个状态：向上或向下。考虑一个令牌，从最左边的某一条导线开始，如果在第 iii 个位置，如果他在 xix_ixi​ 导线上且平衡器状态向下，那么就到 yiy_iyi​，同理如果在 yiy_iyi​ 且状态向上，则到 xix_ixi​。记 kik_iki​ 表示令牌从导线 iii 开始到无穷远处是他在哪条导线上。 让你构造两种解，每种解用一个字符串表示，表示每个平衡器的状态。第一组解要求所有的 kik_iki​ 相等，第二组接要求至少有两个 kik_iki​ 不相等。无解输出 −1-1−1。 数据范围 2≤n≤5×104, 1≤m≤1052\\le n\\le 5\\times 10^4,\\,1\\le m\\le 10^52≤n≤5×104,1≤m≤105。 一道有趣的构造题。 首先我们考虑构造第一组解。我们考虑从后往前做，枚举 ttt 判断是否有一组解使得最终所有 ki=tk_i=tki​=t。令 fi,jf_{i,j}fi,j​ 表示仅有最后 iii 个平衡器时，第 jjj 条线上的令牌是否到了 ttt。考虑在最前面加一个平衡器。发现其实就是 fi+1,xn−i=fi+1,yn−i=fi,xj∨fi,yn−if_{i+1,x_{n-i}}=f_{i+1,y_{n-i}}=f_{i,x_j}\\vee f_{i,y_{n-i}}fi+1,xn−i​​=fi+1,yn−i​​=fi,xj​​∨fi,yn−i​​。因为只要有一条线上可以到达 ttt，我们可以将两条线上的令牌都导到这条线上。 考虑上面的做法将第一维滚掉之后是 O(m)\\mathcal{O}(m)O(m) 的，于是我们得到了一个 O(nm)\\mathcal{O}(nm)O(nm) 的算法。考虑优化，我们令 gi,j,tg_{i,j,t}gi,j,t​ 表示最后 iii 个，第 jjj 条线是否能到达 ttt。我们考虑转移就是 gi+1,xn−i,t=gi+1,yn−i,t=gi,xn−i,t∨gi,yn−i,tg_{i+1,x_{n-i},t}=g_{i+1,y_{n-i},t}=g_{i,x_{n-i},t}\\vee g_{i,y_{n-i},t}gi+1,xn−i​,t​=gi+1,yn−i​,t​=gi,xn−i​,t​∨gi,yn−i​,t​。不难发现这个东西可以用 bitset 进行优化。常数 164\\frac{1}{64}641​，可以过。 然后考虑构造，这就简单了，直接沿着一个有解的 ttt，继续做一遍上面的 dp 即可。 然后考虑第二问，首先我们发现之后当 n=2n=2n=2 的时候才会发生无解。其余时刻都不会，至于为什么，我们考虑一下的构造方法。 仍然考虑倒着做，fi,jf_{i,j}fi,j​ 表示加入最后的 iii 个平衡器，第 jjj 根线上的令牌现在在哪儿。 我们考虑加入一个令牌，那只会有两种状态：fi+1,xn−i=fi+1,yn−i=fi,xn−if_{i+1,x_{n-i}}=f_{i+1,y_{n-i}}=f_{i,x_{n-i}}fi+1,xn−i​​=fi+1,yn−i​​=fi,xn−i​​ 或是 fi+1,xn−i=fi+1,yn−i=fi,yn−if_{i+1,x_{n-i}}=f_{i+1,y_{n-i}}=f_{i,y_{n-i}}fi+1,xn−i​​=fi+1,yn−i​​=fi,yn−i​​。而最终的目的是让至少有两个 fff 值是不相等的。那么我们考虑 gi,jg_{i,j}gi,j​ 表示 fi,k=jf_{i,k}=jfi,k​=j 的数量。这样我们只要比较两个 fff 的 ggg，看看那个多，让多的给少的一个。考虑到 n&gt;2n&gt;2n&gt;2，每次将一个 ggg 加 111，一个 ggg 减 111。不难发现一定有两个 ggg 是大于 000 的。于是一定有一种方案合法。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://pufanyi.pages.dev/tags/%E6%9E%84%E9%80%A0/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"}]},{"title":"一个镜像","slug":"gitee镜像","date":"2020-03-04T16:00:00.000Z","updated":"2020-03-04T16:00:00.000Z","comments":true,"path":"gitee镜像/","link":"","permalink":"https://pufanyi.pages.dev/gitee%E9%95%9C%E5%83%8F/","excerpt":"","text":"2021-08-17 upd: gitee 被封了，说是有一些违规内容。找了半天找不到，那就算了不更镜像了。由于最近 github.io 有些不稳定，我做了个 镜像，会不定期同步博客上的内容。","categories":[{"name":"公告","slug":"公告","permalink":"https://pufanyi.pages.dev/categories/%E5%85%AC%E5%91%8A/"}],"tags":[]},{"title":"AGC041D Problem Scores","slug":"agc041_d","date":"2020-03-03T16:00:00.000Z","updated":"2020-03-03T16:00:00.000Z","comments":true,"path":"agc041_d/","link":"","permalink":"https://pufanyi.pages.dev/agc041_d/","excerpt":"问存在多少个长度为 n (2≤n≤5000)n\\,(2\\le n\\le 5000)n(2≤n≤5000) 的单调不减序列 aaa，满足 1≤ai≤n1\\le a_i\\le n1≤ai​≤n，且对于任意 k (1≤k&lt;n)k\\,(1\\le k&lt;n)k(1≤k&lt;n)，都有：对任意大小为 kkk 的子集 SSS 和大小为 k+1k+1k+1 的子集 TTT，满足 ∑x∈SAx&lt;∑x∈TAx\\sum_{x\\in S}A_x&lt;\\sum_{x\\in T}A_x∑x∈S​Ax​&lt;∑x∈T​Ax​。答案对大质数 mmm 取模。","text":"问存在多少个长度为 n (2≤n≤5000)n\\,(2\\le n\\le 5000)n(2≤n≤5000) 的单调不减序列 aaa，满足 1≤ai≤n1\\le a_i\\le n1≤ai​≤n，且对于任意 k (1≤k&lt;n)k\\,(1\\le k&lt;n)k(1≤k&lt;n)，都有：对任意大小为 kkk 的子集 SSS 和大小为 k+1k+1k+1 的子集 TTT，满足 ∑x∈SAx&lt;∑x∈TAx\\sum_{x\\in S}A_x&lt;\\sum_{x\\in T}A_x∑x∈S​Ax​&lt;∑x∈T​Ax​。答案对大质数 mmm 取模。首先需要发现一个性质，就是如果 k=⌊n2⌋k=\\left\\lfloor\\frac{n}{2}\\right\\rfloork=⌊2n​⌋ 的时候满足了，那么其他的 kkk 都能满足。为什么呢？首先是对于每个 kkk，显然如果满足了 ∑i=1k+1ai≥∑i=n−k+1nai\\sum_{i=1}^{k+1}a_i\\ge \\sum_{i=n-k+1}^na_i∑i=1k+1​ai​≥∑i=n−k+1n​ai​，就满足所有的 SSS 和 TTT 了。然后如果满足了 k=⌊n2⌋k=\\left\\lfloor\\frac{n}{2}\\right\\rfloork=⌊2n​⌋ 的情况，如果 k&gt;⌊n2⌋k&gt;\\left\\lfloor\\frac{n}{2}\\right\\rfloork&gt;⌊2n​⌋，考虑到序列单调不降，左边加上一个较大的数，右边加上一个较小的数，那么不等式肯定仍然成立。否则，如果 k&lt;⌊n2⌋k&lt;\\left\\lfloor\\frac{n}{2}\\right\\rfloork&lt;⌊2n​⌋，其实就是左边减去一个较小的数，右边加上一个较大的数，不等式也仍然成立。那这个东西有什么用呢，我们考虑对一波式子。首先我们需要去掉一个单调性，我们构造一个差分数组 Δai=ai−ai−1\\Delta a_i=a_i-a_{i-1}Δai​=ai​−ai−1​，为了不让 Δa1\\Delta a_1Δa1​ 奇怪，我们就让 a0=1a_0=1a0​=1，这样子其实就是 ai=1+∑i=1nΔaia_i=1+\\sum_{i=1}^n\\Delta a_iai​=1+∑i=1n​Δai​，然后我们的式子就变成了：∑i=1⌊n2⌋+1∑j=1iΔaj≥∑i=n−⌊n2⌋+1n∑j=1iΔaj\\sum_{i=1}^{\\left\\lfloor\\frac{n}{2}\\right\\rfloor+1}\\sum_{j=1}^i\\Delta a_j\\ge \\sum_{i=n-\\left\\lfloor\\frac{n}{2}\\right\\rfloor+1}^n\\sum_{j=1}^i\\Delta a_ji=1∑⌊2n​⌋+1​j=1∑i​Δaj​≥i=n−⌊2n​⌋+1∑n​j=1∑i​Δaj​这个下取整感觉很难受，我们就直接将 nnn 奇偶讨论好了：当 nnn 是奇数时，⌊n2⌋=n−12\\left\\lfloor\\frac{n}{2}\\right\\rfloor=\\frac{n-1}{2}⌊2n​⌋=2n−1​，也就是原式就变成了：∑i=1n+12∑j=1iΔaj≥∑i=n+12+1n∑j=1iΔaj\\sum_{i=1}^{\\frac{n+1}{2}}\\sum_{j=1}^i\\Delta a_j\\ge \\sum_{i=\\frac{n+1}{2}+1}^n\\sum_{j=1}^i\\Delta a_ji=1∑2n+1​​j=1∑i​Δaj​≥i=2n+1​+1∑n​j=1∑i​Δaj​两边都加个 ∑i=1n+12∑j=1iΔaj\\sum_{i=1}^{\\frac{n+1}{2}}\\sum_{j=1}^i\\Delta a_j∑i=12n+1​​∑j=1i​Δaj​ 把右边给补一下：2∑i=1n+12∑j=1iΔaj≥∑i=1n∑j=1iΔaj2\\sum_{i=1}^{\\frac{n+1}{2}}\\sum_{j=1}^i\\Delta a_j\\ge \\sum_{i=1}^n\\sum_{j=1}^i\\Delta a_j2i=1∑2n+1​​j=1∑i​Δaj​≥i=1∑n​j=1∑i​Δaj​根据套路，我们需要把前面的 Σ\\SigmaΣ 拆掉，于是我们拆掉它：2∑i=1n+12(n+12−i+1)Δai≥∑i=1n(n−i+1)Δai2\\sum_{i=1}^{\\frac{n+1}{2}}\\left(\\frac{n+1}{2}-i+1\\right)\\Delta a_i\\ge \\sum_{i=1}^n\\left(n-i+1\\right)\\Delta a_i2i=1∑2n+1​​(2n+1​−i+1)Δai​≥i=1∑n​(n−i+1)Δai​考虑我们将 aia_iai​ 差分的目的，其实就是想把左边的式子减过去，然后合并起来：∑i=1nciΔai≤0\\sum_{i=1}^nc_i\\Delta a_i\\le 0i=1∑n​ci​Δai​≤0其中 ci={i−2i≤n+12n−i+1i&gt;n+12c_i= \\begin{cases} i-2 &amp; i\\le \\frac{n+1}{2}\\\\ n-i+1 &amp; i&gt;\\frac{n+1}{2} \\end{cases}ci​={i−2n−i+1​i≤2n+1​i&gt;2n+1​​ 同样地，我们来考虑 nnn 是偶数的情况：∑i=1n2∑j=1iΔaj≥∑i=n2+2n∑j=1iΔaj\\sum_{i=1}^{\\frac{n}{2}}\\sum_{j=1}^i\\Delta a_j\\ge \\sum_{i=\\frac{n}{2}+2}^n\\sum_{j=1}^i\\Delta a_ji=1∑2n​​j=1∑i​Δaj​≥i=2n​+2∑n​j=1∑i​Δaj​补一补：2∑i=1n2∑j=1iΔaj≥∑i=1n∑j=1iΔaj−∑i=1n2+1Δai2\\sum_{i=1}^{\\frac{n}{2}}\\sum_{j=1}^i\\Delta a_j\\ge \\sum_{i=1}^n\\sum_{j=1}^i\\Delta a_j-\\sum_{i=1}^{\\frac{n}{2}+1}\\Delta a_i2i=1∑2n​​j=1∑i​Δaj​≥i=1∑n​j=1∑i​Δaj​−i=1∑2n​+1​Δai​拆个 Σ\\SigmaΣ：2∑i=1n2(n2−i+1)Δai≥∑i=1n(n−i+1)Δai−∑i=1n2+1Δai2\\sum_{i=1}^{\\frac{n}{2}}\\left(\\frac{n}{2}-i+1\\right)\\Delta a_i\\ge \\sum_{i=1}^n\\left(n-i+1\\right)\\Delta a_i-\\sum_{i=1}^{\\frac{n}{2}+1}\\Delta a_i2i=1∑2n​​(2n​−i+1)Δai​≥i=1∑n​(n−i+1)Δai​−i=1∑2n​+1​Δai​写成 ∑ciΔai≤0\\sum c_i\\Delta a_i\\le 0∑ci​Δai​≤0 的形式，可以得到：ci={i−2i≤n2n−ii=n2+1n−i+1i&gt;n2+1c_i= \\begin{cases} i-2 &amp; i\\le\\frac{n}{2}\\\\ n-i &amp; i=\\frac{n}{2}+1\\\\ n-i+1 &amp; i&gt;\\frac{n}{2}+1 \\end{cases}ci​=⎩⎪⎨⎪⎧​i−2n−in−i+1​i≤2n​i=2n​+1i&gt;2n​+1​不难发现当 i=n2+1i=\\frac{n}{2}+1i=2n​+1 时，n−i=n2−1=i−2n-i=\\frac{n}{2}-1=i-2n−i=2n​−1=i−2，所以：ci={i−2i≤n2+1n−i+1i&gt;n2+1c_i= \\begin{cases} i-2 &amp; i\\le\\frac{n}{2}+1\\\\ n-i+1 &amp; i&gt;\\frac{n}{2}+1 \\end{cases}ci​={i−2n−i+1​i≤2n​+1i&gt;2n​+1​综合奇偶两个式子，我们均可以得到：∑i=1nciΔai≤0\\sum_{i=1}^nc_i\\Delta a_i\\le 0i=1∑n​ci​Δai​≤0其中 ci={i−2i≤⌊n2⌋+1n−i+1i&gt;⌊n2⌋+1c_i= \\begin{cases} i-2 &amp; i\\le\\left\\lfloor\\frac{n}{2}\\right\\rfloor+1\\\\ n-i+1 &amp; i&gt;\\left\\lfloor\\frac{n}{2}\\right\\rfloor+1 \\end{cases}ci​={i−2n−i+1​i≤⌊2n​⌋+1i&gt;⌊2n​⌋+1​ 我们回到题目，除了这个条件，我们再回过头来看看有什么缺的条件，仔细找了找好像只有 ∑Δai+1≤n\\sum\\Delta a_i+1\\le n∑Δai​+1≤n 了。于是我们考虑确定 a2∼ana_2\\sim a_na2​∼an​ 的值，然后回过头来看看有多少个符合条件的 a1a_1a1​。我们发现只有两个条件：{a1≤n−1−∑i=2naia1≥∑i=2nciai\\begin{cases} a_1\\le n-1-\\sum_{i=2}^na_i\\\\ a_1\\ge \\sum_{i=2}^nc_ia_i \\end{cases}{a1​≤n−1−∑i=2n​ai​a1​≥∑i=2n​ci​ai​​于是满足条件的 a1a_1a1​ 个数就是：max⁡(0,n−∑i=2n(ci+1)ai)\\max\\left(0, n-\\sum_{i=2}^n\\left(c_i+1\\right)a_i\\right)max(0,n−i=2∑n​(ci​+1)ai​)我们令 fif_ifi​ 表示 ∑j=2n(cj+1)aj=i\\sum_{j=2}^n\\left(c_j+1\\right)a_j=i∑j=2n​(cj​+1)aj​=i 的方案数，那么最终的答案就是 ∑i=0n−1(n−i)⋅fi\\sum_{i=0}^{n-1} (n-i)\\cdot f_i∑i=0n−1​(n−i)⋅fi​。我们最后要做的一件事情就是计算 fif_ifi​ 了，不难发现其实就是一个背包，第 iii 个物品重量 cic_ici​，可以选 aia_iai​ 个，直接大力 dp 过去即可。于是复杂度 O(n2)\\mathcal{O}(n^2)O(n2)。代码","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://pufanyi.pages.dev/tags/DP/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"}]},{"title":"ARC099F Eating Symbols Hard","slug":"arc099_d","date":"2020-03-03T16:00:00.000Z","updated":"2020-03-03T16:00:00.000Z","comments":true,"path":"arc099_d/","link":"","permalink":"https://pufanyi.pages.dev/arc099_d/","excerpt":"有一段标号从 −∞-\\infty−∞ 到 +∞+\\infty+∞ 的序列 AAA，初始是 Ai=0A_i=0Ai​=0。现在有一个人在 000 位置，有一段操作序列 sss，依次进行操作。假设 iii 时刻这个人在位置 ppp，如果 sis_isi​ 是 '+'，则将 ApA_pAp​ 加 111，如果是 '-'，则减 111；如果是 '&lt;' 则该人左移一格，否则是 '&gt;' 则右移一格。要求数出 sss 的所有连续子串中最终得到的 AAA 与 sss 最终得到相同 AAA 序列的个数。数据范围 ∣s∣≤250000|s|\\le 250000∣s∣≤250000。","text":"有一段标号从 −∞-\\infty−∞ 到 +∞+\\infty+∞ 的序列 AAA，初始是 Ai=0A_i=0Ai​=0。现在有一个人在 000 位置，有一段操作序列 sss，依次进行操作。 假设 iii 时刻这个人在位置 ppp，如果 sis_isi​ 是 '+'，则将 ApA_pAp​ 加 111，如果是 '-'，则减 111；如果是 '&lt;' 则该人左移一格，否则是 '&gt;' 则右移一格。 要求数出 sss 的所有连续子串中最终得到的 AAA 与 sss 最终得到相同 AAA 序列的个数。 数据范围 ∣s∣≤250000|s|\\le 250000∣s∣≤250000。 考虑构造一波类似生成函数的东西 f(x)=∑i=−∞+∞Aixif(x)=\\sum_{i=-\\infty}^{+\\infty}A_ix^if(x)=∑i=−∞+∞​Ai​xi，另外还有一个指针 ggg，开始是 ggg 指向 000 位置，显然初始时 f(x)=0f(x)=0f(x)=0。 我们令 fi(x)f_i(x)fi​(x) 表示 1∼i1\\sim i1∼i 这一段子串操作所得到的 fff 值，gig_igi​ 表示 1∼i1\\sim i1∼i 操作后的指针位置。考虑在末尾加入一个字符 ccc，如果 ccc 是 '+' 或 '-'，那显然 {fi(x)=fi−1(x)±xgigi=gi−1\\begin{cases}f_i(x)=f_{i-1}(x)\\pm x^{g_i}\\\\g_i=g_{i-1}\\end{cases}{fi​(x)=fi−1​(x)±xgi​gi​=gi−1​​，同理如果 ccc 是 '&lt;' 或 '&gt;'，那显然 {fi(x)=fi−1(x)gi=gi−1∓1\\begin{cases}f_i(x)=f_{i-1}(x)\\\\g_i=g_{i-1}\\mp 1\\end{cases}{fi​(x)=fi−1​(x)gi​=gi−1​∓1​。 如果要计算 [l,r][l,r][l,r] 的 fff 值，不难发现就是 fr(x)−fl−1(x)xgl−1\\frac{f_r(x)-f_{l-1}(x)}{x^{g_{l-1}}}xgl−1​fr​(x)−fl−1​(x)​。 于是我们要算的就是 fn(x)=fr(x)−fl−1(x)xgl−1f_n(x)=\\frac{f_r(x)-f_{l-1}(x)}{x^{g_{l-1}}}fn​(x)=xgl−1​fr​(x)−fl−1​(x)​，考虑随便选一个 xxx，算出这个多项式的值然后哈希一下即可。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://pufanyi.pages.dev/tags/DP/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"},{"name":"hash","slug":"hash","permalink":"https://pufanyi.pages.dev/tags/hash/"}]},{"title":"AGC029F Construction of a tree","slug":"agc029_f","date":"2020-02-22T16:00:00.000Z","updated":"2020-02-22T16:00:00.000Z","comments":true,"path":"agc029_f/","link":"","permalink":"https://pufanyi.pages.dev/agc029_f/","excerpt":"题意大概就是给你 n−1n-1n−1 个点集，全集是 {1,2,…,n}\\{1,2,\\dots, n\\}{1,2,…,n}，现在要从每个点点集中抽出两个点来连边，最终形成一棵树。让你输出方案或判断无解。nnn 有 10510^5105，所有集合大小之和不超过 2×1052\\times 10^52×105。","text":"题意大概就是给你 n−1n-1n−1 个点集，全集是 {1,2,…,n}\\{1,2,\\dots, n\\}{1,2,…,n}，现在要从每个点点集中抽出两个点来连边，最终形成一棵树。让你输出方案或判断无解。nnn 有 10510^5105，所有集合大小之和不超过 2×1052\\times 10^52×105。 考虑构造，儿子向父亲连边。也就是说，每个集合最后都是儿子 →\\to→ 父亲的一条边，那么我们可以随便选一个点作为跟，其余点肯定对应一个集合，表示这个集合所对应的边，一端是他，另一端是他父亲。其实也就是一个匹配，左边是除了根节点以外的所有点，右边是所有点集。点与点集有边当且仅当这个点在点集中出现。 显然地，如果这个匹配无解那么最终肯定无解，因为根本找不到一个完美的儿子 →\\to→ 父亲的映射。找到匹配之后我们把根加上去，跟前面的连法一样。如果连上之后这张图仍然不连通，那么显然无解，因为两个独立的连通块显然没有生成树。 那如果上面的判掉之后是否就一定有解了呢？我们考虑构造解。我们从根节点开始 bfs，我们考虑根节点所有连出去的集合，这些集合的匹配点的父亲都定作是这个根，然后这样递归下去。不难发现，这样做是肯定有解的。 考虑复杂度，边数 mmm 是集合的总大小，用 Dinic 做二分图匹配，复杂度 O(mn)\\mathcal{O}(m\\sqrt{n})O(mn​)，之后的构造解复杂度 O(m)\\mathcal{O}(m)O(m)，所以总复杂度 O(mn)\\mathcal{O}(m\\sqrt{n})O(mn​)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://pufanyi.pages.dev/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"}]},{"title":"AGC024D Isomorphism Freak","slug":"agc024_d","date":"2020-02-18T16:00:00.000Z","updated":"2020-02-18T16:00:00.000Z","comments":true,"path":"agc024_d/","link":"","permalink":"https://pufanyi.pages.dev/agc024_d/","excerpt":"定义一棵树上两个点等价当且仅当以这两个点为根的有根树同构，一棵树的权值定义为这棵树的等价类个数。给出一棵 nnn 个点的树，可以在这棵树基础不断的加叶子，使得最后树的权值最小，求出这个权值，以及满足之前条件的所有树中最小叶子数。数据范围 n≤100n\\le 100n≤100。","text":"定义一棵树上两个点等价当且仅当以这两个点为根的有根树同构，一棵树的权值定义为这棵树的等价类个数。 给出一棵 nnn 个点的树，可以在这棵树基础不断的加叶子，使得最后树的权值最小，求出这个权值，以及满足之前条件的所有树中最小叶子数。 数据范围 n≤100n\\le 100n≤100。 我们发现其实最终所得的树只有两种，一种是以一条边为中心，左右两边同构，一种是以点为中心，呈放射状分布。 其实这两种都一样，以边为放射状的只要把这条边看成一个点就可以了。 这样我们考虑枚举中心，要求其权值，首先不难发现同构的数量其实就是以中心为根的树的深度。然后我们考虑叶子个数，我们只要想想构造这棵树的过程，其实就是把每一层深度的所有点的儿子数补成相同，那么补完后树的叶子个数就是每层非叶子节点儿子个数的乘积，对于原树来讲就是每层儿子树最多的儿子个数的乘积。 复杂度 O(n2)\\mathcal{O}(n^2)O(n2)，开 100100100 大概是为了不爆 long long。 这里是代码","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://pufanyi.pages.dev/tags/%E8%B4%AA%E5%BF%83/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"}]},{"title":"CodeForces 512D Fox And Travelling","slug":"CF512D","date":"2020-02-13T16:00:00.000Z","updated":"2020-02-13T16:00:00.000Z","comments":true,"path":"CF512D/","link":"","permalink":"https://pufanyi.pages.dev/CF512D/","excerpt":"有一张 nnn 个点 mmm 条边的简单无向图，每次选择一个度数小于等于 111 的点然后将其删除，对于每个 kkk 求删去 kkk 个点的方案数。n≤100, m≤n×(n−1)2n\\le 100,\\,m\\le \\frac{n\\times(n-1)}{2}n≤100,m≤2n×(n−1)​。","text":"有一张 nnn 个点 mmm 条边的简单无向图，每次选择一个度数小于等于 111 的点然后将其删除，对于每个 kkk 求删去 kkk 个点的方案数。n≤100, m≤n×(n−1)2n\\le 100,\\,m\\le \\frac{n\\times(n-1)}{2}n≤100,m≤2n×(n−1)​。 首先环上点肯定删不掉，如果一个连通块之间有两个环，那么被两个环夹着的点肯定也删不掉。 接下来我们考虑两件事情，一件事情就是如果一个连通块本身不是一棵树，那么如果它的一部分点能被删掉，那这部分点肯定组成一个森林，每棵树肯定之靠着一个环。外面的点先被删，而环旁边的点是最后被删的，那我们相当于对于每棵树就可以以环旁边那个点为根，然后 dp 上去。这个 dp 很方便，考虑到没两个点只会在其 LCA 上被合并一次，所以这部分的复杂度是 O(n2)\\mathcal{O}(n^2)O(n2) 的。 然后我们考虑这个连通块本身就是一棵树的情况，这个情况下其实就是每个点都是可以作为 dp 的根的，这样做出来的话如果全删完那显然是对的，但是发现如果不删完的话是会算重的。我们考虑不删完的一种方案，如果留了 xxx 个节点，那么对于留下来的这 xxx 个节点，每个节点作为根 dp 的时候都会把这种方案算一遍。于是其实就是这种方案对答案的贡献是 xxx 而不是 111 了。于是我们就可以直接把 dp 出来的结构除以 xxx 便使答案了。 最后每个连通块的合并直接暴力卷一下就可以了，别忘了乘个组合数。 代码在这里","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"DP","slug":"DP","permalink":"https://pufanyi.pages.dev/tags/DP/"}]},{"title":"CodeForces 576D Flights for Regular Customers","slug":"CF576D","date":"2020-02-12T16:00:00.000Z","updated":"2020-02-12T16:00:00.000Z","comments":true,"path":"CF576D/","link":"","permalink":"https://pufanyi.pages.dev/CF576D/","excerpt":"有一张 nnn 个点 mmm 条边的无向图，第 iii 条边开通的条件是你已经走过了 did_idi​ 条边，问 1→n1\\to n1→n 至少需要走多少条边，或输出无解。n≤m≤150, 0≤di≤109n\\le m\\le 150,\\,0\\le d_i\\le 10^9n≤m≤150,0≤di​≤109。","text":"有一张 nnn 个点 mmm 条边的无向图，第 iii 条边开通的条件是你已经走过了 did_idi​ 条边，问 1→n1\\to n1→n 至少需要走多少条边，或输出无解。n≤m≤150, 0≤di≤109n\\le m\\le 150,\\,0\\le d_i\\le 10^9n≤m≤150,0≤di​≤109。 首先有一个 simple 的想法就是枚举路径上的 ddd 最大的边，然后先用比该边 ddd 小的边满足要求地走 did_idi​ 步，然后再用 ddd 小于等于该边的边走到终点。 我们考虑将边从大到小排序，首先要算出前 did_idi​ 步能到哪儿，这不难用矩乘，然后是走用小于等于 did_idi​ 的边走到终点，这一个 bfs 即可解决。 代码在这里","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"图论","slug":"图论","permalink":"https://pufanyi.pages.dev/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","permalink":"https://pufanyi.pages.dev/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"CodeForces 516D Drazil and Morning Exercise","slug":"CF516D","date":"2020-02-11T16:00:00.000Z","updated":"2020-02-11T16:00:00.000Z","comments":true,"path":"CF516D/","link":"","permalink":"https://pufanyi.pages.dev/CF516D/","excerpt":"给你一棵树，边有边权，定义 fx=max⁡i=1ndist⁡(x,i)f_x=\\max_{i=1}^n\\operatorname{dist}(x,i)fx​=maxi=1n​dist(x,i)。qqq 次询问，每次给出一个数 lll 求最大的连通块 sss 满足 max⁡x∈sfx−min⁡x∈sfx≤l\\max_{x\\in s}f_x-\\min_{x\\in s}f_x\\le lmaxx∈s​fx​−minx∈s​fx​≤l。n≤105,q≤50n\\le 10^5,q\\le 50n≤105,q≤50。","text":"给你一棵树，边有边权，定义 fx=max⁡i=1ndist⁡(x,i)f_x=\\max_{i=1}^n\\operatorname{dist}(x,i)fx​=maxi=1n​dist(x,i)。qqq 次询问，每次给出一个数 lll 求最大的连通块 sss 满足 max⁡x∈sfx−min⁡x∈sfx≤l\\max_{x\\in s}f_x-\\min_{x\\in s}f_x\\le lmaxx∈s​fx​−minx∈s​fx​≤l。n≤105,q≤50n\\le 10^5,q\\le 50n≤105,q≤50。 首先假设这棵树的直径的两个端点为 u,vu,vu,v，不难发现 fx=max⁡(dist⁡(u,x)v,x⁡)f_x=\\max(\\operatorname{dist}(u,x)\\operatorname{v,x})fx​=max(dist(u,x)v,x)。这个用证明直径的方法可以证明。 然后我们需要发现一个性质，那就是将点按照 fff 从大到小排序，那么儿子一定排在父亲的前面。 然后就好办了，我们考虑将点按 fff 从大到小排序，然后我们考虑在上面 two points，一边用并查集维护两个指针所在区间的联通性，插入一个点直接将其儿子合并，删除节点是发现只会删除叶子节点，不会改变连通性，只要把该连通块 size 减掉即可。 这里是代码","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"并查集","slug":"并查集","permalink":"https://pufanyi.pages.dev/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"two points","slug":"two-points","permalink":"https://pufanyi.pages.dev/tags/two-points/"}]},{"title":"CodeForces 575I Robots protection","slug":"CF575I","date":"2020-02-10T16:00:00.000Z","updated":"2020-02-10T16:00:00.000Z","comments":true,"path":"CF575I/","link":"","permalink":"https://pufanyi.pages.dev/CF575I/","excerpt":"你需要在平面直角坐标系上进行 qqq 次操作。每次操作有两种，要么放置一个两条直角边平行于坐标轴的等腰直角三角形，要么查询某一个点被多少个三角形覆盖。保证所有点的坐标都是整数且 ∈[1,n]\\in [1,n]∈[1,n]。n≤5×103,q≤105n \\le 5 \\times 10^3, q \\le 10^5n≤5×103,q≤105。","text":"你需要在平面直角坐标系上进行 qqq 次操作。每次操作有两种，要么放置一个两条直角边平行于坐标轴的等腰直角三角形，要么查询某一个点被多少个三角形覆盖。保证所有点的坐标都是整数且 ∈[1,n]\\in [1,n]∈[1,n]。n≤5×103,q≤105n \\le 5 \\times 10^3, q \\le 10^5n≤5×103,q≤105。 考虑到四种方向是对称的，我们只考虑其中一种情况，比如说直角顶点在左下角的情况，令三个顶点为 (x,y),(x+l,y),(x,y+l)(x,y), (x+l,y), (x,y+l)(x,y),(x+l,y),(x,y+l)。 首先我们发现需要加的所有点 (x′,y′)(x&#x27;,y&#x27;)(x′,y′)，都满足 x+y≤x′+y′≤x+y+lx+y\\le x&#x27;+y&#x27;\\le x+y+lx+y≤x′+y′≤x+y+l，这个东西用一棵树状数组就可以维护： 然后我们就是要减去这两块： 我们考虑如何减去，观察这些点的性质，首先均满足 x′+y′∈[x+y,x+y+l]x&#x27;+y&#x27;\\in [x+y,x+y+l]x′+y′∈[x+y,x+y+l]，然后其还满足 x′&lt;xx&#x27;&lt;xx′&lt;x 或 y′&lt;yy&#x27;&lt;yy′&lt;y。于是我们可以考虑开两棵二维树状数组，一棵维护下标 (x+y,x)(x+y,x)(x+y,x)，另一棵维护下标 (x+y,y)(x+y,y)(x+y,y)，然后在这两棵树状数组上矩阵加即可。 时间复杂度 O(qlog⁡2n)\\mathcal{O}(q\\log^2n)O(qlog2n)，空间 O(n2)\\mathcal{O}(n^2)O(n2)。 代码在这儿 。","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"数据结构","slug":"数据结构","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树状数组/线段树","slug":"树状数组-线段树","permalink":"https://pufanyi.pages.dev/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"CodeForces 391F3 Stock Trading","slug":"CF391F3","date":"2020-02-09T16:00:00.000Z","updated":"2020-02-09T16:00:00.000Z","comments":true,"path":"CF391F3/","link":"","permalink":"https://pufanyi.pages.dev/CF391F3/","excerpt":"给出 n (1≤n≤4000000)n\\,(1\\le n\\le 4000000)n(1≤n≤4000000) 天的股票价格，每天可买进或卖出一股，可以同时买进或卖出，也可以不操作，但最终手上只能有一股。问最多 kkk 次买进和卖出后的最大收益。","text":"给出 n (1≤n≤4000000)n\\,(1\\le n\\le 4000000)n(1≤n≤4000000) 天的股票价格，每天可买进或卖出一股，可以同时买进或卖出，也可以不操作，但最终手上只能有一股。问最多 kkk 次买进和卖出后的最大收益。我们先来看一个 O(nlog⁡n)\\mathcal{O}(n\\log n)O(nlogn) 的做法。首先我们考虑如果是一段连续的递增股票，那我们相当于是一开始买进，最后卖出。如果这样连续的段小于等于 kkk，那么就直接可以返回答案了。如果比 kkk 大，那么我们就需要做出这样两种选择：要么选择一个上升的区间放弃，要么选择一段下降的区间把两段上升的区间给连起来。这个东西我们可以用一个堆或者 set 来维护。但是我们还有一个 O(n)\\mathcal{O}(n)O(n) 的做法，需要观察一些性质。我们把读入的股票看成是一个个单调不减的区间。当然有些区间可能只有一个数。我们考虑一些区间可以合并成一个等价的区间，我们考虑将区间从左往后一个个加入。我们再开一个数组 bbb，记录那些不可能跟后面的区间合并的区间。我们首先可以得到一个结论：在任一时刻对于那些可能与后面合并的区间，其买入时的价格一定是单调递增的。因为如果不是递增的，如下图情况，原来默认的匹配是 [x1,x2][x_1,x_2][x1​,x2​]，[x3,x4][x_3,x_4][x3​,x4​]，现在加入了一个右端点 x5x_5x5​（左端点在哪儿我们并不需要关心），如果 x1x_1x1​ 跟 x5x_5x5​配，那显然不如 x3x_3x3​ 跟 x5x_5x5​ 配，因为这样不仅节省了一段区间（[x1,x2][x_1,x_2][x1​,x2​]），答案还更优。我们还需要发现一个性质，那就是如果现在有两个区间 [l1,r1],[l2,r2][l_1,r_1],[l_2,r_2][l1​,r1​],[l2​,r2​]，如果有 l1&lt;l2l_1&lt;l_2l1​&lt;l2​ 且 r1&lt;r2r_1&lt;r_2r1​&lt;r2​，我们可以把它等价成为 [l1,r2],[l2,r1][l_1,r_2],[l_2,r_1][l1​,r2​],[l2​,r1​] 这样两段区间。而 [l2,r1][l_2,r_1][l2​,r1​] 是不可能再跟后面的匹配了，所以我们可以直接将其扔进 bbb 中。根据这样两个性质，我们可以得到很多个区间。不难发现这些区间是独立的。最后我们取前 kkk 大的区间即可。具体代码可以 戳这里。","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"贪心","slug":"贪心","permalink":"https://pufanyi.pages.dev/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"CodeForces 708E Student's Camp","slug":"CF708E","date":"2020-02-09T16:00:00.000Z","updated":"2020-02-09T16:00:00.000Z","comments":true,"path":"CF708E/","link":"","permalink":"https://pufanyi.pages.dev/CF708E/","excerpt":"有一个 (n+2)×m(n + 2) \\times m(n+2)×m 的长方形，除了第一行和最后一行，其他每一行每一天最左边和最右边的格子都有 ppp 的概率被摧毁，每行之间独立且左边和右边独立，求 kkk 天之后最上面一行与最下面一行四联通的概率。其中 1≤n,m≤1500, 0≤k≤1051\\le n,m\\le 1500,\\,0\\le k\\le 10^51≤n,m≤1500,0≤k≤105，答案对 109+710^9+7109+7 取模。","text":"有一个 (n+2)×m(n + 2) \\times m(n+2)×m 的长方形，除了第一行和最后一行，其他每一行每一天最左边和最右边的格子都有 ppp 的概率被摧毁，每行之间独立且左边和右边独立，求 kkk 天之后最上面一行与最下面一行四联通的概率。其中 1≤n,m≤1500, 0≤k≤1051\\le n,m\\le 1500,\\,0\\le k\\le 10^51≤n,m≤1500,0≤k≤105，答案对 109+710^9+7109+7 取模。一个简单的想法就是我们令 hi,l,rh_{i,l,r}hi,l,r​ 表示 kkk 天后第 iii 行还剩下 [l,r][l,r][l,r]，前 iii 行联通的概率。Pl,rP_{l,r}Pl,r​ 表示单独一行只剩 [l,r][l,r][l,r] 的概率。首先我们有：hi,l,r=Pl,r∑[l,r]∩[l′,r′]≠∅hi−1,l′,r′h_{i,l,r}=P_{l,r}\\sum_{[l,r]\\cap[l&#x27;,r&#x27;]\\neq\\emptyset}h_{i-1,l&#x27;,r&#x27;}hi,l,r​=Pl,r​[l,r]∩[l′,r′]​=∅∑​hi−1,l′,r′​接下来我们考虑 Pl,rP_{l,r}Pl,r​，我们令 qi=(ki)pi(1−p)k−iq_{i}=\\binom{k}{i}p^i(1-p)^{k-i}qi​=(ik​)pi(1−p)k−i，不难发现：Pl,r=ql−1qm−rP_{l,r}=q_{l-1}q_{m-r}Pl,r​=ql−1​qm−r​然后我们令 fi,rf_{i,r}fi,r​ 表示右端点为 rrr 的所有 hhh 之和，同理 gi,lg_{i,l}gi,l​ 表示以左端点为 lll 的所有 hhh 之和，再令 Fi,rF_{i,r}Fi,r​ 表示右端点小于等于 rrr 的所有 hhh 之和，同理 Gi,lG_{i,l}Gi,l​ 表示以左端点大于等于 lll 的所有 hhh 之和。具体地：fi,r=∑l=1rhi,l,rgi,l=∑r=lmhi,l,rFi,r=∑R=1rfi,RGi,l=∑L=lmgi,L\\begin{aligned} f_{i,r}&amp;=\\sum_{l=1}^rh_{i,l,r}\\\\ g_{i,l}&amp;=\\sum_{r=l}^mh_{i,l,r}\\\\ F_{i,r}&amp;=\\sum_{R=1}^rf_{i,R}\\\\ G_{i,l}&amp;=\\sum_{L=l}^mg_{i,L} \\end{aligned}fi,r​gi,l​Fi,r​Gi,l​​=l=1∑r​hi,l,r​=r=l∑m​hi,l,r​=R=1∑r​fi,R​=L=l∑m​gi,L​​于是我们就有：hi,l,r=Pl,r(Fi−1,m−Fi−1,l−1−Gi−1,r+1)h_{i,l,r}=P_{l,r}\\left(F_{i-1,m}-F_{i-1,l-1}-G_{i-1,r+1}\\right)hi,l,r​=Pl,r​(Fi−1,m​−Fi−1,l−1​−Gi−1,r+1​)将 hhh 代入 fff 和 ggg，我们有：fi,r=∑l=1rql−1qm−r(Fi−1,m−Fi−1,l−1−Gi−1,r+1)=qm−r(∑l=1rql−1(Fi−1,m−Fi−1,l−1)−Gi−1,r+1∑l=1rql−1)gi,l=∑r=lmql−1qm−r(Fi−1,m−Fi−1,l−1−Gi−1,r+1)=ql−1(∑r=lmqm−r(Fi−1,m−Gi−1,r+1)−Fi−1,l−1∑r=lmqm−r)\\begin{aligned} f_{i,r}&amp;=\\sum_{l=1}^rq_{l-1}q_{m-r}\\left(F_{i-1,m}-F_{i-1,l-1}-G_{i-1,r+1}\\right)\\\\ &amp;=q_{m-r}\\left(\\sum_{l=1}^rq_{l-1}\\left(F_{i-1,m}-F_{i-1,l-1}\\right)-G_{i-1,r+1}\\sum_{l=1}^rq_{l-1}\\right)\\\\ g_{i,l}&amp;=\\sum_{r=l}^mq_{l-1}q_{m-r}\\left(F_{i-1,m}-F_{i-1,l-1}-G_{i-1,r+1}\\right)\\\\ &amp;=q_{l-1}\\left(\\sum_{r=l}^mq_{m-r}\\left(F_{i-1,m}-G_{i-1,r+1}\\right)-F_{i-1,l-1}\\sum_{r=l}^mq_{m-r}\\right) \\end{aligned}fi,r​gi,l​​=l=1∑r​ql−1​qm−r​(Fi−1,m​−Fi−1,l−1​−Gi−1,r+1​)=qm−r​(l=1∑r​ql−1​(Fi−1,m​−Fi−1,l−1​)−Gi−1,r+1​l=1∑r​ql−1​)=r=l∑m​ql−1​qm−r​(Fi−1,m​−Fi−1,l−1​−Gi−1,r+1​)=ql−1​(r=l∑m​qm−r​(Fi−1,m​−Gi−1,r+1​)−Fi−1,l−1​r=l∑m​qm−r​)​考虑到最后答案是 Fn,mF_{n,m}Fn,m​，我们发现我们可以绕过 hhh 来求 FFF。最终复杂度 O(k+nm)\\mathcal{O}(k+nm)O(k+nm)。代码可以看 这里。","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"DP","slug":"DP","permalink":"https://pufanyi.pages.dev/tags/DP/"}]},{"title":"AGC032E Modulo Pairing","slug":"agc032_e","date":"2020-02-09T16:00:00.000Z","updated":"2020-02-09T16:00:00.000Z","comments":true,"path":"agc032_e/","link":"","permalink":"https://pufanyi.pages.dev/agc032_e/","excerpt":"给一个长度为 2n2n2n 的序列，要求将其两两匹配成 nnn 组，假设第 iii 组为 (xi,yi)(x_i,y_i)(xi​,yi​)，求 max⁡i=1n(xi+yi) mod m\\max_{i=1}^n(x_i+y_i)\\bmod mmaxi=1n​(xi​+yi​)modm 的最小值，1≤n≤105,1≤m≤109,0≤ai&lt;m1\\le n\\le 10^5,1\\le m\\le 10^9,0\\le a_i&lt;m1≤n≤105,1≤m≤109,0≤ai​&lt;m。","text":"给一个长度为 2n2n2n 的序列，要求将其两两匹配成 nnn 组，假设第 iii 组为 (xi,yi)(x_i,y_i)(xi​,yi​)，求 max⁡i=1n(xi+yi) mod m\\max_{i=1}^n(x_i+y_i)\\bmod mmaxi=1n​(xi​+yi​)modm 的最小值，1≤n≤105,1≤m≤109,0≤ai&lt;m1\\le n\\le 10^5,1\\le m\\le 10^9,0\\le a_i&lt;m1≤n≤105,1≤m≤109,0≤ai​&lt;m。我们首先我们有：(x+y) mod m={x+yx+y≤mx+y−mx+y&gt;m(x+y)\\bmod m=\\begin{cases} x+y&amp;x+y\\le m\\\\ x+y-m&amp;x+y&gt;m \\end{cases}(x+y)modm={x+yx+y−m​x+y≤mx+y&gt;m​接下来我们看几种情况：如果我们有 x1≤x2≤x3≤x4x_1\\le x_2\\le x_3\\le x_4x1​≤x2​≤x3​≤x4​，那么我们有这样 444 中情况：第一种，x3+x4&lt;mx_3+x_4&lt;mx3​+x4​&lt;m，那显然 (x1,x4),(x2,x3)(x_1,x_4),(x_2,x_3)(x1​,x4​),(x2​,x3​) 更优。第二种，x1+x2≥mx_1+x_2\\ge mx1​+x2​≥m，和第一种一样。第三种，{x1+x3&lt;mx2+x4≥m\\begin{cases}x_1+x_3&lt;m\\\\x_2+x_4\\ge m\\end{cases}{x1​+x3​&lt;mx2​+x4​≥m​，考虑到 x2+x4−m&lt;x2x_2+x_4-m&lt;x_2x2​+x4​−m&lt;x2​，故有 max⁡{x1+x3,x2+x4−m}=x1+x3\\max\\{x_1+x_3,x_2+x_4-m\\}=x_1+x_3max{x1​+x3​,x2​+x4​−m}=x1​+x3​，而考虑到 {x1+x2≤x1+x3x3+x4−m&lt;x3\\begin{cases}x_1+x_2\\le x_1+x_3\\\\x_3+x_4-m&lt;x_3\\end{cases}{x1​+x2​≤x1​+x3​x3​+x4​−m&lt;x3​​，故有 max⁡{x1+x3,x2+x4−m}≥max⁡{x1+x2,x3+x4−m}\\max\\{x_1+x_3,x_2+x_4-m\\}\\ge \\max\\{x_1+x_2,x_3+x_4-m\\}max{x1​+x3​,x2​+x4​−m}≥max{x1​+x2​,x3​+x4​−m}。所以 (x1,x2),(x3,x4)(x_1,x_2),(x_3,x_4)(x1​,x2​),(x3​,x4​) 一定比 (x1,x3),(x2,x4)(x_1,x_3),(x_2,x_4)(x1​,x3​),(x2​,x4​) 优。我们再来看 (x1,x4),(x2,x3)(x_1,x_4),(x_2,x_3)(x1​,x4​),(x2​,x3​) 的情况。如果有 {x1+x4≥mx2+x3≥m\\begin{cases}x_1+x_4\\ge m\\\\x_2+x_3\\ge m\\end{cases}{x1​+x4​≥mx2​+x3​≥m​，那就有 {x1+x4−m&lt;x1x2+x3−m&lt;x2\\begin{cases}x_1+x_4-m&lt;x1\\\\x_2+x_3-m&lt;x_2\\end{cases}{x1​+x4​−m&lt;x1x2​+x3​−m&lt;x2​​，所以 max⁡{x1+x4−m,x2+x3−m}&lt;x2≤max⁡{x1+x2,x3+x4−m}\\max\\{x_1+x_4-m,x_2+x_3-m\\}&lt;x_2\\le \\max\\{x_1+x_2,x_3+x_4-m\\}max{x1​+x4​−m,x2​+x3​−m}&lt;x2​≤max{x1​+x2​,x3​+x4​−m}，此时 (x1,x4),(x2,x3)(x_1,x_4),(x_2,x_3)(x1​,x4​),(x2​,x3​) 的方案更优。但是如果有 x1+x4≤mx_1+x_4\\le mx1​+x4​≤m 或是 x2+x3≤mx_2+x_3\\le mx2​+x3​≤m，则答案将会更大。第四种，{x1+x4&lt;mx2+x3&lt;mx3+x6≥mx4+x5≥m\\begin{cases}x_1+x_4&lt;m\\\\x_2+x_3&lt;m\\\\x_3+x_6\\ge m\\\\x_4+x_5\\ge m\\end{cases}⎩⎪⎪⎪⎨⎪⎪⎪⎧​x1​+x4​&lt;mx2​+x3​&lt;mx3​+x6​≥mx4​+x5​≥m​。根据前面的讨论，我们仅需比较 (x1,x4),(x2,x3),(x5,x6)(x_1,x_4),(x_2,x_3),(x_5,x_6)(x1​,x4​),(x2​,x3​),(x5​,x6​) 和 (x1,x2),(x3,x4),(x5,x6)(x_1,x_2),(x_3,x_4),(x_5,x_6)(x1​,x2​),(x3​,x4​),(x5​,x6​) 即可，不难发现 {x1+x2≤x1+x4x3+x6−m&lt;x3≤x2+x3x4+x5−m≤x5+x6−m\\begin{cases}x_1+x_2\\le x_1+x_4\\\\x_3+x_6-m&lt;x_3\\le x_2+x_3\\\\x_4+x_5-m\\le x_5+x_6-m\\end{cases}⎩⎪⎨⎪⎧​x1​+x2​≤x1​+x4​x3​+x6​−m&lt;x3​≤x2​+x3​x4​+x5​−m≤x5​+x6​−m​，于是 max⁡{x1+x2,x3+x6−m,x4+x5−m}≤max⁡{x1+x4,x2+x3,x5+x6−m}\\max\\{x_1+x_2,x_3+x_6-m,x_4+x_5-m\\}\\le \\max\\{x_1+x_4,x_2+x_3,x_5+x_6-m\\}max{x1​+x2​,x3​+x6​−m,x4​+x5​−m}≤max{x1​+x4​,x2​+x3​,x5​+x6​−m}。根据第一、二、三种情况，我们发现，最终的划分结果肯定是被分成两部分，左边部分最小的匹配，次大的和次小的匹配……右边也这样匹配。其中左边所有的匹配 (x,y)(x,y)(x,y) 都有 x+y&lt;mx+y&lt;mx+y&lt;m，右边的匹配 (x,y)(x,y)(x,y) 都有 x+y≥mx+y\\ge mx+y≥m。根据第四种情况，我们可以发现蓝色的匹配数越多越好，于是我们考虑二分蓝色的匹配数量，最终确定答案。代码可以看 这里。","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://pufanyi.pages.dev/tags/%E4%BA%8C%E5%88%86/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"}]},{"title":"CodeForces 1288F Red-Blue Graph","slug":"CF1288F","date":"2020-02-06T16:00:00.000Z","updated":"2020-02-06T16:00:00.000Z","comments":true,"path":"CF1288F/","link":"","permalink":"https://pufanyi.pages.dev/CF1288F/","excerpt":"有一张二分图，左边有 n1n_1n1​ 个点，右边有 n2n_2n2​ 个点，mmm 条边。每个点可能有一种颜色 R 或者 B，也可能没有，也就是 U。现在要给一些边染色，把边染成 R 要花费 rrr 的代价，把边染成 B 要花费 bbb 的代价，要求对于每个颜色为 R 的点，与之相邻的边中 R 的边严格多于 B 的边；对于每个颜色为 B 的点，与之相邻的边中 B 的边严格多于 R 的边。求花费最小的方案，输出任意一种，无解输出 −1-1−1。其中 1≤n1,n2,m,r,b≤2001 \\le n_1, n_2, m, r, b \\le 2001≤n1​,n2​,m,r,b≤200。","text":"有一张二分图，左边有 n1n_1n1​ 个点，右边有 n2n_2n2​ 个点，mmm 条边。每个点可能有一种颜色 R 或者 B，也可能没有，也就是 U。现在要给一些边染色，把边染成 R 要花费 rrr 的代价，把边染成 B 要花费 bbb 的代价，要求对于每个颜色为 R 的点，与之相邻的边中 R 的边 严格多于 B 的边；对于每个颜色为 B 的点，与之相邻的边中 B 的边 严格多于 R 的边。求花费最小的方案，输出任意一种，无解输出 −1-1−1。其中 1≤n1,n2,m,r,b≤2001 \\le n_1, n_2, m, r, b \\le 2001≤n1​,n2​,m,r,b≤200。 考虑网络流建图，对于每条边 &lt;u,v&gt;\\left&lt;u,v\\right&gt;⟨u,v⟩，在网络流图上建立两条边：u→vu\\to vu→v，如果流表示将该边染成红色，v→uv\\to uv→u，表示将改变染成黑色。建立超源 sss 和超汇 ttt，考虑左边红色点，sss 向该点连一条下界为 111 的边，表示强制流红大于流黑，对于左边黑色点，该点向 ttt 连一条下界为 111 的边，表示强制流黑大于流红，右边同理。最后跑一遍费用流即可。","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"网络流","slug":"网络流","permalink":"https://pufanyi.pages.dev/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"CERC 2017 Cumulative Code","slug":"CERC2017C","date":"2020-01-30T16:00:00.000Z","updated":"2020-01-30T16:00:00.000Z","comments":true,"path":"CERC2017C/","link":"","permalink":"https://pufanyi.pages.dev/CERC2017C/","excerpt":"给你一棵 k (k≤30)k\\ (k\\le 30)k (k≤30) 阶的满二叉树，从上到下、从左到右从 111 开始编号，设 {pn}\\{p_{n}\\}{pn​} 是它的 Prüfer 序列。给你三个数 a,d,ma,d,ma,d,m，求 ∑i=0m−1pa+id\\sum_{i=0}^{m-1}p_{a+id}∑i=0m−1​pa+id​。","text":"给你一棵 k (k≤30)k\\ (k\\le 30)k (k≤30) 阶的满二叉树，从上到下、从左到右从 111 开始编号，设 {pn}\\{p_{n}\\}{pn​} 是它的 Prüfer 序列。给你三个数 a,d,ma,d,ma,d,m，求 ∑i=0m−1pa+id\\sum_{i=0}^{m-1}p_{a+id}∑i=0m−1​pa+id​。这题主要是要发现一个性质，就是考虑定义 fi,k,h(x)f_{i,k,h}(x)fi,k,h​(x) 表示以 xxx 为根，深度为 kkk 的子树，现在要开始删的是 Prüfer 序列中的第 iii 位，对答案的共献，hhh表示 xxx 是否有父亲，那么 fi,k,h(x)f_{i,k,h}(x)fi,k,h​(x) 可以表示成 ai,k,hx+bi,k,h⌊x2⌋+ci,k,ha_{i,k,h}x+b_{i,k,h}\\lfloor\\frac{x}{2}\\rfloor+c_{i,k,h}ai,k,h​x+bi,k,h​⌊2x​⌋+ci,k,h​ 的形式。令 QQQ 表示询问集合，考虑左儿子对答案的贡献为 fi,k−1,1(2x)f_{i,k-1,1}(2x)fi,k−1,1​(2x)，也就是对父亲的贡献是2ai,k−1,1x+bi,k−1,1⌊2x2⌋+ci,k−1,1=(2ai,k−1,1+bi,k−1,1)x+ci,k−1,12a_{i,k-1,1}x+b_{i,k-1,1}\\lfloor\\frac{2x}{2}\\rfloor+c_{i,k-1,1}=\\left(2a_{i,k-1,1}+b_{i,k-1,1}\\right)x+c_{i,k-1,1}2ai,k−1,1​x+bi,k−1,1​⌊22x​⌋+ci,k−1,1​=(2ai,k−1,1​+bi,k−1,1​)x+ci,k−1,1​，即{2ai,k−1,1+bi,k−1,1,0,ci,k−1,1}\\{2a_{i,k-1,1}+b_{i,k-1,1},0,c_{i,k-1,1}\\}{2ai,k−1,1​+bi,k−1,1​,0,ci,k−1,1​}，右儿子同理可推出，为{2a+b,0,a+c}\\{2a+b,0,a+c\\}{2a+b,0,a+c}。 我们考虑记搜，记搜的答案直接存的是 a,b,ca,b,ca,b,c，这样我们就可以省掉xxx 对答案的影响。我们发现 iii 其实可以表示成到下一个询问的距离，也就是其 lower_bound，这样我们可以省一点空间。但是我们发现还是需要 2n2^n2n 级别，我们考虑小范围暴搜，其余记搜，即 k&gt;15k&gt;15k&gt;15 是不计入状态，然后如果递归到一棵子树发现它没有询问节点，那么直接 return 掉，这样就使得 iii 小于等于子树 size 了。其实 h=0h=0h=0 我们也不用计入状态，因为不难发现 h=0h=0h=0 只会搜索 O(k)\\mathcal{O}(k)O(k) 次，完全可以接受。最后稍稍判一下边界即可。这样深度小于等于 k2\\frac{k}{2}2k​ 的节点只有 O(2k2)\\mathcal{O}(2^\\frac{k}{2})O(22k​) 个，深度大于 k2\\frac{k}{2}2k​ 的只有 O(k2k2)\\mathcal{O}(k2^\\frac{k}{2})O(k22k​) 个，所以单次询问时空复杂度均为O(k2k2)\\mathcal{O}(k2^\\frac{k}{2})O(k22k​)。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxl = 16;const int lim = 15;struct Solution &#123; LL a, b, c; Solution (LL a = 0, LL b = 0, LL c = 0) &#123; this-&gt;a = a, this-&gt;b = b, this-&gt;c = c; &#125; inline LL calc(int x) &#123; return a * x + b * (x &gt;&gt; 1) + c; &#125;&#125; F[maxl][1 &lt;&lt; maxl];int vis[maxl][1 &lt;&lt; maxl];inline void addls(Solution&amp; a, const Solution b) &#123; a.a += 2 * b.a + b.b; a.c += b.c;&#125;inline void addrs(Solution&amp; a, const Solution b) &#123; a.a += 2 * b.a + b.b; a.c += b.a + b.c;&#125;int kase;#define jian(x, y) &#123; \\ x -= y; \\&#125;inline Solution f(int k, int first, int m, int d, bool h) &#123; if (k == 1) &#123; return Solution(0, 1, 0); &#125; int siz = (1 &lt;&lt; k) - 1; if (siz &lt; first || !m) &#123; return Solution(0, 0, 0); &#125; bool flg = k &lt;= lim &amp;&amp; h &amp;&amp; first + m * d &gt;= siz; if (flg) &#123; if (vis[k][first] == kase) &#123; return F[k][first]; &#125; &#125; int fstbak = first; Solution ans; int sizs = (1 &lt;&lt; (k - 1)) - 1; Solution xx; if (first &lt; sizs &amp;&amp; m &gt; 0) &#123; int nowm = min(m, (sizs - first - 1) / d + 1); addls(ans, xx = f(k - 1, first, nowm, d, true)); first += nowm * d; m -= nowm; &#125; jian(first, sizs); if (!h) &#123; if (m &gt; 0 &amp;&amp; !first) &#123; ans.a += 2, ans.c++; first += d, m--; &#125; jian(first, 1); &#125; if (first &lt; sizs &amp;&amp; m &gt; 0) &#123; int nowm = min(m, (sizs - first - 1) / d + 1); addrs(ans, xx = f(k - 1, first, nowm, d, h)); first += nowm * d; m -= nowm; &#125; jian(first, sizs); if (h &amp;&amp; m &gt; 0) &#123; ans.b++; &#125; if (flg) &#123; vis[k][fstbak] = kase; F[k][fstbak] = ans; &#125; return ans;&#125;int main() &#123; int k, q; cin &gt;&gt; k &gt;&gt; q; while (q--) &#123; int a, d, m; cin &gt;&gt; a &gt;&gt; d &gt;&gt; m; a--, kase++; Solution ans = f(k, a, m, d, false); cout &lt;&lt; ans.a + ans.c &lt;&lt; '\\n'; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://pufanyi.pages.dev/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"}]},{"title":"CodeForces 1264D Beautiful Bracket Sequence","slug":"CF1264D","date":"2020-01-30T16:00:00.000Z","updated":"2020-01-30T16:00:00.000Z","comments":true,"path":"CF1264D/","link":"","permalink":"https://pufanyi.pages.dev/CF1264D/","excerpt":"给定一个长度为nnn的字符串，其中只有 '(', ')', '?' 三种字符，其中 '?' 可以为 '(' 或者 ')'。对于一个括号序列，定义其权值为其通过删除字符后可以得到的合法的括号匹配的最深的深度，求出所有可能的括号序列（即问号替换后）的权值和。在 D1 中，n≤2000n\\le 2000n≤2000；在 D2 中，n≤106n\\le 10^6n≤106。","text":"给定一个长度为 nnn 的字符串，其中只有 '(', ')', '?' 三种字符，其中 '?' 可以为 '(' 或者 ')'。对于一个括号序列，定义其权值为其通过删除字符后可以得到的合法的括号匹配的最深的深度，求出所有可能的括号序列（即问号替换后）的权值和。在 D1 中，n≤2000n\\le 2000n≤2000；在 D2 中，n≤106n\\le 10^6n≤106。考虑枚举答案计算方案数，显然对于一个括号序列，存在一个划分点使得划分点左边的左括号个数等于划分点右边的有括号个数。则此时该括号序列的深度就是划分点左边的左括号个数。这样 dp 之后合并一下是 O(n2)\\mathcal{O}(n^2)O(n2) 的。这样 D1 就做完了。考虑把前面 dp 的式子转换成组合数，我们考虑每个分割点，前面有 lll 个左括号，rrr个右括号，前面有 xxx 个问号，后面有 yyy 个问号。其实答案就是：∑i=0x(l+i)(xi)(yl+i−r)=l∑i=0x(xi)(yl+i−r)+∑i=0xi(xi)(yl+i−r)\\sum_{i=0}^x(l+i)\\binom{x}{i}\\binom{y}{l+i-r}=l\\sum_{i=0}^x\\binom{x}{i}\\binom{y}{l+i-r}+\\sum_{i=0}^xi\\binom{x}{i}\\binom{y}{l+i-r}i=0∑x​(l+i)(ix​)(l+i−ry​)=li=0∑x​(ix​)(l+i−ry​)+i=0∑x​i(ix​)(l+i−ry​)对于左边的式子：l∑i=0x(xi)(yl+i−r)= l∑i=0x(xi)(yy+r−l−i)= l(x+yy+r−l)\\begin{aligned} &amp;l\\sum_{i=0}^x\\binom{x}{i}\\binom{y}{l+i-r}\\\\ =\\ &amp;l\\sum_{i=0}^x\\binom{x}{i}\\binom{y}{y+r-l-i}\\\\ =\\ &amp;l\\binom{x+y}{y+r-l} \\end{aligned}= = ​li=0∑x​(ix​)(l+i−ry​)li=0∑x​(ix​)(y+r−l−iy​)l(y+r−lx+y​)​对于右边的式子：∑i=0xi(xi)(yl+i−r)= ∑i=0xx(x−1i−1)(yy−l−i+r)= x(x+y−1y−l+r−1)\\begin{aligned} &amp;\\sum_{i=0}^xi\\binom{x}{i}\\binom{y}{l+i-r}\\\\ =\\ &amp;\\sum_{i=0}^xx\\binom{x-1}{i-1}\\binom{y}{y-l-i+r}\\\\ =\\ &amp;x\\binom{x+y-1}{y-l+r-1} \\end{aligned}= = ​i=0∑x​i(ix​)(l+i−ry​)i=0∑x​x(i−1x−1​)(y−l−i+ry​)x(y−l+r−1x+y−1​)​所以该点的贡献为：l(x+yy+r−l)+x(x+y−1y−l+r−1)l\\binom{x+y}{y+r-l}+x\\binom{x+y-1}{y-l+r-1}l(y+r−lx+y​)+x(y−l+r−1x+y−1​)代码就直接丢链接了：D1、D2。","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E5%AD%A6/"},{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"DP","slug":"DP","permalink":"https://pufanyi.pages.dev/tags/DP/"}]},{"title":"换了个主题","slug":"换个主题","date":"2020-01-28T16:00:00.000Z","updated":"2020-01-28T16:00:00.000Z","comments":true,"path":"换个主题/","link":"","permalink":"https://pufanyi.pages.dev/%E6%8D%A2%E4%B8%AA%E4%B8%BB%E9%A2%98/","excerpt":"之前的主题太丑了……","text":"之前的主题太丑了……换上了 Material X，很多修改直接偷了 myh 的代码 。 之前搭得太臃肿了，现在删库之后全部重新搭了一遍……好感人啊，搭完发现速度快了好多……","categories":[],"tags":[]},{"title":"生成树入门","slug":"生成树入门","date":"2020-01-28T16:00:00.000Z","updated":"2020-01-28T16:00:00.000Z","comments":true,"path":"生成树入门/","link":"","permalink":"https://pufanyi.pages.dev/%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8/","excerpt":"万年不更了，随便写点什么吧。","text":"万年不更了，随便写点什么吧。首先最小生成树的两种求法 Kruskal 和 Prim，强行丢 链接 。 其他还有一个 Borůvka 算法，大概思路就是每次将每个集合伸出去的最短的那条边选入，选入后将两个集合合并成一个新的集合，考虑到每次集合个数减半，所以复杂度 O(mlog⁡n)\\mathcal{O}(m\\log n)O(mlogn)。偷了张 Wikipedia 的图：那这东西有什么用呢？有 这么一道题 ，大概是有一个 n (n≤200000)n\\,(n\\le 200000)n(n≤200000) 个点的完全图，每个节点的编号为 ai (0≤ai&lt;230)a_i\\,(0\\le a_i&lt;2^{30})ai​(0≤ai​&lt;230)，iii 与 jjj 的边的权值是 ai⨂aja_i\\bigotimes a_jai​⨂aj​，⨂\\bigotimes⨂ 是按位异或，求该图的最小生成树。 这道题大概用到了 Borůvka 的思想，先用所有点权建一棵 Trie 树，考虑 Trie 树上一棵子树，显然一开始肯定是他们自己连成一棵 MST，然后再和其兄弟连一条边，因为跨越子树像兄弟连一条边需要 2d2^d2d 的代价，ddd 是节点深度，显然自己连更优，于是建出 Trie 树之后分治（其实就是 dfs）下去即可。具体代码可以 戳这里 。 有一道叫 最小 mex 生成树 的题目，题目大意是给定 nnn 个点 mmm 条边的无向连通图，求一棵生成树，使得其边权集合的 mex\\mathrm{mex}mex 尽可能小。1≤n≤106, 1≤m≤105, 0≤w≤1051\\le n\\le 10^6,\\,1\\le m\\le 10^5,\\,0\\le w\\le 10^51≤n≤106,1≤m≤105,0≤w≤105。考虑一个做法：枚举答案 xxx，把边权为 xxx 的所有边全部删掉，看看能不能构成一棵生成树。建一棵以边权为下标的线段树，对于每条边权为 www 的边将其放到 [0,w−1][0,w-1][0,w−1] 和 [w+1,105][w+1,10^5][w+1,105] 上。然后在线段树上遍历，遍历到一个节点就将它上面挂着的边连上，这样子到叶结点时就连上了所有不包含该边权的边，用可撤销并查集判断图是否连通即可。用可撤销按秩合并并查集，复杂度 O(nlog⁡2n)\\mathcal{O}(n\\log^2n)O(nlog2n)。并不是很懂为什么两只 log⁡\\loglog 能过 10610^6106。最小比率生成树，也就是给你一张图，每条边有一个非负权值 ai,bia_i,b_iai​,bi​，求一棵生成树 TTT，使得 ∑e∈Tae∑e∈Tbe\\frac{\\sum_{e\\in T}a_e}{\\sum_{e\\in T}b_e}∑e∈T​be​∑e∈T​ae​​ 最小。大概就是一个 01 分数规划问题，我们可以考虑二分答案 lll，条件是 ∑e∈Tae∑e∈Tbe≤l\\frac{\\sum_{e\\in T}a_e}{\\sum_{e\\in T}b_e}\\le l∑e∈T​be​∑e∈T​ae​​≤l，也就是 ∑e∈Tae−l⋅be≤0\\sum_{e\\in T}a_e-l\\cdot b_e\\le 0∑e∈T​ae​−l⋅be​≤0。考虑到 ai≥0,bi≥0a_i\\ge 0,b_i\\ge 0ai​≥0,bi​≥0，所以左边的东西肯定随 lll 递减。以 ai−l⋅bia_i-l\\cdot b_iai​−l⋅bi​ 为边权建树二分即可。模板题大概是 这道 ，代码可以 戳这里 。 接下来是那到经典的 wqs 二分好题 ，题目大意就是给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有 xxx 条白色边的生成树。V≤50000, E≤100000V\\le 50000,\\,E\\le 100000V≤50000,E≤100000，边权为[1,100][1,100][1,100] 中的整数。首先我们先要知道 wqs 二分是什么，那就先说一道题吧，大概就是有一个长度为 n (n≤105)n\\,(n\\le 10^5)n(n≤105) 的正整数序列 {a}\\{a\\}{a}，要分成 KKK 段，第 iii 段之和记为 sis_isi​，求最小的 ∑i=1Ksi2\\sum_{i=1}^Ks_i^2∑i=1K​si2​。我们令 fkf_kfk​ 表示分成 kkk 段的最小值，有一个显然的结论就是 fkf_kfk​ 是递减的，因为 (a+b)2&gt;a2+b2\\left(a+b\\right)^2&gt; a^2+b^2(a+b)2&gt;a2+b2，把一段给拆开来肯定更优。我们来考虑 fff 的差分数列，我们发现 fff 的差分数列是单调不增的。感觉我的证明比较口胡，大家意会一下就可以了。如果大家对证明没什么兴趣，也可以不跳过这一段，反正只要意会一下这是单调的就可以了。我们考虑从分成 kkk 段到分成 k−1k-1k−1 段的情况，也就是说，要把段数减 111。此时，有两种办法，一种是合并其中的两段，另一种是拆掉原有的一些段。首先看合并两段。考虑到如果合并这两段所假的量比 fk+1−fkf_{k+1}-f_kfk+1​−fk​ 要小，那么 k+1→kk+1\\to kk+1→k 的时候就应该合并这两段。当然可能这两段可能是 k+1→kk+1\\to kk+1→k 的时候出现的，这时候我们考虑到 a⋅(b+c)≥aba\\cdot(b+c)\\ge aba⋅(b+c)≥ab 即可。还有一种方法就是拆掉一些段然后合并。不难发现这其实只有和二分图增广一样的情况，就是 0101010 变成 1010101。如果 k+1→kk+1\\to kk+1→k 所生成的段和这些段无关，那显然这样操作的代价比 k+1→kk+1\\to kk+1→k 的代价劣，如果有关，我们考虑这一段，如果 k→k−1k\\to k-1k→k−1 的代价比 k+1→kk+1\\to kk+1→k 优，考虑 k→k−1k\\to k-1k→k−1 这一次“增广”时该块所断开的那个位置，我们考虑 k+1→kk+1\\to kk+1→k 时不将那一段合并，而是将我们刚才找到的那个位置向左侧或右侧跟 k→k−1k\\to k-1k→k−1 这样的样子的方向进行“增广”，不难证明这样做的代价优于 fk+1−fkf_{k+1}-f_kfk+1​−fk​，而由于我们之前认为 fk+1−fkf_{k+1}-f_kfk+1​−fk​ 是最优的，矛盾了，所以不合。综上，我们可以发现 fff 的差分数列是单调不增的，也就是说，是一个凸壳。那我们既然我们得到了一个凸壳，但是我们并不知道凸壳上具体点的纵坐标，我们考虑一个做法：考虑用一条直线 y=kx+by=kx+by=kx+b 去切这个凸壳，我们二分 kkk，如果能快速求出 bbb 和具体切到了凸壳上的那一个点，那么就能得出答案。对于这道题，我们发现二分的 kkk 其实就是给每段增加了一个代价，也就是说，每段的代价不再是 si2s_i^2si2​，而是 si2−ks_i^2-ksi2​−k（显然，这里需要二分的 kkk 是负数）。这样做有一个好处，就是我们不必考虑需要选 KKK 段的限制，而是只要求出最优解分成了几段（也就是切到了那个点），以及最优解的答案（也就是 bbb）即可。这个东西我们可以考虑一个朴素的 dp，令 gig_igi​ 表示以 iii 结尾的答案，显然我们有：gi=min⁡j=1i−1(gj+(∑t=jiat)2)−kg_i=\\min_{j=1}^{i-1}\\left(g_j+\\left(\\sum_{t=j}^ia_t\\right)^2\\right)-kgi​=j=1mini−1​⎝⎛​gj​+(t=j∑i​at​)2⎠⎞​−k我们令 Si=∑j=1iajS_i=\\sum_{j=1}^ia_jSi​=∑j=1i​aj​，不难得到：gi=min⁡j=1i−1(gj+sj2−2sisj)−k−si2g_i=\\min_{j=1}^{i-1}\\left(g_j+s_j^2-2s_is_j\\right)-k-s_i^2gi​=j=1mini−1​(gj​+sj2​−2si​sj​)−k−si2​不难发现这个东西可以斜率优化，于是我们就可以顺利地解决这道题。我们回过头来看之前那道题：给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有 xxx 条白色边的生成树。这道题的答案似乎并不是随 xxx 单调的，应该是一个单峰的函数，但是我们考虑其差分数列，发现其也是单调的。因为想象如果你必须扔掉一条边而去选择另一种颜色一条边，那一定是有很多中选择（如弃 aaa 选 bbb，弃 ccc 选 ddd），而这些决策是独立的，我们可以选择任意一个，而显然是会去选择最小的一个。于是这仍然是一个凸壳。我们仍然能用刚才的思路，用一条直线去卡，二分斜率，发现斜率就是给每条白色边加一个权值，然后就可以直接做了。如果先将黑白边分别排序，最后每次二分是归并一下，那么排序的复杂度变成了 O(E)\\mathcal{O}(E)O(E)，于是复杂度 O(Elog⁡C α(V))\\mathcal{O}(E\\log C\\,\\alpha(V))O(ElogCα(V))，CCC 是二分范围。接着应该是 严格次小生成树 ，题目就是让你求一棵严格次小生成树吧。其实也很简单，首先发现任意一棵最小生成树都可以通过加一条边再删一条边变成一棵严格次小生成树，于是就可以建出一棵最小生成树，用倍增、树剖或是 LCT 维护链最大值，每次枚举一条非树边尝试删除一条树边，复杂度 O(nlog⁡2n)/O(nlog⁡n)\\mathcal{O}(n\\log^2n)/\\mathcal{O}(n\\log n)O(nlog2n)/O(nlogn)。代码看 这里 。 最小权值生成树？就是要求 ∑wisi\\sum w_is_i∑wi​si​ 最小。wiw_iwi​ 是 iii 以 111 为根时与父亲边权的大小，w1=0w_1=0w1​=0，sis_isi​ 是以 111 为根时 iii 的子树大小。1≤n,m≤105, wi≥01\\le n,m\\le 10^5,\\,w_i\\ge 01≤n,m≤105,wi​≥0。发现 ∑wisi=∑di\\sum w_is_i=\\sum d_i∑wi​si​=∑di​，did_idi​ 表示 iii 到 111 的距离，于是最短路径树即是答案。最小极差生成树？首先有一个 O(m2)\\mathcal{O}(m^2)O(m2) 的做法，就是枚举最小边，然后就是最小瓶颈生成树了，直接 Kruskal。然后我们发现我们可以倒着枚举边，每次加入一个最小的，形成一个环，显然是删去环中最大的，这个我们可以直接用 LCT 维护，维护边权的时候将边变成一个虚点即可。时间复杂度 O(mlog⁡(n+m))\\mathcal{O}(m\\log (n+m))O(mlog(n+m))。模板题可以看 这道 ，代码可以看 这里 。有一个大坑就是这道题有自环。 还有最小乘积生成树。就是每条边有两个权值 ai,bia_i,b_iai​,bi​，求一棵生成树 TTT，最小化 ∑e∈Tae×∑e∈Tbe\\sum_{e\\in T}a_e\\times\\sum_{e\\in T}b_e∑e∈T​ae​×∑e∈T​be​。数据范围 1≤n≤200, 1≤m≤10000, 0≤ai≤bi≤2551\\le n\\le 200,\\,1\\le m\\le 10000,\\,0\\le a_i\\le b_i\\le 2551≤n≤200,1≤m≤10000,0≤ai​≤bi​≤255。考虑将每棵最小生成树 TTT 都映射到一个点 (∑e∈Tae,∑e∈Tbe)\\left(\\sum_{e\\in T} a_e,\\sum_{e\\in T} b_e\\right)(∑e∈T​ae​,∑e∈T​be​)。也就是求其与 (0,0)(0,0)(0,0) 所围成的面积最小。然后就不难发现答案一定在凸壳上，我们考虑找到这个凸壳。有一种叫做 Quick-Hull 的找凸包的方法，就是选取两个凸包上的点，连成一条线，找到距离这条线最远的点（一侧），然后分治下去（继续偷一张 Wikipedia 上的图）：这种方法可以用在这道题目上，我们考虑先找到两个点，最好找的就是左上角和右下角了，一个是以 aaa 建一棵最小生成树，另一个以 bbb 建最小生成树。然后我们考虑找最远的点，那显然就是面积最大的点，也就是说，如果我们找到左上角的点 A(xa,ya)A(x_a,y_a)A(xa​,ya​)，右下角 B(xb,yb)B(x_b,y_b)B(xb​,yb​)，我们要找一个点 C(xc,yc)C(x_c,y_c)C(xc​,yc​)，我们要最大化 AC→×AB→\\overrightarrow{AC}\\times \\overrightarrow{AB}AC×AB。我们考虑到：AC→×AB→=(xc−xa,yc−ya)×(xb−xa,yb−ya)=(xc−xa)⋅(yb−ya)−(xb−xa)⋅(yc−ya)=xcyb−xcya−xayb+xaya−xbyc+xayc+xbya−xaya=xc(yb−ya)+yc(xa−xb)+xbya−xayb\\begin{aligned} \\overrightarrow{AC}\\times \\overrightarrow{AB}&amp;=\\left(x_c-x_a,y_c-y_a\\right)\\times\\left(x_b-x_a,y_b-y_a\\right)\\\\ &amp;=(x_c-x_a)\\cdot(y_b-y_a)-(x_b-x_a)\\cdot(y_c-y_a)\\\\ &amp;=x_cy_b-x_cy_a-x_ay_b+x_ay_a-x_by_c+x_ay_c+x_by_a-x_ay_a\\\\ &amp;=x_c(y_b-y_a)+y_c(x_a-x_b)+x_by_a-x_ay_b \\end{aligned}AC×AB​=(xc​−xa​,yc​−ya​)×(xb​−xa​,yb​−ya​)=(xc​−xa​)⋅(yb​−ya​)−(xb​−xa​)⋅(yc​−ya​)=xc​yb​−xc​ya​−xa​yb​+xa​ya​−xb​yc​+xa​yc​+xb​ya​−xa​ya​=xc​(yb​−ya​)+yc​(xa​−xb​)+xb​ya​−xa​yb​​考虑到 xbya−xaybx_by_a-x_ay_bxb​ya​−xa​yb​ 是一个定值，我们只要最大化 xc(yb−ya)+yc(xa−xb)x_c(y_b-y_a)+y_c(x_a-x_b)xc​(yb​−ya​)+yc​(xa​−xb​)，即最小化 xc(ya−yb)+yc(xb−xa)x_c(y_a-y_b)+y_c(x_b-x_a)xc​(ya​−yb​)+yc​(xb​−xa​) 即可。于是我们只要将边权定为 ac(ya−yb)+bc(xb−xa)a_c(y_a-y_b)+b_c(x_b-x_a)ac​(ya​−yb​)+bc​(xb​−xa​)，然后就一遍最小生成树即可。复杂度？大概口胡一下：决策点应该是有 O(nn−2)\\mathcal{O}\\left(n^{n-2}\\right)O(nn−2) 个。关于其会使凸包上的点期望有多少个，自己 实测 了一下感觉像是 O(log⁡n)\\mathcal{O}(\\log n)O(logn) 的，后来在 知乎 上看到了一篇奇怪的证明，说确实是 O(log⁡n)\\mathcal{O}(\\log n)O(logn)，但是听说这个证明有点锅，然后有找到了一篇 论文 ，并不是很懂里面的内容，有兴趣的可以看一下。于是凸包上的期望点数应该是 O(log⁡(nn−2))=O(nlog⁡n)\\mathcal{O}\\left(\\log \\left(n^{n-2}\\right)\\right)=\\mathcal{O}(n\\log n)O(log(nn−2))=O(nlogn) 的。每次找一个点的复杂度是 O(mlog⁡m)\\mathcal{O}(m\\log m)O(mlogm) 的，所以期望复杂度应该是 O(nmlog⁡nlog⁡m)\\mathcal{O}(nm\\log n\\log m)O(nmlognlogm)。 模板题在 这里 ，代码在 这里 。 关于这个问题的复杂度在知乎上翻到了一个奇怪的讨论，大家可以 去看看 。 然后是 Matrix-Tree 定理。关于这部分内容的很多东西均偷自 这篇论文 。 在此之前先需要介绍一下行列式是什么，首先我们来先介绍一下置换。关于置换，记为 (12⋯na1a2⋯an)\\begin{pmatrix} 1 &amp; 2 &amp; \\cdots &amp; n\\\\ a_1 &amp; a_2 &amp; \\cdots &amp; a_n \\end{pmatrix}(1a1​​2a2​​⋯⋯​nan​​) 其中 aaa 是 1∼n​1\\sim n​1∼n​ 的一个排列。显然对于任意一个排列，要将其排序的话，其交换次数的奇偶性与交换方式无关，我们令最小交换次数为 ttt，我们定义：δ(12⋯na1a2⋯an)=(−1)t\\delta\\begin{pmatrix} 1 &amp; 2 &amp; \\cdots &amp; n\\\\ a_1 &amp; a_2 &amp; \\cdots &amp; a_n \\end{pmatrix}=(-1)^tδ(1a1​​2a2​​⋯⋯​nan​​)=(−1)t然后是行列式，其实说白了他是一个函数，将一个 n×nn\\times nn×n 的矩阵映射到了一个标量，我们记为 det⁡A\\det AdetA 或 ∣A∣\\left|A\\right|∣A∣。我们定义：det⁡A=∑(12⋯ni1i2⋯in)δ(12⋯ni1i2⋯in)∏j=1naj,ij\\det A=\\sum_{\\begin{pmatrix} 1 &amp; 2 &amp; \\cdots &amp; n\\\\ i_1 &amp; i_2 &amp; \\cdots &amp; i_n \\end{pmatrix}}\\delta\\begin{pmatrix} 1 &amp; 2 &amp; \\cdots &amp; n\\\\ i_1 &amp; i_2 &amp; \\cdots &amp; i_n \\end{pmatrix}\\prod_{j=1}^na_{j,i_j}detA=(1i1​​2i2​​⋯⋯​nin​​)∑​δ(1i1​​2i2​​⋯⋯​nin​​)j=1∏n​aj,ij​​观察上式，我们可以得到一些性质，考虑到这些性质都可以直接由定义得到，证明就不再一一展开。首先，我们有：det⁡AT=det⁡A\\det A^{\\mathrm{T}}=\\det AdetAT=detAATA^{\\mathrm{T}}AT 是 AAA 的转置，大概就是这样子吧：这暗示着我们，行列式中行和列是等价的，下面在讨论行的问题时，列都是一样的。然后是如果将行列式中的两行互换，那么行列式变号。于是我们有一个推论，那就是如果矩阵 AAA 中两行相同，那么交换这两行不会改变 AAA，于是我们有 det⁡A=−det⁡A\\det A=-\\det AdetA=−detA，即 det⁡A=0\\det A=0detA=0。在行列式中，某一行的每个元素是两数之和，则此行列式可拆分为两个相加的行列式。∣a11a12…a1n⋮⋮…⋮ai1+bi1ai2+bi2…ain+bin⋮⋮⋱⋮an1an2…ann∣=∣a11a12…a1n⋮⋮…⋮ai1ai2…ain⋮⋮⋱⋮an1an2…ann∣+∣a11a12…a1n⋮⋮…⋮bi1bi2…bin⋮⋮⋱⋮an1an2…ann∣{\\begin{vmatrix}a_{11}&amp;a_{12}&amp;\\dots &amp;a_{1n}\\\\\\vdots &amp;\\vdots &amp;\\dots &amp;\\vdots \\\\{\\color {blue}a_{i1}}+{\\color {green}b_{i1}}&amp;{\\color {blue}a_{i2}}+{\\color {green}b_{i2}}&amp;\\dots &amp;{\\color {blue}a_{in}}+{\\color {green}b_{in}}\\\\\\vdots &amp;\\vdots &amp;\\ddots &amp;\\vdots \\\\a_{n1}&amp;a_{n2}&amp;\\dots &amp;a_{nn}\\end{vmatrix}}={\\begin{vmatrix}a_{11}&amp;a_{12}&amp;\\dots &amp;a_{1n}\\\\\\vdots &amp;\\vdots &amp;\\dots &amp;\\vdots \\\\{\\color {blue}a_{i1}}&amp;{\\color {blue}a_{i2}}&amp;\\dots &amp;{\\color {blue}a_{in}}\\\\\\vdots &amp;\\vdots &amp;\\ddots &amp;\\vdots \\\\a_{n1}&amp;a_{n2}&amp;\\dots &amp;a_{nn}\\end{vmatrix}}+{\\begin{vmatrix}a_{11}&amp;a_{12}&amp;\\dots &amp;a_{1n}\\\\\\vdots &amp;\\vdots &amp;\\dots &amp;\\vdots \\\\{\\color {green}b_{i1}}&amp;{\\color {green}b_{i2}}&amp;\\dots &amp;{\\color {green}b_{in}}\\\\\\vdots &amp;\\vdots &amp;\\ddots &amp;\\vdots \\\\a_{n1}&amp;a_{n2}&amp;\\dots &amp;a_{nn}\\end{vmatrix}}∣∣∣∣∣∣∣∣∣∣∣∣​a11​⋮ai1​+bi1​⋮an1​​a12​⋮ai2​+bi2​⋮an2​​………⋱…​a1n​⋮ain​+bin​⋮ann​​∣∣∣∣∣∣∣∣∣∣∣∣​=∣∣∣∣∣∣∣∣∣∣∣∣​a11​⋮ai1​⋮an1​​a12​⋮ai2​⋮an2​​………⋱…​a1n​⋮ain​⋮ann​​∣∣∣∣∣∣∣∣∣∣∣∣​+∣∣∣∣∣∣∣∣∣∣∣∣​a11​⋮bi1​⋮an1​​a12​⋮bi2​⋮an2​​………⋱…​a1n​⋮bin​⋮ann​​∣∣∣∣∣∣∣∣∣∣∣∣​根据上面一条，我们可以得到，如果将矩阵的一行或是一列都乘以一个数 λ\\lambdaλ，那么该矩阵的行列式也将乘以 λ\\lambdaλ。结合上面那个性质的推论，我们不难发现如果矩阵中有两行或两列成比例，那么该矩阵的行列式为 000。∣a11a12…a1n⋮⋮…⋮kai1kai2…kain⋮⋮⋱⋮an1an2…ann∣=k∣a11a12…a1n⋮⋮…⋮ai1ai2…ain⋮⋮⋱⋮an1an2…ann∣{\\begin{vmatrix}a_{11}&amp;a_{12}&amp;\\dots &amp;a_{1n}\\\\\\vdots &amp;\\vdots &amp;\\dots &amp;\\vdots \\\\{\\color {blue}k}a_{i1}&amp;{\\color {blue}k}a_{i2}&amp;\\dots &amp;{\\color {blue}k}a_{in}\\\\\\vdots &amp;\\vdots &amp;\\ddots &amp;\\vdots \\\\a_{n1}&amp;a_{n2}&amp;\\dots &amp;a_{nn}\\end{vmatrix}}={\\color {blue}k}{\\begin{vmatrix}a_{11}&amp;a_{12}&amp;\\dots &amp;a_{1n}\\\\\\vdots &amp;\\vdots &amp;\\dots &amp;\\vdots \\\\a_{i1}&amp;a_{i2}&amp;\\dots &amp;a_{in}\\\\\\vdots &amp;\\vdots &amp;\\ddots &amp;\\vdots \\\\a_{n1}&amp;a_{n2}&amp;\\dots &amp;a_{nn}\\end{vmatrix}}∣∣∣∣∣∣∣∣∣∣∣∣​a11​⋮kai1​⋮an1​​a12​⋮kai2​⋮an2​​………⋱…​a1n​⋮kain​⋮ann​​∣∣∣∣∣∣∣∣∣∣∣∣​=k∣∣∣∣∣∣∣∣∣∣∣∣​a11​⋮ai1​⋮an1​​a12​⋮ai2​⋮an2​​………⋱…​a1n​⋮ain​⋮ann​​∣∣∣∣∣∣∣∣∣∣∣∣​根据上面的东西，我们就可以发现：∣⋮⋮⋮⋮ai1ai2…ainaj1aj2…ajn⋮⋮⋮⋮∣=∣⋮⋮⋮⋮ai1ai2…ainaj1aj2…ajn⋮⋮⋮⋮∣+∣⋮⋮⋮⋮ai1ai2…ainkai1kai2…kain⋮⋮⋮⋮∣=∣⋮⋮⋮⋮ai1ai2…ainaj1+kai1aj2+kai2…ajn+kain⋮⋮⋮⋮∣\\begin{aligned} {\\begin{vmatrix}\\vdots &amp;\\vdots &amp;\\vdots &amp;\\vdots \\\\a_{i1}&amp;a_{i2}&amp;\\dots &amp;a_{in}\\\\a_{j1}&amp;a_{j2}&amp;\\dots &amp;a_{jn}\\\\\\vdots &amp;\\vdots &amp;\\vdots &amp;\\vdots \\\\\\end{vmatrix}}&amp;={\\begin{vmatrix}\\vdots &amp;\\vdots &amp;\\vdots &amp;\\vdots \\\\a_{i1}&amp;a_{i2}&amp;\\dots &amp;a_{in}\\\\a_{j1}&amp;a_{j2}&amp;\\dots &amp;a_{jn}\\\\\\vdots &amp;\\vdots &amp;\\vdots &amp;\\vdots \\\\\\end{vmatrix}}+{\\begin{vmatrix}\\vdots &amp;\\vdots &amp;\\vdots &amp;\\vdots \\\\a_{i1}&amp;a_{i2}&amp;\\dots &amp;a_{in}\\\\{\\color {blue}ka_{i1}}&amp;{\\color {blue}ka_{i2}}&amp;\\dots &amp;{\\color {blue}ka_{in}}\\\\\\vdots &amp;\\vdots &amp;\\vdots &amp;\\vdots \\\\\\end{vmatrix}}\\\\&amp;={\\begin{vmatrix}\\vdots &amp;\\vdots &amp;\\vdots &amp;\\vdots \\\\a_{i1}&amp;a_{i2}&amp;\\dots &amp;a_{in}\\\\a_{j1}{\\color {blue}+ka_{i1}}&amp;a_{j2}{\\color {blue}+ka_{i2}}&amp;\\dots &amp;a_{jn}{\\color {blue}+ka_{in}}\\\\\\vdots &amp;\\vdots &amp;\\vdots &amp;\\vdots \\\\\\end{vmatrix}} \\end{aligned}∣∣∣∣∣∣∣∣∣∣​⋮ai1​aj1​⋮​⋮ai2​aj2​⋮​⋮……⋮​⋮ain​ajn​⋮​∣∣∣∣∣∣∣∣∣∣​​=∣∣∣∣∣∣∣∣∣∣​⋮ai1​aj1​⋮​⋮ai2​aj2​⋮​⋮……⋮​⋮ain​ajn​⋮​∣∣∣∣∣∣∣∣∣∣​+∣∣∣∣∣∣∣∣∣∣​⋮ai1​kai1​⋮​⋮ai2​kai2​⋮​⋮……⋮​⋮ain​kain​⋮​∣∣∣∣∣∣∣∣∣∣​=∣∣∣∣∣∣∣∣∣∣​⋮ai1​aj1​+kai1​⋮​⋮ai2​aj2​+kai2​⋮​⋮……⋮​⋮ain​ajn​+kain​⋮​∣∣∣∣∣∣∣∣∣∣​​也就是说，我们可以把行列式中的某行的每个环诉乘上一个常数 kkk，加到另一行上去。根据这一个性质，我们不难使用类似高斯消元的做法吧行列式转换成上三角的形式：∣a1,1a1,2a1,3…a1,na2,2a2,3…a2,n⋮⋱⋱⋮(0)⋱an−1,n0⋯an,n∣=∏i=1nai,i{\\begin{vmatrix}a_{1,1}&amp;a_{1,2}&amp;a_{1,3}&amp;\\ldots &amp;a_{1,n}\\\\&amp;a_{2,2}&amp;a_{2,3}&amp;\\ldots &amp;a_{2,n}\\\\\\vdots &amp;&amp;\\ddots &amp;\\ddots &amp;\\vdots \\\\&amp;(0)&amp;&amp;\\ddots &amp;a_{n-1,n}\\\\0&amp;&amp;\\cdots &amp;&amp;a_{n,n}\\end{vmatrix}}=\\prod_{i=1}^na_{i,i}∣∣∣∣∣∣∣∣∣∣∣​a1,1​⋮0​a1,2​a2,2​(0)​a1,3​a2,3​⋱⋯​……⋱⋱​a1,n​a2,n​⋮an−1,n​an,n​​∣∣∣∣∣∣∣∣∣∣∣​=i=1∏n​ai,i​于是我们就可以 O(n3)\\mathcal{O}(n^3)O(n3) 计算行列式啦！这里有一道 模板题 ，其中有模数 ppp，不保证是质数。 由于不是质数，所以可能不存在逆元。我们考虑在消元的时候，使用类似辗转相除的方法。这样时间复杂度 O(n3log⁡n)\\mathcal{O}(n^3\\log n)O(n3logn)。代码在 这儿 。 当然，我们还有能发现，如果矩阵 AAA 中每一行和为 000，那么我们可以把矩阵中的第一列加上其余各列，这样子第一列就全 000 了，于是 det⁡A=0\\det A=0detA=0。接下来是一个非常牛逼的东西叫做柯西 - 比内公式，大概就是假设 AAA 是一个 m×nm\\times nm×n 的矩阵，BBB 是一个 n×nn\\times nn×n 的矩阵，如果 SSS 是 1,…,n{1, \\dots, n}1,…,n 中具有 mmm 个元素的子集，我们记 ASA_SAS​ 为 AAA 中列下标位于 SSS 中的 m×mm\\times mm×m 子矩阵。类似地，记 BSB_SBS​ 为 BBB 中行下标位于 SSS 中的 m×mm\\times mm×m 子矩阵。Binet-Cauchy 公式说：det⁡(AB)=∑det⁡AS⋅det⁡BS\\det(AB)=\\sum\\det A_{S}\\cdot \\det B_{S}det(AB)=∑detAS​⋅detBS​这个东西我太菜了不会证啊，如果有兴趣的同学可以自己看 论文 或是 水知乎 。 根据上面的公式，当 n=mn=mn=m 时，det⁡(AB)=det⁡Adet⁡B\\det(AB)=\\det A\\det Bdet(AB)=detAdetB然后我们会到生成树上来，问题大概就是让你求一张无向图的生成树个数，n≤100n\\le 100n≤100。先说结论，假设给出图为 GGG，定义一个 n×nn\\times nn×n 的矩阵 D(G)D(G)D(G) 表示 GGG 个点的度数，当 i≠ji\\neq ji​=j时，di,j=0d_{i,j}=0di,j​=0，当 i=ji=ji=j 时，di,jd_{i,j}di,j​ 等于节点 iii 的度数。再定义一个 n×nn\\times nn×n 的矩阵 AGA_GAG​ 表示 GGG 的邻接矩阵，Ai,jA_{i,j}Ai,j​ 表示 iii 到 jjj 的边数。然后我们定义基尔霍夫矩阵 C(G)=D(G)−A(G)C(G)=D(G)-A(G)C(G)=D(G)−A(G)。则 GGG 中生成树个数等于 C(G)C(G)C(G) 中任意一个 n−1n-1n−1 阶主子式的行列式的绝对值。所谓一个矩阵 MMM 的 n−1n-1n−1 阶主子式就是对于两个整数 r (1≤r≤n)r\\,(1\\le r\\le n)r(1≤r≤n)，将 MMM 去掉第 rrr 行和第 rrr 列后形成的 n−1n-1n−1 阶的矩阵，记作 MrM_{r}Mr​。举个栗子，比如说现在有这样张图，其生成树有 888 个（直接偷 Wikipedia 上的图了）：其度数矩阵 D(G)=[2000030000300002]D(G)=\\begin{bmatrix}2&amp;0&amp;0&amp;0\\\\0&amp;3&amp;0&amp;0\\\\0&amp;0&amp;3&amp;0\\\\0&amp;0&amp;0&amp;2\\end{bmatrix}D(G)=⎣⎢⎢⎡​2000​0300​0030​0002​⎦⎥⎥⎤​ 其邻接矩阵 A(G)=[0110101111010110]A(G)=\\begin{bmatrix}0&amp;1&amp;1&amp;0\\\\1&amp;0&amp;1&amp;1\\\\1&amp;1&amp;0&amp;1\\\\0&amp;1&amp;1&amp;0\\end{bmatrix}A(G)=⎣⎢⎢⎡​0110​1011​1101​0110​⎦⎥⎥⎤​ 于是其基尔霍夫矩阵 C(G)=[2−1−10−13−1−1−1−13−10−1−12]C(G)=\\begin{bmatrix}2&amp;-1&amp;-1&amp;0\\\\-1&amp;3&amp;-1&amp;-1\\\\-1&amp;-1&amp;3&amp;-1\\\\0&amp;-1&amp;-1&amp;2\\end{bmatrix}C(G)=⎣⎢⎢⎡​2−1−10​−13−1−1​−1−13−1​0−1−12​⎦⎥⎥⎤​ 我们取 r=2r=2r=2，得到其主子式 C2(G)=[2−10−13−10−12]C_2(G)=\\begin{bmatrix}2&amp;-1&amp;0\\\\-1&amp;3&amp;-1\\\\0&amp;-1&amp;2\\end{bmatrix}C2​(G)=⎣⎡​2−10​−13−1​0−12​⎦⎤​ 得到的行列式 det⁡C2(G)=∣2−10−13−10−12∣=∣2−10052−10085∣=2×52×85=8\\det C_2(G)=\\begin{vmatrix}2&amp;-1&amp;0\\\\-1&amp;3&amp;-1\\\\0&amp;-1&amp;2\\end{vmatrix}=\\begin{vmatrix}2&amp;-1&amp;0\\\\0&amp;\\frac{5}{2}&amp;-1\\\\0&amp;0&amp;\\frac{8}{5}\\end{vmatrix}=2\\times\\frac{5}{2}\\times \\frac{8}{5}=8detC2​(G)=∣∣∣∣∣∣​2−10​−13−1​0−12​∣∣∣∣∣∣​=∣∣∣∣∣∣​200​−125​0​0−158​​∣∣∣∣∣∣​=2×25​×58​=8 那为什么是这样呢？首先我们来观察一下 C(G)C(G)C(G) 的性质。我们考虑如果我们把两个点在矩阵中的出现顺序交换，其实就是把行交换一次，列交换一次，一共交换偶数次，所以行列式不变。于是我们发现，C(G)C(G)C(G) 和 Cr(G)C_r(G)Cr​(G) 的行列式与其顶点的顺序无关。我们考虑构造一个 n×mn\\times mn×m（nnn 是点数，mmm 是边数）的矩阵 BBB，如果对于第 iii 条边，如果连接 &lt;u,v&gt;\\left&lt;u,v\\right&gt;⟨u,v⟩，那么我们就令 bu,i=1,bv,i=−1b_{u,i}=1,b_{v,i}=-1bu,i​=1,bv,i​=−1，其余都是 000。其实谁是 111 谁是 −1-1−1 不重要，因为是无向图，只要一个是 −1-1−1 一个是 111 即可。接下来，我们考虑 BBTBB^{\\mathrm T}BBT。我们发现对于 (BBT)i,j(BB^{\\mathrm T})_{i,j}(BBT)i,j​，如果 i=ji=ji=j，那么 (BBT)i,j=∑k=1mBi,k2(BB^{\\mathrm T})_{i,j}=\\sum_{k=1}^mB_{i,k}^2(BBT)i,j​=∑k=1m​Bi,k2​，也就是 iii 的度数；如果 i≠ji\\neq ji​=j，那么 (BBT)i,j=∑k=1mBi,kBj,k(BB^{\\mathrm T})_{i,j}=\\sum_{k=1}^mB_{i,k}B_{j,k}(BBT)i,j​=∑k=1m​Bi,k​Bj,k​，也就是 iii 到 jjj 的边数的相反数。于是我们发现，BBTBB^{\\mathrm T}BBT 就是基尔霍夫矩阵，即 C(G)=BBTC(G)=BB^\\mathrm{T}C(G)=BBT。令 HHH 表示 BBB 去掉 rrr 行后的矩阵，易得 C(G)r=HHTC(G)_r=HH^\\mathrm{T}C(G)r​=HHT。于是根据 Binet-Cauchy 公 式，我们可以得到：det⁡C(G)=det⁡(HHT)=∑Sdet⁡HSdet⁡HST=∑S(det⁡HS)2=∑Sdet⁡HS2\\det C(G)=\\det (HH^\\mathrm{T})=\\sum_{S}\\det H_S\\det H_S^\\mathrm{T}=\\sum_{S}\\left(\\det H_S\\right)^2=\\sum_{S}\\det H_S^2detC(G)=det(HHT)=S∑​detHS​detHST​=S∑​(detHS​)2=S∑​detHS2​我们观察这只式子，发现他其实就是在干这样一件事情：每次在这 mmm 条边中取出 n−1n-1n−1 条，并对答案计入 det⁡HS2\\det H_S^2detHS2​ 的贡献。那我们来看这个 det⁡HS2\\det H_S^2detHS2​。我们将 SSS 中选出的这些边组合成一个集合，和 nnn 个点组合成一张图，记为 G′G&#x27;G′，不难发现 C(G′)=HS2C(G&#x27;)=H_S^2C(G′)=HS2​，于是 det⁡HS2=det⁡C(G′)\\det H_S^2=\\det C(G&#x27;)detHS2​=detC(G′)。然后我们考虑一个基尔霍夫矩阵 C(G)C(G)C(G)，由于其各行各列之和均为 000，det⁡C(G)=0\\det C(G)=0detC(G)=0。如果 GGG 是一个非连通图，那么我们发现 C(G)C(G)C(G) 一定可以通过调整点的编号变成这样：[a1,1…a1,k0…0⋮⋱⋮⋮⋱⋮ak,1…ak,k0…00…0ak+1,k+1…ak+1,n⋮⋱⋮⋮⋱⋮0…0an,k+1…an,n]\\begin{bmatrix} a_{1,1}&amp;\\ldots&amp;a_{1,k}&amp;0&amp;\\ldots&amp;0\\\\ \\vdots&amp;\\ddots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\ a_{k,1}&amp;\\ldots&amp;a_{k,k}&amp;0&amp;\\ldots&amp;0\\\\ 0&amp;\\ldots&amp;0&amp;a_{k+1,k+1}&amp;\\ldots&amp;a_{k+1,n}\\\\ \\vdots&amp;\\ddots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\ 0&amp;\\ldots&amp;0&amp;a_{n,k+1}&amp;\\ldots&amp;a_{n,n}\\\\ \\end{bmatrix}⎣⎢⎢⎢⎢⎢⎢⎢⎢⎡​a1,1​⋮ak,1​0⋮0​…⋱……⋱…​a1,k​⋮ak,k​0⋮0​0⋮0ak+1,k+1​⋮an,k+1​​…⋱……⋱…​0⋮0ak+1,n​⋮an,n​​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎤​不难发现这两个连通块都可以独立地变成一个上三角。由于 Cr(G)C_r(G)Cr​(G) 只抽走了一行和一列，那也就是说肯定有一个块最后对角线上有一个 000，于是行列式的值为 000。所以说，如果 G′G&#x27;G′ 不是连通图，那其对答案的贡献是 000，考虑到 G′G&#x27;G′ 只有 n−1n-1n−1 条边，如果联通，那肯定只能是棵树了。于是我们来考虑数的情况。不要忘了我们扔出去了一个 rrr，我们以 rrr 为根对这棵树进行 dfs，将节点重新按照 dfs 序标号。然后我们从大往小倒着来。考虑对每个点，用他去消他的父亲。也就是说，将它父亲的每那一行减去自己的那一行。不难发现，如果这样做，主对角线都是 111，因为只有它与它父亲的那条边没被减，其他边都被儿子减掉了。这样就形成了一个下三角矩阵，我们把它转置一下就变成了上三角，其贡献就是对角线的乘积，也就是 111。于是他对答案的贡献就是 111。我们再来回顾一下这只式子：det⁡C(G)=∑Sdet⁡HS2\\det C(G)=\\sum_{S}\\det H_S^2detC(G)=S∑​detHS2​经过上面的论证，如果 G′G&#x27;G′ 是棵树，那么 det⁡HS2=1\\det H_S^2=1detHS2​=1，否则 det⁡HS2=0\\det H_S^2=0detHS2​=0。也就是说，这个式子在枚举所有 n−1n-1n−1 条边的子集，如果这个子集是一棵生成树，那么就将答案加 111，于是我们成功在 O(n3)\\mathcal{O}(n^3)O(n3) 的时间复杂度内完成了生成树计数问题。那就让我们来做一下这道 模板题 ，代码在 这里 。 然后是最小生成树计数。这个大概就是发现每个最小生成树每种边权的边数应该是一样的，且将这些边去掉后所得的连通块相同。于是我们考虑建出一棵最小生成树，枚举边权然后把原来最小生成树上该边权的边删掉，然后跑矩阵树。复杂度？假设离散之后边权 iii 共有 aia_iai​ 条边，那么显然 ∑ai=m\\sum a_i=m∑ai​=m。如果图没有重边，则 Kruscal 复杂度 O(mlog⁡m)\\mathcal{O}(m\\log m)O(mlogm)，矩阵树复杂度为 O(∑(n+m+min⁡(n,ai)3))\\mathcal{O}\\left(\\sum \\left(n+m+\\min(n, a_i)^3\\right)\\right)O(∑(n+m+min(n,ai​)3))，由于没有重边，前面的 n+mn+mn+m 那一项卡满不过 O(m×(n+m))=O(m2)=O(n2m)\\mathcal{O}(m\\times (n+m))=\\mathcal{O}(m^2)=\\mathcal{O}(n^2m)O(m×(n+m))=O(m2)=O(n2m)，而后面那一项当每个 aia_iai​ 取到 nnn 时最大，即 O(mn×n3)=O(n2m)\\mathcal{O}\\left(\\frac{m}{n}\\times n^3\\right)=\\mathcal{O}(n^2m)O(nm​×n3)=O(n2m)，所以总复杂度 O(n2m)\\mathcal{O}(n^2m)O(n2m)。模板题在 这儿 ，代码在 这儿 。 那如何计算树形图呢？我们先考虑树是叶子向根的情况。我们考虑刚才的证明，不难构造出树形图的解。大概就是将原来的度数矩阵改成出度矩阵，然后定义基尔霍夫矩阵。这样一棵树已经可以直接变成一个上三角了。我们考虑枚举 rrr，对每个 rrr 都做一遍矩阵树，最后求和即可。那从根向叶子呢？把边反一反就可以了。具体直接把出度矩阵改成入度矩阵即可。矩阵树就暂时到这儿吧。未完待续……列几篇写这篇博客时看到的有趣的文章，上面的很多内容很多 参考 抄自这些文章，当然有些文章看不懂，也列在了这里：罗雨屏的课件 CMXRYNP 的博客：01 分数规划学习笔记wqs 的论文：《浅析一类二分方法》clj 的论文：《Tree 解题报告》YoungNeal 的博客：[总结] wqs 二分学习笔记Creeper_LKF 的博客：关于 WQS 二分算法以及其一个细节证明Wikipedia 词条：Quickhull 一篇关于凸包期望个数的论文 知乎上关于最小乘积生成树的讨论 《生成树的计数及其应用》 周冬MoebiusMeow 的博客：康复计划 #5 Matrix-Tree 定理(生成树计数) 的另类证明和简单拓展 Wikipedia 词条：行列式Stilwell 的课件：线性代数 关于 Cauchy-Binet 公式的一个证明「from CommonAnts」Matrix-Tree 定理相关","categories":[{"name":"小小结","slug":"小小结","permalink":"https://pufanyi.pages.dev/categories/%E5%B0%8F%E5%B0%8F%E7%BB%93/"}],"tags":[{"name":"生成树","slug":"生成树","permalink":"https://pufanyi.pages.dev/tags/%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"线段树入门","slug":"线段树入门","date":"2020-01-26T16:00:00.000Z","updated":"2020-01-26T16:00:00.000Z","comments":true,"path":"线段树入门/","link":"","permalink":"https://pufanyi.pages.dev/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/","excerpt":"万年不更了，决定扔点什么东西上来凑数吧。","text":"万年不更了，决定扔点什么东西上来凑数吧。","categories":[{"name":"小小结","slug":"小小结","permalink":"https://pufanyi.pages.dev/categories/%E5%B0%8F%E5%B0%8F%E7%BB%93/"}],"tags":[{"name":"树状数组/线段树","slug":"树状数组-线段树","permalink":"https://pufanyi.pages.dev/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"CSP2019 后做的一些题","slug":"CSP2019后做的一些题","date":"2019-11-30T16:00:00.000Z","updated":"2019-11-30T16:00:00.000Z","comments":true,"path":"CSP2019后做的一些题/","link":"","permalink":"https://pufanyi.pages.dev/CSP2019%E5%90%8E%E5%81%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E9%A2%98/","excerpt":"感觉已经濒临AFO了。","text":"感觉已经濒临 AFO 了。 题解中的翻译大部分来自网上，如果有侵权行为请联系我。","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"USACO","slug":"USACO","permalink":"https://pufanyi.pages.dev/tags/USACO/"}]},{"title":"这个毒瘤的 live2d","slug":"毒瘤","date":"2019-10-09T16:00:00.000Z","updated":"2019-10-09T16:00:00.000Z","comments":true,"path":"毒瘤/","link":"","permalink":"https://pufanyi.pages.dev/%E6%AF%92%E7%98%A4/","excerpt":"来一波搞事。","text":"来一波搞事。 大概是这里：https://github.com/pufanyi/live","categories":[{"name":"毒瘤","slug":"毒瘤","permalink":"https://pufanyi.pages.dev/categories/%E6%AF%92%E7%98%A4/"}],"tags":[]},{"title":"CodeForces 1221F Choose a Square","slug":"CF1221F","date":"2019-10-03T16:00:00.000Z","updated":"2019-10-03T16:00:00.000Z","comments":true,"path":"CF1221F/","link":"","permalink":"https://pufanyi.pages.dev/CF1221F/","excerpt":"题意大概就是有nnn个点，每个点其坐标xi,yix_i,y_ixi​,yi​与权值cic_ici​，其中1≤n≤5⋅105,0≤xi,yi≤109,−106≤ci≤1061\\le n\\le 5\\cdot 10^5,0\\le x_i,y_i\\le 10^9,-10^6\\le c_i\\le 10^61≤n≤5⋅105,0≤xi​,yi​≤109,−106≤ci​≤106。让你选一个正方形，该正方形的左下角及右上角必须在y=xy=xy=x这条直线上。所获得的权值为在正方形内的点的权值和减去正方形的边权。输出所获的最大权值及其选择正方形的左下角x1,y1x_1,y_1x1​,y1​及右上角x2,y2x_2,y_2x2​,y2​，要求0≤x1=y1≤x2=y2≤2⋅1090\\le x_1=y_1\\le x_2=y_2\\le 2\\cdot 10^90≤x1​=y1​≤x2​=y2​≤2⋅109。","text":"题意大概就是有 nnn 个点，每个点其坐标 xi,yix_i,y_ixi​,yi​ 与权值 cic_ici​，其中1≤n≤5⋅105,0≤xi,yi≤109,−106≤ci≤1061\\le n\\le 5\\cdot 10^5,0\\le x_i,y_i\\le 10^9,-10^6\\le c_i\\le 10^61≤n≤5⋅105,0≤xi​,yi​≤109,−106≤ci​≤106。 让你选一个正方形，该正方形的左下角及右上角必须在 y=xy=xy=x 这条直线上。所获得的权值为在正方形内的点的权值和减去正方形的边权。输出所获的最大权值及其选择正方形的左下角 x1,y1x_1,y_1x1​,y1​ 及右上角 x2,y2x_2,y_2x2​,y2​，要求0≤x1=y1≤x2=y2≤2⋅1090\\le x_1=y_1\\le x_2=y_2\\le 2\\cdot 10^90≤x1​=y1​≤x2​=y2​≤2⋅109。 其实就是让你选两个数 l,rl,rl,r，左下角为(l,l)(l,l)(l,l)，右上角为(r,r)(r,r)(r,r)。 我们考虑一个点是否在正方形内。我们发现对于第 iii 个点，若 l≤min⁡{xi,yi}≤max⁡{xi,yi}≤rl\\le \\min\\{x_i,y_i\\}\\le \\max\\{x_i,y_i\\}\\le rl≤min{xi​,yi​}≤max{xi​,yi​}≤r，那么(xi,yi)(x_i,y_i)(xi​,yi​) 就在正方形内。所以我们发现答案就是：∑max⁡{xi,yi}≤rci−∑min⁡{xi,yi}&lt;l≤max⁡{xi,yi}≤rci−(r−l+1)\\sum_{\\max\\{x_i,y_i\\}\\le r} c_i-\\sum_{\\min\\{x_i,y_i\\}&lt; l\\le \\max\\{x_i,y_i\\}\\le r}c_i-(r-l+1)max{xi​,yi​}≤r∑​ci​−min{xi​,yi​}&lt;l≤max{xi​,yi​}≤r∑​ci​−(r−l+1)我们考虑枚举右端点 rrr，也就是枚举∑max⁡{xi,yi}≤rci−r\\sum_{\\max\\{x_i,y_i\\}\\le r} c_i-r∑max{xi​,yi​}≤r​ci​−r，同时用线段树维护−∑min⁡{xi,yi}&lt;l≤max⁡{xi,yi}≤rci+l−1-\\sum_{\\min\\{x_i,y_i\\}&lt; l\\le \\max\\{x_i,y_i\\}\\le r}c_i+l-1−∑min{xi​,yi​}&lt;l≤max{xi​,yi​}≤r​ci​+l−1 的最小值即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256#define _CRT_SECURE_NO_WARNINGS#include &lt;map&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cassert&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;inline char gc() &#123; static const LL L = 233333; static char sxd[L], *sss = sxd, *ttt = sxd; if (sss == ttt) &#123; ttt = (sss = sxd) + fread(sxd, 1, L, stdin); if (sss == ttt) &#123; return EOF; &#125; &#125; return *sss++;&#125;#ifndef dd#define dd c = gc()#endifinline char readalpha() &#123; char dd; for (; !isalpha(c); dd); return c;&#125;inline char readchar() &#123; char dd; for (; c == ''; dd); return c;&#125;template &lt;class T&gt;inline bool read(T&amp; x) &#123; bool flg = false; char dd; x = 0; for (; !isdigit(c); dd) &#123; if (c == '-') &#123; flg = true; &#125; else if(c == EOF) &#123; return false; &#125; &#125; for (; isdigit(c); dd) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); &#125; if (flg) &#123; x = -x; &#125; return true;&#125;#undef ddtemplate &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; if (x &lt; 10) &#123; putchar(x | 48); return; &#125; write(x / 10); putchar((x % 10) | 48);&#125;typedef long long LL;const LL maxn = 1000005;LL n;LL _cnt = 0;set&lt;LL&gt; mj;#define ls(x) (x &lt;&lt; 1)#define rs(x) (x &lt;&lt; 1 | 1)struct Tree &#123; struct Node &#123; pair&lt;LL, LL&gt; xx; LL lzy; &#125; no[maxn &lt;&lt; 2]; inline void push_up(LL x) &#123; no[x].xx = max(no[ls(x)].xx, no[rs(x)].xx); &#125; inline void build_tree(LL l, LL r, LL k) &#123; static auto x = mj.begin(); if (l == r) &#123; auto tmp = x; ++tmp; if (tmp != mj.end()) &#123; no[k].xx = make_pair(*tmp, *x); &#125; else &#123; no[k].xx = make_pair(-233333, *x); &#125; x++; return; &#125; LL mid = (l + r) &gt;&gt; 1; build_tree(l, mid, ls(k)); build_tree(mid + 1, r, rs(k)); push_up(k); &#125; inline void push_down(LL k) &#123; if (no[k].lzy) &#123; no[ls(k)].xx.first -= no[k].lzy; no[rs(k)].xx.first -= no[k].lzy; no[ls(k)].lzy += no[k].lzy; no[rs(k)].lzy += no[k].lzy; no[k].lzy = 0; &#125; &#125; inline void add(LL l, LL r, LL k, LL L, LL R, LL x) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; no[k].lzy += x; no[k].xx.first -= x; return; &#125; LL mid = (l + r) &gt;&gt; 1; push_down(k); if (L &lt;= mid) &#123; add(l, mid, ls(k), L, R, x); &#125; if (R &gt; mid) &#123; add(mid + 1, r, rs(k), L, R, x); &#125; push_up(k); &#125; inline pair&lt;LL, LL&gt; query(LL l, LL r, LL k, LL L, LL R) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return no[k].xx; &#125; LL mid = (l + r) &gt;&gt; 1; push_down(k); if (R &lt;= mid) &#123; return query(l, mid, ls(k), L, R); &#125; else if (L &gt; mid) &#123; return query(mid + 1, r, rs(k), L, R); &#125; else &#123; return max(query(l, mid, ls(k), L, R), query(mid + 1, r, rs(k), L, R)); &#125; &#125;&#125; tr;struct QJ &#123; LL mn, mx, mnid, mxid, qz; friend bool operator &lt; (QJ a, QJ b) &#123; return a.mx &lt; b.mx; &#125;&#125; qj[maxn];struct LS &#123; LL x, id; friend bool operator &lt; (LS a, LS b) &#123; return a.x &lt; b.x; &#125;&#125; ls[maxn &lt;&lt; 1];map&lt;int, int&gt; anss;int main() &#123; read(n); for (LL i = 1; i &lt;= n; ++i) &#123; LL x, y; read(x), read(y), read(qj[i].qz); if (x == y) &#123; anss[x] += qj[i].qz; &#125; qj[i].mn = min(x, y); qj[i].mx = max(x, y); ls[++_cnt].x = qj[i].mn; ls[_cnt].id = i &lt;&lt; 1; ls[++_cnt].x = qj[i].mx; ls[_cnt].id = i &lt;&lt; 1 | 1; mj.insert(x); mj.insert(y); &#125; sort(ls + 1, ls + _cnt + 1); LL cnt = 0; for (LL i = 1; i &lt;= _cnt; ++i) &#123; if (i == 1 || ls[i].x != ls[i - 1].x) &#123; cnt++; &#125; if (ls[i].id &amp; 1) &#123; qj[ls[i].id &gt;&gt; 1].mxid = cnt; &#125; else &#123; qj[ls[i].id &gt;&gt; 1].mnid = cnt; &#125; &#125; sort(qj + 1, qj + n + 1); LL ansx = 1300000000, ansy = 1300000000, ans = 0; for (auto x : anss) &#123; if (x.second &gt; ans) &#123; ans = x.second; ansx = ansy = x.first; &#125; &#125; tr.build_tree(1, cnt, 1); LL now = 1; LL __cnt = 0; LL sum = 0; int bg = *mj.begin(); for (auto x : mj) &#123; __cnt++; while (now &lt;= n &amp;&amp; qj[now].mx &lt;= x) &#123; tr.add(1, cnt, 1, qj[now].mnid, cnt, qj[now].qz); sum += qj[now].qz; now++; &#125; if (__cnt &gt; 1) &#123; pair&lt;LL, LL&gt; an = tr.query(1, cnt, 1, 1, __cnt - 1); LL Ans = sum + an.first - x; if (Ans &gt; ans) &#123; auto tx = mj.lower_bound(an.second); ansx = *(++tx); ansy = x; ans = Ans; &#125; &#125; int len = x - bg; if (sum - len &gt; ans) &#123; ansx = bg, ansy = x, ans = sum - len; &#125; &#125; printf(\"%lld\\n\", ans); printf(\"%lld %lld %lld %lld\\n\", ansx, ansx, ansy, ansy); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"数据结构","slug":"数据结构","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"造一棵树","slug":"造一棵树","date":"2019-09-20T16:00:00.000Z","updated":"2019-09-20T16:00:00.000Z","comments":true,"path":"造一棵树/","link":"","permalink":"https://pufanyi.pages.dev/%E9%80%A0%E4%B8%80%E6%A3%B5%E6%A0%91/","excerpt":"帮人造了几组数据。其实就是造了一棵树。记录一下以备后用。","text":"帮人造了几组数据。 其实就是造了一棵树。 记录一下以备后用。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;cassert&gt;#include &lt;cstdlib&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define hb bhusing namespace std;const int maxn = 1000000;int n, m, seed;int bh[maxn];vector&lt;pair&lt;int, int&gt; &gt; ve;vector&lt;int&gt; rt;vector&lt;int&gt; ln;int main(int argc, char** argv) &#123; assert(argc == 4); ofstream fout(argv[1]); sscanf(argv[2], \"%d\", &amp;n); sscanf(argv[3], \"%d\", &amp;seed); srand((unsigned) seed); fout &lt;&lt; n &lt;&lt; '\\n'; mt19937 rnd((unsigned) seed); int lim = n / 3; for (int i = 1; i &lt;= n; ++i) &#123; bh[i] = i; &#125; int Lrt = max(1, max(lim - (lim / 10), lim - 10)); random_shuffle(bh + 1, bh + n + 1); rt.push_back(bh[1]); for (int i = 2; i &lt;= lim; ++i) &#123; ve.push_back(make_pair(bh[i], rt[rnd() % rt.size()])); if (i - Lrt &gt; 1) &#123; rt.push_back(hb[i - Lrt]); &#125; &#125; for (int i = lim + 1; i &lt;= n; ++i) &#123; if (ln.empty() || !(rnd() % max(3, lim &gt;&gt; 3))) &#123; ve.push_back(make_pair(hb[i], rt[rnd() % rt.size()])); &#125; else &#123; ve.push_back(make_pair(hb[i], ln[max(0, (int) (ln.size() - (rnd() % 100) - 1))])); &#125; ln.push_back(hb[i]); &#125; random_shuffle(ve.begin(), ve.end()); for (auto x : ve) &#123; if (rnd() &amp; 1) &#123; fout &lt;&lt; x.first &lt;&lt; '' &lt;&lt; x.second &lt;&lt; '\\n'; &#125; else &#123; fout &lt;&lt; x.second &lt;&lt; ' ' &lt;&lt; x.first &lt;&lt; '\\n'; &#125; &#125; fout.close(); return 0;&#125;","categories":[{"name":"随笔","slug":"随笔","permalink":"https://pufanyi.pages.dev/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"出题","slug":"出题","permalink":"https://pufanyi.pages.dev/tags/%E5%87%BA%E9%A2%98/"}]},{"title":"UVa11600 Masud Rana","slug":"UVa11600","date":"2019-09-07T16:00:00.000Z","updated":"2019-09-07T16:00:00.000Z","comments":true,"path":"UVa11600/","link":"","permalink":"https://pufanyi.pages.dev/UVa11600/","excerpt":"题目大意就是有n (n≤30)n\\,(n\\le 30)n(n≤30)个点的无向完全图，有m (m≤n×(n−1)2)m\\,\\left(m\\le \\frac{n\\times (n-1)}{2}\\right)m(m≤2n×(n−1)​)条道路上没有怪兽，其他道路都有怪兽。一个人一开始在111号点，每次会随机选择一条路走并把这条路上的怪兽全部杀完。问期望走多少步才能让这nnn个点之间都存在没有怪兽的路径。按照国际惯例，多组数据，T≤100T\\le 100T≤100。","text":"题目大意就是有 n (n≤30)n\\,(n\\le 30)n(n≤30) 个点的无向完全图，有 m (m≤n×(n−1)2)m\\,\\left(m\\le \\frac{n\\times (n-1)}{2}\\right)m(m≤2n×(n−1)​) 条道路上没有怪兽，其他道路都有怪兽。一个人一开始在 111 号点，每次会随机选择一条路走并把这条路上的怪兽全部杀完。问期望走多少步才能让这 nnn 个点之间都存在没有怪兽的路径。按照国际惯例，多组数据，T≤100T\\le 100T≤100。一看网上的题解，为什么都是 O(2n)\\mathcal{O}(2^n)O(2n) 的啊，为什么暴力都能过啊。当然先声明一下，下面说的复杂度多不太准确，比如说 O(2n)\\mathcal{O}(2^n)O(2n)，实际上可能说的是O(2n×n)\\mathcal{O}(2^n\\times n)O(2n×n) 或是 O(2n×n2)\\mathcal{O}(2^n\\times n^2)O(2n×n2)，但考虑到这道题对于这种算法的复杂度数据范围放的很宽，且nnn 很小，这里就忽略不计了，反正这是实现的问题。然后开始自闭。结果发现 udebug 上那份 std 好像是可以过 30 0 这组数据的。于是就大概搞了个复杂度似乎有点真的算法。先说一下那个 O(2n)\\mathcal{O}(2^n)O(2n) 的做法吧，我们先考虑把联通的点缩起来，我们姑且称之为团，这样问题就转化成了期望需要走多少次才能遍历所有的团。然后考虑令 fi,jf_{i,j}fi,j​ 表示现在在第 iii 个团，选取团的状态为 jjj，直接dp 即可，如果直接计搜然后用 hash 或是 map 存状态，这道题就直接过掉了。然后我们发现其实我们只关心每个团的大小而不关心每个团的具体标号，于是我们可以用 fi,jf_{i,j}fi,j​ 表示当前在第 iii 个点，还有 jjj（jjj 是一个 multiset，当然也可以把这个multiset 哈希掉）这些团的期望，然后转移。转移的话大概就是枚举下一步到那个团，直接计搜下去即可，具体可以看代码。复杂度？我们发现状态大概是把 nnn 划分成多个数字之和的方案数，也就是 划分数 ，n=30n=30n=30 时才 500050005000。 大概跑的是比较快的，极限数据（100100100个 30 0）大概只需要跑0.30.30.3 秒（本机）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;// read/write 的代码略去const int maxn = 305;int n, m;struct ZT &#123; static const int mod = 19260817; multiset&lt;int&gt; st; int hsh, xx; inline void init() &#123; hsh = xx; for (auto x : st) &#123; hsh = ((LL) hsh * hsh % mod * hsh % mod + x) % mod; &#125; &#125; ZT () &#123; hsh = 0, xx = 0; st.clear(); &#125;&#125;;int siz[maxn];int fa[maxn];inline int getfa(int x) &#123; return fa[x] == x ? x : fa[x] = getfa(fa[x]);&#125;inline void merge(int x, int y) &#123; int fax = getfa(x); int fay = getfa(y); if (fax != fay) &#123; if (fax &gt; fay) &#123; swap(fax, fay); &#125; siz[fax] += siz[fay]; fa[fay] = fax; &#125;&#125;map&lt;int, double&gt; mp;inline double dfs(const ZT&amp; now) &#123; if (now.st.empty()) &#123; return 0; &#125; if (mp.count(now.hsh)) &#123; return mp[now.hsh]; &#125; double ans = 0; for (auto x : now.st) &#123; ZT tmp = now; auto it = tmp.st.find(x); tmp.xx += x; tmp.st.erase(it); tmp.init(); ans += dfs(tmp) * x; &#125; ans /= n - 1; ans++; ans /= 1. - (double) (now.xx - 1) / (double) (n - 1); return mp[now.hsh] = ans;&#125;inline double solve() &#123; mp.clear(); read(n), read(m); for (int i = 1; i &lt;= n; ++i) &#123; fa[i] = i; siz[i] = 1; &#125; for (int i = 1; i &lt;= m; ++i) &#123; int x, y; read(x), read(y); merge(x, y); &#125; ZT fir; fir.xx = siz[1]; for (int i = 2; i &lt;= n; ++i) &#123; if (fa[i] == i) &#123; fir.st.insert(siz[i]); &#125; &#125; fir.init(); return dfs(fir);&#125;int main() &#123; int T; read(T); for (int i = 1; i &lt;= T; ++i) &#123; printf(\"Case %d: %.10f\\n\", i, solve()); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://pufanyi.pages.dev/tags/DP/"},{"name":"UVa","slug":"UVa","permalink":"https://pufanyi.pages.dev/tags/UVa/"}]},{"title":"CodeForces VP 记录","slug":"CodeForcesVP","date":"2019-08-14T16:00:00.000Z","updated":"2019-08-14T16:00:00.000Z","comments":true,"path":"CodeForcesVP/","link":"","permalink":"https://pufanyi.pages.dev/CodeForcesVP/","excerpt":"感觉tf的时候还是打几场VP好……加*号的是当场过掉的，这样以后复习可以用。","text":"感觉 tf 的时候还是打几场 VP 好……加 * 号的是当场过掉的，这样以后复习可以用。 Codeforces Round #472 (rated, Div. 1, based on VK Cup 2018 Round 2) *A. Mystical Mosaic题意好难翻译啊，那就不翻译了吧。反正直接模拟就可以了。代码：58555087 *B. Three-level Laser题目大意是给你一个长度为 n(n≤105)n(n\\le 10^5)n(n≤105) 的严格递增的正整数序列 {E}\\{E\\}{E}，让你求i&lt;j&lt;ki&lt;j&lt;ki&lt;j&lt;k 使得 Ek−Ei≤UE_k-E_i\\le UEk​−Ei​≤U 且η=Ek−EjEk−Ei\\eta=\\frac{E_k-E_j}{E_k-E_i}η=Ek​−Ei​Ek​−Ej​​最大。考虑到严格递增应该是单调性问题。显然如果 iii 和kkk固定，那么 η\\etaη 与EjE_jEj​负相关，于是 i=j−1i=j-1i=j−1。 然后考虑枚举 iii 算kkk，直接把上面的 EkE_kEk​ 去掉即可：η=Ek−EjEk−Ei=Ek−Ei+Ei−EjEk−Ei=1+Ei−EjEk−Ei\\eta=\\frac{E_k-E_j}{E_k-E_i}=\\frac{E_k-E_i+E_i-E_j}{E_k-E_i}=1+\\frac{E_i-E_j}{E_k-E_i}η=Ek​−Ei​Ek​−Ej​​=Ek​−Ei​Ek​−Ei​+Ei​−Ej​​=1+Ek​−Ei​Ei​−Ej​​二分一下就好了。代码：58555515 *C. Riverside Curio题意大概就是有一个人每天去看一条河的水位，每次在水位上画一条线，并记录下严格高于当前水位的线有几条，记为 mim_imi​。令第iii 天严格低于当前水位的线有 did_idi​ 条，求 ∑di\\sum d_i∑di​ 的最小值，n≤105n\\le 10^5n≤105。显然最少有 max⁡{mi}\\max\\{m_i\\}max{mi​} 条线，然后我们找到这个位置，然后往两边跑。往后跑就直接模拟即可，因为之后是不会画新的线了。往前跑相当于是删线，显然是能删就删，维护一下前缀 max⁡\\maxmax 即可。代码：58556096 D. Contact ATC题意是说有 n(n≤105)n(n\\le 10^5)n(n≤105) 架飞机在一条数轴上飞，坐标为 xix_ixi​，速度为viv_ivi​，有xivi&lt;0x_iv_i&lt;0xi​vi​&lt;0（往原点飞），现在可能有一速度为vvv 的风，只能预测出 v∈[−w,w]v\\in [-w,w]v∈[−w,w]，当然保证∣vi∣&lt;w|v_i|&lt;w∣vi​∣&lt;w。求有多少对飞机可能同时到达原点。 感觉自己好菜啊，推式子发现是跟斜率相关的一个东西，然后惊喜地发现这好像是道计算几何，然后码了一年……我们考虑计算出飞机到达原点的时间 ti∈[li,ri]t_i\\in [l_i,r_i]ti​∈[li​,ri​]，考虑到风速与时间是呈一个一次函数的关系，画图便可知道如果是相向飞行的飞机i,ji,ji,j，只要[li,ri]∩[lj,rj]≠∅[l_i,r_i]\\cap[l_j,r_j]\\neq \\empty[li​,ri​]∩[lj​,rj​]​=∅ 即可，如果是同向的飞机 i,ji,ji,j，只要[li,ri]⊆[lj,rj][l_i,r_i]\\subseteq[l_j,r_j][li​,ri​]⊆[lj​,rj​] 或[li,ri]⊇[lj,rj][l_i,r_i]\\supseteq[l_j,r_j][li​,ri​]⊇[lj​,rj​]即可。然后就变成了一个二维数点问题。代码：58560521 E. Wardrobe题解写在了 另一篇文章里 。 F. Minimal Subset Difference 太菜了，不会。 Codeforces Round #539 (Div. 1) *A. Sasha and a Bit of Relax题意大概就是给你一段长度为 n(n≤3×105)n(n\\le 3\\times 10^5)n(n≤3×105) 序列 {a}(0≤ai&lt;220)\\{a\\}(0\\le a_i&lt; 2^{20}){a}(0≤ai​&lt;220)，求有多少个区间[l,r][l,r][l,r] 使得 r−l+1r-l+1r−l+1 是偶数且 ⨁i=lmai=⨁i=m+1rai\\bigoplus_{i=l}^{m}a_i=\\bigoplus_{i=m+1}^{r}a_i⨁i=lm​ai​=⨁i=m+1r​ai​，其中m=l+r−12m=\\frac{l+r-1}{2}m=2l+r−1​，⨁\\bigoplus⨁ 是指 xor。 显然只要 ⨁i=lrai=0\\bigoplus_{i=l}^r a_i=0⨁i=lr​ai​=0 即可，然后开个桶算。代码：58788064 *B. Sasha and One More Name题意是给你一个回文串 s(1≤∣s∣≤5000)s(1\\le |s|\\le 5000)s(1≤∣s∣≤5000)，求最小割多少刀然后重组变成一个不同的回文串，无解输出Impossible。 显然答案只有 111、222、Impossible 三种，Impossible直接判，111直接暴力枚举，剩下来的都是 222。 代码：58788424 C. Sasha and One More Name数据结构题，直接抄了 这篇博客 的翻译：维护以下三种操作 1 t s：在时刻ttt 插入命令 sss。保证任意操作后，任意时刻至多只有一个命令。2 t：删除时刻ttt 的命令。3 l r v：求最小的 t∈[l,r]t\\in [l,r]t∈[l,r]，使得f(t)=0f(t)=0f(t)=0。 其中 f(t)=v+∫ltg(x)dxf(t) = v+\\int_l^t g(x) \\mathrm{d} xf(t)=v+∫lt​g(x)dx 其中设在 [l,r]\\left[l,r\\right][l,r] 时间内的命令依次为 (t1,s1),…,(tm,sm)(t_1, s_1), \\dots, (t_m, s_m)(t1​,s1​),…,(tm​,sm​)，则：g(t)={0l≤t&lt;t1s1t1≤t&lt;t2…sktk≤t&lt;tk+1…smt≥tm.g(t) = \\begin{cases} 0 &amp; l \\leq t &lt; t_1 \\\\ s_1 &amp; t_1 \\leq t &lt; t_2 \\\\ \\dots \\\\ s_k &amp; t_k \\leq t &lt; t_{k+1} \\\\ \\dots \\\\ s_m &amp; t \\geq t_m \\end{cases}.g(t)=⎩⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎧​0s1​…sk​…sm​​l≤t&lt;t1​t1​≤t&lt;t2​tk​≤t&lt;tk+1​t≥tm​​. 若不存在，则返回 −1−1−1。 题解留坑吧…… Codeforces Round #578 (Div. 2)打了场 Div. 2 感觉自己心情舒畅，然鹅还是自闭了……话说我的 hash 好菜啊，为什么一定要打双哈希啊……自闭了： *A. Hotelier直接模拟就可以了。代码：58884080 *B. Block Adventure还是直接模拟就可以了。代码：58884001 *C. Round Corridor大概就是有类似这样的一个圆形屋子，内层有 nnn 格，外层有 mmm 格，每层都有一面墙在 121212 时的位置，每格大小均匀。内外层没有墙，但每层格子与格子之间有墙。多次询问 (sx,sy)(s_x,s_y)(sx​,sy​) 和(ex,ey)(e_x,e_y)(ex​,ey​)询问着两个格子能否相互到达。n,m≤1018,q≤104n,m\\le 10^{18},q\\le 10^4n,m≤1018,q≤104。显然可以把这个环形分成一段一段，每段都相连且独立（与其他格子不连通）。假设一段有 xxx 个内层格子与 yyy 个外层格子，那显然有 nx=my\\frac{n}{x}=\\frac{m}{y}xn​=ym​，即ny=mxny=mxny=mx，我们需要找到最小的x,yx,yx,y，也就是ny=mx=lcm(n,m)=nmgcd⁡(n,m)ny=mx=\\mathrm{lcm}(n,m)=\\frac{nm}{\\gcd(n,m)}ny=mx=lcm(n,m)=gcd(n,m)nm​，也就是x=ngcd⁡(n,m),y=mgcd⁡(n,m)x=\\frac{n}{\\gcd(n,m)},y=\\frac{m}{\\gcd(n,m)}x=gcd(n,m)n​,y=gcd(n,m)m​，然后每次O(1)\\mathcal{O}(1)O(1) 判断两个点是否在同一联通块中即可。代码：58883764 *D. White Lines题意是有一块 n×nn\\times nn×n 的画布，有一些像素点是 W，有一些是B，你可以将一个k×kk\\times kk×k 的子矩阵中所有的 B 全部变成 W，问做多能有多少行列是全白色的，n≤2000n\\le 2000n≤2000。 我们考虑行和列分开来看，我们令 fi,jf_{i,j}fi,j​ 表示左上角在第 iii 行第 jjj 列，会把多少原来不是全白的行变成全白的行，同理可以定义 gi,jg_{i,j}gi,j​ 表示会把多少原来不是全白的列变成全白的列。当然，为了复制粘贴方便，代码中把 gi,jg_{i,j}gi,j​ 定义为了左上角在第 jjj 行第 iii 列。由于转移是对称（行和列的方程一样）的，所以我们就仅考虑行。我们考虑要把一行变成全白，必须把该行上最左边的黑色格子和最右边的黑色格子全部覆盖到，所以对于每行我们可以 O(1)\\mathcal{O}(1)O(1) 计算。我们考虑先 O(nk)\\mathcal{O}(nk)O(nk) 暴力算出 f1,jf_{1,j}f1,j​，然后每次计算fi,jf_{i,j}fi,j​ 考虑增加第 i+k−1i+k-1i+k−1 行的贡献并删除第 i−1i-1i−1 行的贡献即可。这样复杂度就是 O(n2)\\mathcal{O}(n^2)O(n2) 的了。代码：58884654 E.Compress Words题目大意是有 nnn 个字符串 sis_isi​，从左往右依次合并每一个字符串，就是找到之前合并完的串的最长后缀使其是要合并的那个串的前缀，输出最终合并完的串，n≤105,∑∣si∣≤106n\\le 10^5,\\sum|s_i|\\le10^6n≤105,∑∣si​∣≤106。 直接哈希就可以了，复杂度 O(n)\\mathcal{O}(n)O(n)…… 大概需要双哈希，我的单哈希 wa on 66。 代码：58886006 Codeforces Round #589 (Div. 2)又是一场愉快的 Div. 2。可惜窝还是爆蛋了…… *A. Distinct Digits直接模拟即可……代码：61680483 *B. Filling the Grid直接模拟即可……代码：61680658 *C. Primes and Multiplication题目大意有点复杂，然后我就看错了一年的题……定义 prime(x)\\mathrm{prime}(x)prime(x) 表示 xxx 的质因子集合，g(x,p)g(x,p)g(x,p)表示最大的 pk∣x(k∈N)p^k\\mid x(k\\in \\mathbb{N})pk∣x(k∈N)，f(x,y)=∏k∈prime(x)g(y,k)f(x,y)=\\prod_{k\\in \\mathrm{prime}(x)}g(y,k)f(x,y)=∏k∈prime(x)​g(y,k)，求∏i=1nf(x,i)\\prod_{i=1}^nf(x,i)∏i=1n​f(x,i)。（x≤109,n≤1018x\\le 10^9,n\\le 10^{18}x≤109,n≤1018） 考虑到全是乘法，显然满足交换律。所以我们对每个质因子分开来求，最后乘起来即可。我们考虑质因子 kkk，显然1∼k−11\\sim k-11∼k−1 的区间贡献是 111，k∼k2−1k\\sim k^2-1k∼k2−1 的贡献是 kkk，k2∼k3−1k^2\\sim k^3-1k2∼k3−1 的贡献是 k2k^2k2…… 然后不难发现只有 log⁡\\loglog 个这样的区间，所以总复杂度O(x+log⁡xlog⁡n)\\mathcal{O}(\\sqrt x + \\log x\\log n)O(x​+logxlogn)。代码：61681335 *D. Complete Tripartite有 n(3≤n≤105)n(3\\le n\\le 10^5)n(3≤n≤105) 个点 m(0≤m≤min⁡(3⋅105,n(n−1)2))m(0\\le m\\le \\min(3\\cdot 10^5,\\frac{n(n-1)}{2}))m(0≤m≤min(3⋅105,2n(n−1)​)) 条边的无向无自环无重边图，需要对每条边染色（1,2,31,2,31,2,3），使得每种颜色自己的点之间没有边，其余的必须两两有边，求一种方案或无解。直接模拟即可……代码：61681851 *E. Another Filling the Grid有一个 n×nn\\times nn×n 的矩阵，需要将每个格子用 1∼k1\\sim k1∼k 的数字填充，要求每行每列都有至少一个 111，求方案数。n≤250,k≤109n\\le 250,k\\le 10^9n≤250,k≤109。O(n3)\\mathcal{O}(n^3)O(n3) 的dp很好想，直接令 fi,jf_{i,j}fi,j​ 表示到第 iii 行已经有 jjj 列有 111。 考虑转移，枚举一个 ttt 表示这一列之前有多少列有 111，那么这些格子可以乱填，为ktk^tkt。其中j−tj-tj−t 个格子只能填 111，其余格子不能填111。这样直接转移过去即可。 由于每一行也至少要有一个 111，所以转移时一行中没有一个111 的方案数减掉即可。代码：61682746结果一看题解发现复杂度可以更优。我们考虑容斥，有 iii 行jjj列没有 111，所以答案就是：∑i=0n(−1)i(ni)∑j=0n(−1)j(nj)k(n−i)(n−j)(k−1)ni+nj−ij\\sum_{i=0}^n(-1)^i\\binom{n}{i}\\sum_{j=0}^n(-1)^j\\binom{n}{j}k^{(n-i)(n-j)}(k-1)^{ni+nj-ij}i=0∑n​(−1)i(in​)j=0∑n​(−1)j(jn​)k(n−i)(n−j)(k−1)ni+nj−ij 当然写的好看一点也可以是：∑i=0n∑j=0n(−1)i+j(ni)(nj)k(n−i)(n−j)(k−1)ni+nj−ij\\sum_{i=0}^n\\sum_{j=0}^n(-1)^{i+j}\\binom{n}{i}\\binom{n}{j}k^{(n-i)(n-j)}(k-1)^{ni+nj-ij}i=0∑n​j=0∑n​(−1)i+j(in​)(jn​)k(n−i)(n−j)(k−1)ni+nj−ij这样就可以 n2log⁡nn^2\\log nn2logn 啦！然后我们考虑继续优化。我们观察后面那只 ∑\\sum∑：∑j=0n(−1)j(nj)k(n−i)(n−j)(k−1)ni+nj−ij\\sum_{j=0}^n(-1)^j\\binom{n}{j}k^{(n-i)(n-j)}(k-1)^{ni+nj-ij}j=0∑n​(−1)j(jn​)k(n−i)(n−j)(k−1)ni+nj−ij 我们发现她可以转换成一个二项式展开的形式，也就是把后面的 (k−1)ni+nj−ij(k-1)^{ni+nj-ij}(k−1)ni+nj−ij 看成是 (k−1)i(n−j)⋅(k−1)nj(k-1)^{i(n-j)}\\cdot(k-1)^{nj}(k−1)i(n−j)⋅(k−1)nj：∑j=0n(nj)(kn−i(k−1)i)n−j(−(k−1)n)j=(kn−i(k−1)i−(k−1)n)n\\sum_{j=0}^n\\binom{n}{j}\\left(k^{n-i}(k-1)^i\\right)^{n-j}\\left(-(k-1)^n\\right)^j=\\left(k^{n-i}(k-1)^i-(k-1)^n\\right)^nj=0∑n​(jn​)(kn−i(k−1)i)n−j(−(k−1)n)j=(kn−i(k−1)i−(k−1)n)n 于是最终答案就变成了：∑i=0n(−1)i(ni)(kn−i(k−1)i−(k−1)n)n\\sum_{i=0}^n(-1)^i\\binom{n}{i}\\left(k^{n-i}(k-1)^i-(k-1)^n\\right)^ni=0∑n​(−1)i(in​)(kn−i(k−1)i−(k−1)n)n复杂度O(nlog⁡n)\\mathcal{O}(n\\log n)O(nlogn)。","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"}]},{"title":"新坑","slug":"cfdpproblems","date":"2019-08-03T16:00:00.000Z","updated":"2019-08-03T16:00:00.000Z","comments":true,"path":"cfdpproblems/","link":"","permalink":"https://pufanyi.pages.dev/cfdpproblems/","excerpt":"决定开个新坑，刷一些CF上的dp题。现在做了几题：10","text":"决定开个新坑，刷一些 CF 上的 dp 题。现在做了几题：10[2019.8.5]忽然发现 stoxielinhanorz 怎么什么题都做过啊，果然是神仙……[2019.8.6]大家快看这里有个叫 pufanyi 的沙雕自闭了：果然他是个菜鸡……[2019.9.21]文化课真香……感觉好久没做题了…… CodeForces 913F Strongly Connected Tournament有 nnn 个国际象棋棋手，他们先两两比赛，实力强的会有 ppp 的概率打败实力弱的（ppp从头至尾都是相同的），然后赢得把边连向败的。然后再把每个强连通分量的抠出来继续做，知道所有人都有一个唯一的排名。求共期望下棋多少盘。我们令 fif_ifi​ 表示有 iii 名棋手的答案，我们考虑转移。我们有：fi=∑j=1ngi,jsj(fj+fi−j+i(i−j)+j(j−1)2)f_i=\\sum_{j=1}^{n} g_{i,j}s_{j}\\left(f_j+f_{i-j}+i(i-j)+\\frac{j(j-1)}{2}\\right)fi​=j=1∑n​gi,j​sj​(fj​+fi−j​+i(i−j)+2j(j−1)​)其中 gi,jg_{i,j}gi,j​ 表示从 iii 个点中选出 jjj 个点而这 jjj 个点均被另外 i−ji-ji−j 个点打败的概率，sis_isi​表示 iii 个点是强连通分量的概率。大概思路就是枚举一下 只要我们算出 sis_isi​ 和gi,jg_{i,j}gi,j​，剩下的就是解方程的问题了。我们考虑 gi,jg_{i,j}gi,j​ 的转移。我们考虑最后一个节点是否选入 jjj 个的这个集合中：gi,j=pi−jgi−1,j−1+(1−p)jgi−1,jg_{i,j}=p^{i-j}g_{i-1,j-1}+(1-p)^{j}g_{i-1,j}gi,j​=pi−jgi−1,j−1​+(1−p)jgi−1,j​然后我们考虑 sis_isi​。 我们考虑用 ggg 转移 sss：si=1−∑j=1i−1sjgi,js_i=1-\\sum_{j=1}^{i-1} s_jg_{i,j}si​=1−j=1∑i−1​sj​gi,j​ 代码：58105715 CodeForces 908G New Year and Original Order给 n≤10700n\\le 10^{700}n≤10700，问111 到nnn中每个数在各数位排序后得到的数的和。答案膜 109+710^9+7109+7。[1] 一道有趣的数位 dp。我们令 fi,j,k,[0/1]f_{i,j,k,[0/1]}fi,j,k,[0/1]​ 表示从高到低第 iii 位，共有 jjj 个数超过 kkk，是否卡上界（[0/1][0/1][0/1]）。 转移比较简单：1f[i + 1][j + (p &gt;= k)][k][K &amp;&amp; (p == d[i + 1])] += f[i][j][k][K];考虑统计答案，冷（da）静（kai）思（ti）考（jie）之后就会发现是这个：∑(fn,i,j,0+fn,i,j,1)×11⋯111⏟i个 1\\sum \\left(f_{n,i,j,0}+f_{n,i,j,1}\\right)\\times \\underbrace{11\\cdots 111}_{i\\text{个}1}∑(fn,i,j,0​+fn,i,j,1​)×i 个111⋯111​​代码：58147084 CodeForces 889E Mod Mod Mod给出长度为 n(n≤200000)n(n\\le 200000)n(n≤200000) 的序列 {a}\\{a\\}{a}，定义f(x,i)(x≥0,i≥1)f(x,i)(x\\ge 0,i\\ge 1)f(x,i)(x≥0,i≥1) 为：f(x,i)={x mod aii=nx mod ai+f(x mod ai,i+1)1≤i&lt;nf(x,i)= \\begin{cases} x\\bmod a_i&amp; i=n\\\\ x\\bmod a_i + f(x\\bmod a_i,i+1)&amp; 1\\le i &lt; n \\end{cases}f(x,i)={xmodai​xmodai​+f(xmodai​,i+1)​i=n1≤i&lt;n​求 f(x,1)f(x,1)f(x,1) 的最大值。神仙的状态定义。我们考虑把答案分解为 ki+bki+bki+b 的形式，iii表示的是做到 aia_iai​ 的时候。我们考虑 gi,jg_{i,j}gi,j​ 表示到第 iii 个数，k=jk=jk=j时最大的 bbb。这样答案就是max⁡i=0∞ni+gn,i\\max_{i=0}^{\\infty}ni+g_{n,i}maxi=0∞​ni+gn,i​。 我们考虑优化这个方程。首先我们需要发现一个性质：最优方案一定有某个余数为 ai−1a_i-1ai​−1，否则整体+1+1+1 即可。[2]于是我们发现，其实只要考虑是哪次取模后变成 ai−1a_i-1ai​−1 即可。我们考虑在 dp 中体现。我们发现许多状态是冗余的，因为可以从一些状态计算出另一些状态的答案。事实上就是整体上移和整体下移。于是我们有转移方程：{fi+1,x mod ai←fi,x+(x−x mod ai)×(i−1)（之前已经是卡上界了，这次直接取模）fi+1,ai←fi,x+ai+1(x−x mod ai−ai)×(i−1)（比较难理解，画个图会比较清晰，大概是整体下移了一些，使得 x mod ai=ai−1）\\begin{cases} f_{i+1,x\\bmod a_i}\\leftarrow f_{i,x}+(x-x\\bmod a_i)\\times(i-1)&amp;\\text{（之前已经是卡上界了，这次直接取模）}\\\\ f_{i+1,a_i}\\leftarrow f_{i,x}+a_{i+1}(x-x\\bmod a_i - a_i)\\times(i-1)&amp;\\text{（比较难理解，画个图会比较清晰，大概是整体下移了一些，使得 $x\\bmod a_i=a_i-1$）} \\end{cases}{fi+1,xmodai​​←fi,x​+(x−xmodai​)×(i−1)fi+1,ai​​←fi,x​+ai+1​(x−xmodai​−ai​)×(i−1)​（之前已经是卡上界了，这次直接取模）（比较难理解，画个图会比较清晰，大概是整体下移了一些，使得xmodai​=ai​−1）​ 这个东西直接用 map 维护即可。一个结论是如果 x&gt;yx&gt;yx&gt;y，则x mod y≤x2x\\bmod y\\le \\frac{x}{2}xmody≤2x​。这个东西好像曾经 cf 有道数据结构题就用的是这个结论。大概就是考虑y≤x2y\\le \\frac{x}{2}y≤2x​ 和y&gt;x2y&gt;\\frac{x}{2}y&gt;2x​讨论即可。所以复杂度是 O(nlog⁡nlog⁡a1)\\mathcal{O}(n\\log n\\log a_1)O(nlognloga1​) 代码：58244734 CodeForces 886E Maximum Element题意就是有一个老哥发明了一种 神奇的 求序列最大值的算法：12345678910111213141516int fast_max(int n, int a[]) &#123; int ans = 0; int offset = 0; for (int i = 0; i &lt; n; ++i) &#123; if (ans &lt; a[i]) &#123; ans = a[i]; offset = 0; &#125; else &#123; offset = offset + 1; if (offset == k) &#123; return ans; &#125; &#125; &#125; return ans;&#125;看起来挺牛皮，但是有一定错误率。给出 n,kn,kn,k，求有多少个1∼n1\\sim n1∼n 的排列能把这位老哥给卡掉，答案对 109+710^9+7109+7 取模。我们令 fif_ifi​ 表示长度为 iii 的排列时，且 iii 在第 iii 个数的答案。转移时我们考虑第 i−1i-1i−1 个数放在哪儿：如果放在前 i−k−1i-k-1i−k−1 位，因为二元组 (i−1,i)(i-1,i)(i−1,i) 是不合法的，所以另外的可以乱放，即 (i−k−1)⋅(i−2)!(i-k-1)\\cdot (i-2)!(i−k−1)⋅(i−2)!。 如果放在最后 kkk 位（当然最后一位是 iii），那么假设它放在了第jjj 位，则 j∼ij\\sim ij∼i 这一段肯定是合法的，所以有 Pi−2i−j−1=(i−2)!(j−1)!P_{i-2}^{i-j-1}=\\frac{(i-2)!}{(j-1)!}Pi−2i−j−1​=(j−1)!(i−2)!​ 种方案，又因为前 jjj 个必须不合法，所以有 fjf_jfj​ 种方案。综上，有 fj⋅(i−2)(j−1)!f_j\\cdot \\frac{(i-2)}{(j-1)!}fj​⋅(j−1)!(i−2)​ 种方案。综上，我们可以得到方程：fi=(i−k−1)⋅(n−2)!+∑j=i−ki−1fj⋅(i−2)!(j−1)!f_i=(i-k-1)\\cdot(n-2)!+\\sum_{j=i-k}^{i-1}f_j\\cdot \\frac{(i-2)!}{(j-1)!}fi​=(i−k−1)⋅(n−2)!+j=i−k∑i−1​fj​⋅(j−1)!(i−2)!​发现这个 ∑\\sum∑ 可以前缀和，维护一下就变成 O(n)\\mathcal{O}(n)O(n) 的了。代码：58319515 CodeForces 878E Numbers on the blackboard有一个长度为 nnn 的序列 {a}\\{a\\}{a}，每次询问其中一段区间[l,r][l,r][l,r]，对这个区间内部的点进行操作，每次操作可以找到两个相邻的数x,yx,yx,y 将其合并成 x+2yx+2yx+2y，询问把这个区间缩成一个数是，这个数最大可能是多少，每个询问独立，答案对109+710^9+7109+7 取模。不知道为什么，交了 60 多发还是 T on 40，然后就去膜拜别人代码了…… 我们发现其实就是求 ∑i=lr2kiai\\sum_{i=l}^r 2^{k_i}a_i∑i=lr​2ki​ai​，其中kl=0k_l=0kl​=0，其余的ki∈[1,ki−1+1]k_i\\in [1, k_{i-1}+1]ki​∈[1,ki−1​+1]。 那么我们发现，对于每一个询问，我们都可以把 kkk 分成若干段区间，每一段区间 [s,t][s, t][s,t] 表示 ks=1k_s=1ks​=1，ki=ki−1+1(i∈(s,t])k_i=k_{i-1}+1(i\\in \\left(s, t\\right])ki​=ki−1​+1(i∈(s,t])，当然，第一段ks=0k_s=0ks​=0。 我们考虑离线枚举右端点 rrr，显然，如果ar&lt;0a_r&lt;0ar​&lt;0，那么ara_rar​ 单独成一段，否则与前一段合并，知道该段的值小于 000，我们发现合并是O(1)\\mathcal{O}(1)O(1) 的（然而一开始的时候我硬生生地写成了 log⁡\\loglog）。 我们考虑用并查集维护每一段，每次查询即可。不过讲道理这跟 dp 有关系吗？不管反正标签有 dp。 代码：58520589 CodeForces 924E Wardrobe有 n(n≤104)n(n\\le 10^4)n(n≤104) 个箱子，每个箱子有一个高度 hi(∑hi≤104)h_i(\\sum h_i\\le 10^4)hi​(∑hi​≤104)，一些箱子是重要的。现在要把所有箱子叠放在一起。问有多少个箱子底部的高度位于[l,r][l,r][l,r]。 一道有趣的背包问题，感觉跟那道 小矮人 差不多。首先我么需要发现一个性质，那就是最优解肯定是先一段不重要的，在一段重要的，最后一段不重要的。正确性显然。我们考虑到箱子底部比较难受，于是我们想到用把整个系统倒过来，这样我们就相当于是在考虑箱子顶部了。我们发现我们需要知道这样一些东西：最低端那些不重要的箱子是那些（因为顺序无关），当然这样其实也知道了最顶端的情况。我们还需要知道重要箱子的排列情况。先考虑不重要的箱子，我们发现这些箱子只是给我们打一个“底座”，所以我们可以直接 dp 出来，其实就是个背包。然后我们考虑重要的箱子。有一个结论是把这些重要的箱子从大到小排序，然后直接做一遍背包（在之前不重要的箱子的那个 dp 数组之上直接做就可以了）就是对的。那为什么要从大到小排序呢？我们考虑这个背包的本质其实就是先把这些箱子按照一定顺序从下往上排，我们可以删掉任意多的箱子使得 [l,r][l,r][l,r] 内重要的箱子顶最多。我们大概考虑是把最小的那些放在 [l,r][l,r][l,r] 内，而一些大的要么删掉，要么和不重要的箱子一起当“底座”。所以我们考虑从大到小排序，如果不删，就是当“底座”，否则就是把它删掉。代码：58638973 CodeForces 1218A BubbleReactor给你 n(3≤n≤15000)n(3\\le n\\le 15000)n(3≤n≤15000) 一棵环套树，一开始全是白点。先给一个点染成黑色，获得 nnn 的收益。然后每次可以选择一个与黑色点相邻的白点并将其染成黑色，获得收益是其所在连通块的大小。求最大收益。O(n2)\\mathcal{O}(n^2)O(n2)居然过了，然后去围观了一下标算发现也是 O(n2)\\mathcal{O}(n^2)O(n2) 的。CF 机子真快。把环上的边全部删除，以换上点为根，可以得到一个森林。先令 fif_ifi​ 表示从 iii 开始把 iii 的所有子树全部染黑所能获得的代价，这个很好 dp。 然后令 gig_igi​ 表示从 iii 点开始往子树外把 iii 的所有子树全部染黑所获得的代价。特殊地，第一次也就是染第 iii 个点时的贡献为 n−sin-s_in−si​ 而不是 n−si+1n-s_i+1n−si​+1，其中sis_isi​ 表示 iii 的子树大小。因为这样才能让 fi+gif_i+g_ifi​+gi​ 直接表示从 iii 点开始染色的答案。我们考虑先 dp 出环上的 ggg 数组，然后往儿子 dp。 我们令 hl,rh_{l,r}hl,r​ 表示环上将 [l,r][l,r][l,r] 这些点染黑并将其子树染黑的答案，显然 hi,i=fih_{i,i}=f_ihi,i​=fi​。 我们令 pre(i)pre(i)pre(i) 表示环上 iii 的上一个，nxt(i)nxt(i)nxt(i)表示 iii 的下一个，比如如果环大小为 mmm，则nxt(m)=1,pre(1)=mnxt(m)=1,pre(1)=mnxt(m)=1,pre(1)=m。 如果 l&gt;rl&gt;rl&gt;r，那其实就是越过了mmm 点，重新回到了 111 点。我们有转移：hl,r=max⁡{hnxt(l),r+fl+∑k∈[nxt(l),r]sk,hl,pre(r)+fr+∑k∈[l,pre(r)]sk}h_{l,r}=\\max\\left\\{h_{nxt(l),r}+f_l+\\sum_{k\\in [nxt(l),r]}s_k,h_{l,pre(r)}+f_r+\\sum_{k\\in[l,pre(r)]}s_k\\right\\}hl,r​=max⎩⎨⎧​hnxt(l),r​+fl​+k∈[nxt(l),r]∑​sk​,hl,pre(r)​+fr​+k∈[l,pre(r)]∑​sk​⎭⎬⎫​于是最终答案 gi=hnxt(i 在环上的位置 ),pre(i 在环上的位置 )g_{i}=h_{nxt(\\text{$i$ 在环上的位置}),pre(\\text{$i$ 在环上的位置})}gi​=hnxt(i 在环上的位置 ),pre(i 在环上的位置 )​ 我们考虑对 hhh 数组压位。考虑到 dp 第一层循环是枚举 lenlenlen（即r−l+1r-l+1r−l+1），于是我们可以直接令状态为hlen,lh_{len,l}hlen,l​，然后就可以把lenlenlen 压掉了。最后余下的点直接从上往下 dp 即可。代码：60925813 CodeForces 1203F2 Complete the Projects (hard version)Div. 3 的题好难啊……有 n(n≤100)n(n\\le 100)n(n≤100) 个任务，初始有一个分数 r(r≤30000)r(r\\le 30000)r(r≤30000)，做第iii 个任务需要达到 ai(1≤ai≤30000)a_i(1\\le a_i\\le 30000)ai​(1≤ai​≤30000) 的分数，完成后分数会增加 bi(−300≤bi≤300)b_i(-300\\le b_i\\le 300)bi​(−300≤bi​≤300)。每一时刻分数都需要大于等于000，求最多能完成的任务数量。 首先肯定想到的是背包，和 小矮人 （完了去看题目的时候发现为什么现在小矮人变成nlog⁡nn\\log nnlogn 的了，不管了，先记录一下 ，写完这篇题解再说）差不多，我们考虑背包的顺序。 显然 bi≥0b_i\\ge0bi​≥0 和bi&lt;0b_i&lt;0bi​&lt;0是要分类的，先做 bi≥0b_i\\ge 0bi​≥0 的，因为 bi&lt;0b_i&lt;0bi​&lt;0 的只能让分数下降，在最前面肯定不优。显然对于 bi≥0b_i\\ge0bi​≥0 的，我们可以对于 aia_iai​ 从小到大排序。我们考虑如何对 bi&lt;0b_i&lt;0bi​&lt;0 的进行排序。我们假设有 i,ji,ji,j，iii 放在 jjj 前面更优，那么我们就优，那只能是如果取完 jjj，就不能再取iii 了。我们假设开始有 rrr 的积分，我们有：{r≥max⁡(ai,aj)r+bi≥ajr+bj&lt;ai\\begin{cases} r\\ge \\max(a_i,a_j)\\\\ r+b_i\\ge a_j\\\\ r+b_j&lt; a_i \\end{cases}⎩⎪⎨⎪⎧​r≥max(ai​,aj​)r+bi​≥aj​r+bj​&lt;ai​​于是我们有：aj−bi≤r&lt;ai−bja_j-b_i\\le r&lt;a_i-b_jaj​−bi​≤r&lt;ai​−bj​即：ai+bi&gt;aj+bja_i+b_i&gt;a_j+b_jai​+bi​&gt;aj​+bj​于是我们按 ai+bia_i+b_iai​+bi​ 从大到小排序即可。代码：61593790 CodeForces 1234F One Node is Gone感觉现在沉迷于 Div. 3 了……题目大意是给你一个字符集为 202020，长度为10610^6106 的字符串，你可以翻转其中的一个子串，使操作后的串最大完美子串最长。完美子串就是该子串中没有字符是相同的。显然就是让你找两个不相交的字符串他们拼起来是完美的。然后我们发现我们不用考虑相交，因为两个子串相交就肯定是不完美的了。考虑到找到的两个串首先肯定分别都是完美子串，我们考虑把所有完美子串都找出来。不难证明暴力找子串的复杂度是 O(n∣∑∣)\\mathcal O(n\\left|\\sum\\right|)O(n∣∑∣)，因为对于每个字符，以他们为结尾的完美子串最多不过nnn 个。然后我们直接类似高维前缀和一样预处理一下高维前缀 max⁡\\maxmax，最后统计一下答案即可。 代码：61748541 CodeForces 1218H Function Composition题目大意是给你一个长度为 nnn 的数列 aaa，定义f(x,y)={xy=0af(x,y−1)y&gt;0f(x,y)=\\begin{cases}x&amp;y=0\\\\a_{f(x,y-1)}&amp;y&gt;0\\end{cases}f(x,y)={xaf(x,y−1)​​y=0y&gt;0​，让你求在1∼n1\\sim n1∼n 中，有多少个 xxx 满足 f(x,m)=yf(x,m)=yf(x,m)=y，qqq 次询问，1≤n≤2⋅105,1≤ai≤n,1≤q≤105,1≤m≤1018,1≤y≤n1\\le n\\le 2\\cdot 10^5,1\\le a_i\\le n,1\\le q\\le 10^5,1\\le m\\le {10}^{18},1\\le y\\le n1≤n≤2⋅105,1≤ai​≤n,1≤q≤105,1≤m≤1018,1≤y≤n。我们考虑 iii 向aia_iai​连一条有向边，不难发现这张图变成了环套内向森林。我们考虑将询问离线。首先考虑 yyy 为不在环上点的询问。这个显然只要 dp 一下即可，就是记 fi,jf_{i,j}fi,j​ 表示到第 iii 个点需要 jjj 步的答案，向上转移的时候启发式合并一下即可。当然用 dfs 序是可以 O(n)\\mathcal{O}(n)O(n) 做的。考虑 yyy 在环上的询问。我们对每个环找到环上一条边，将这条边断开，分别处理路径经过这条边的答案和不经过这条边的答案，这两个都可以类似上面的 dp 做，最后对加一下即可。代码：61582213翻译来自 luogu.org ↩︎ 摘自zory.ink ↩︎","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"DP","slug":"DP","permalink":"https://pufanyi.pages.dev/tags/DP/"}]},{"title":"AGC006F Blackout","slug":"agc006_f","date":"2019-04-20T16:00:00.000Z","updated":"2019-04-20T16:00:00.000Z","comments":true,"path":"agc006_f/","link":"","permalink":"https://pufanyi.pages.dev/agc006_f/","excerpt":"我们有一个NNN行NNN列的矩阵。第iii行第jjj列的格子表示为(i,j)(i,j)(i,j)。开始时，有MMM个格子是黑色，其他格子都是白色。特别地，开始时格子(a1,b1),(a2,b2),⋯ ,(aM,bM)(a_1,b_1),(a_2,b_2),\\cdots,(a_M,b_M)(a1​,b1​),(a2​,b2​),⋯,(aM​,bM​)是黑色。スヌケ君会按照以下的规则尽可能多的将白色格子涂成黑色：对于整数1≤x,y,z≤N1\\le x,y,z\\le N1≤x,y,z≤N，如果(x,y)(x,y)(x,y)和(y,z)(y,z)(y,z)都是黑色，那么就把(z,x)(z,x)(z,x)涂黑。请计算出当再也没有白色格子能被涂黑时，黑色格子的个数。1≤N,M≤105;1≤ai,bi≤N1\\le N,M\\le 10^5;1\\le a_i,b_i\\le N1≤N,M≤105;1≤ai​,bi​≤N。[1]","text":"我们有一个 NNN 行NNN列的矩阵。第 iii 行第 jjj 列的格子表示为 (i,j)(i,j)(i,j)。 开始时，有 MMM 个格子是黑色，其他格子都是白色。特别地，开始时格子 (a1,b1),(a2,b2),⋯ ,(aM,bM)(a_1,b_1),(a_2,b_2),\\cdots,(a_M,b_M)(a1​,b1​),(a2​,b2​),⋯,(aM​,bM​) 是黑色。スヌケ君会按照以下的规则尽可能多的将白色格子涂成黑色：对于整数 1≤x,y,z≤N1\\le x,y,z\\le N1≤x,y,z≤N，如果(x,y)(x,y)(x,y) 和(y,z)(y,z)(y,z)都是黑色，那么就把 (z,x)(z,x)(z,x) 涂黑。请计算出当再也没有白色格子能被涂黑时，黑色格子的个数。1≤N,M≤105;1≤ai,bi≤N1\\le N,M\\le 10^5;1\\le a_i,b_i\\le N1≤N,M≤105;1≤ai​,bi​≤N。[1] 题解 按照套路，我们应该把行和列看成点，即有 1∼N1\\sim N1∼N 个点，每个格子 (x,y)(x,y)(x,y) 可以看成是 x→yx\\to yx→y 的一条有向边。如果存在边 (x,y)(x,y)(x,y) 与边 (y,z)(y,z)(y,z)，就连边(z,x)(z,x)(z,x)，询问最终有几条边。 我们将每个弱连通分量分开考虑。我们考虑什么时候不能加边了，大概是这 222 中情况：已经是完全图了，边数为 n×(n−1)n\\times (n - 1)n×(n−1)。 图被划分为 333 个集合（可以是空集）A,B,CA,B,CA,B,C，AAA的所有点向 BBB 的所有点连边，BBB的所有点向 CCC 连边，CCC的所有点向 AAA 连边，边数为 ∣A∣×∣B∣+∣B∣×∣C∣+∣C∣×∣A∣|A|\\times |B| + |B|\\times |C| + |C|\\times |A|∣A∣×∣B∣+∣B∣×∣C∣+∣C∣×∣A∣。 我们发现一个点集如果会到情况 222，那就到情况222，否则就是情况111。 于是我们尝试划分集合，将弱连通块中每个点一遍 dfs 染色，如果染色成功，那就是情况 222，否则就是情况111。 翻译来自luogu ↩︎","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"}]},{"title":"ARC068F Solitaire","slug":"arc068_d","date":"2019-04-20T16:00:00.000Z","updated":"2019-04-20T16:00:00.000Z","comments":true,"path":"arc068_d/","link":"","permalink":"https://pufanyi.pages.dev/arc068_d/","excerpt":"将1∼n1\\sim n1∼n顺序加入双端队列（每次可加头可加尾），再删除（每次可删头可删尾），求有多少种删除序列，使得111是第kkk个被删的。[1]k≤n≤2000k\\le n\\le 2000k≤n≤2000","text":"将 1∼n1\\sim n1∼n 顺序加入双端队列（每次可加头可加尾），再删除（每次可删头可删尾），求有多少种删除序列，使得 111 是第 kkk 个被删的。[1]k≤n≤2000k\\le n\\le 2000k≤n≤2000 题解 根据套路这种计数类题我们应该考虑什么样的序列满足性质。我们考虑我们是如何构造这段序列的。一开始，我们将 1∼n1\\sim n1∼n 的排列放入双端队列中，那应该是这样的：然后我们考虑取出后哪些数是可以放在 111 前面的：大概就应该是上图红色和蓝色的（当然分成两段的可能是红色而不是绿色）。于是我们发现 111 前面的序列（包括 111）可以划分为两个单调递减的子序列（111 划给与他相邻的那个序列，反正他是最小的）：我们发现如果是这样的话，与 111 相邻颜色序列的末尾一定是 111，另一个子序列的末尾（即最小值）一定比绿色序列中的最大值要大。 于是我们就可以愉快地 dp 辣！显然后面那段绿色的我们是可以随便选的，即每次选左边和选右边都可以，也就是 2n−k−12^{n-k-1}2n−k−1。 我们考虑如何 dp 出前面的序列。一个非常 simple 的想法是令 fi,j,kf_{i,j,k}fi,j,k​ 表示到第 iii 位，红色序列（结尾为 111 的序列，下同）的最小值为 jjj，蓝色序列的最小值为kkk。如果我们加进去一个数字xxx，我们考虑加入哪一段序列。 我们有如下贪心：我们尽量把小的数扔给红色序列（因为蓝色序列的最小值越大越可能符合条件）。如果 x&lt;jx&lt;jx&lt;j，那我们就丢给红色序列，否则只能丢给蓝色序列。 但由于我们无法枚举 xxx，所以上面的dp 行不通，但我们得到了一个有趣的贪心策略。有上面的贪心策略，我们发现只要我们能知道所有合法的 xxx，我们就不必关心kkk 是多少。所以我们考虑令 fi,j,kf_{i,j,k}fi,j,k​ 表示红色序列有 iii 个数，蓝色序列有 jjj 个数，红色序列的最小值为 kkk 的方案数。我们考虑对于一个状态 fi,j,kf_{i,j,k}fi,j,k​，我们有两种方案进行转移： 选择一个最大的数放入蓝色序列，当然前提条件是存在这个大于 kkk 的数。由于这个数不可能放在红色序列里了，且如果不选最大的那个而去选其他大于 kkk 的数，那也就意味着这个最大的数要给绿色序列。而这样一来绿色序列就会有一个数比蓝色序列大，这显然是不合法的。也就是 fi,j,k→fi,j+1,kf_{i,j,k} \\to f_{i,j+1,k}fi,j,k​→fi,j+1,k​。 选择一个比 kkk 小的数给红色序列。也就是 fi,j,k→fi+1,j,1∼k−1f_{i,j,k} \\to f_{i+1,j,1\\sim k-1}fi,j,k​→fi+1,j,1∼k−1​ 这样做复杂度 O(n4)\\mathcal{O}(n^4)O(n4)，前缀和优化一下复杂度就变成了O(n3)\\mathcal{O}(n^3)O(n3) 我们发现我们并不必关心 iii 和jjj，因为根据上面的贪心策略，我们只要知道最小的一个（红色序列的最小值显然比蓝色的最小值小，因为比红色序列最小值小的数只会被放入红色序列）就可以转移了。我们令 fi,jf_{i,j}fi,j​ 表示到第 iii 位，最小的一位为 jjj，我们发现转移方式和上面没有本质区别： 选择一个最大的数放入蓝色序列。fi,j→fi+1,jf_{i,j}\\to f_{i+1,j}fi,j​→fi+1,j​。选择一个比 kkk 小的数给红色序列。fi,j→fi+1,1∼k−1f_{i,j}\\to f_{i+1,1\\sim k-1}fi,j​→fi+1,1∼k−1​。发现第一维可以直接压掉，然后直接 dp 即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;typedef long long LL;const int maxn = 2005;const int mod = 1000000007;inline int pow(int a, int b)&#123; if (b &lt; 0) return 1; int ans = 1; for (; b; b &gt;&gt;= 1, a = (LL) a * a % mod) if (b &amp; 1) ans = (LL) ans * a % mod; return ans;&#125;int dp[maxn];int main()&#123; int n, k; cin &gt;&gt; n &gt;&gt; k; dp[n + 1] = 1; for (int i = 1; i &lt;= k; ++i) &#123; for (int j = n; j; --j) &#123; if (n - j + 1 &lt; i) dp[j] = 0; else &#123; dp[j] = dp[j + 1] + dp[j]; if (dp[j] &gt;= mod) dp[j] -= mod; &#125; &#125; &#125; cout &lt;&lt; (LL) dp[1] * pow(2, n - k - 1) % mod; return 0;&#125; 翻译来自luogu ↩︎","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://pufanyi.pages.dev/tags/DP/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"}]},{"title":"AGC005C Tree Restoring","slug":"agc005_c","date":"2019-04-13T16:00:00.000Z","updated":"2019-04-13T16:00:00.000Z","comments":true,"path":"agc005_c/","link":"","permalink":"https://pufanyi.pages.dev/agc005_c/","excerpt":"青木君特别喜欢数列和树，他觉得它们是世界上最美妙的事物。有一天，神仙给了青木君一个长度为nnn的整数数列aaa。这让青木君特别想构造一棵美妙树。美妙树的每条边长度都为111。而且美妙树有一个最重要的性质：对于每一个点i(1≤i≤n)i(1\\le i\\le n)i(1≤i≤n)，在树中离它距离最远的点与它的距离应恰好等于aia_iai​。青木君想了想就秒掉了这题，他决定考考你：对于一个给定的序列，是否存在一棵美妙树？[1]2≤n≤100,1≤ai≤n−12\\le n\\le 100,1\\le a_i\\le n−12≤n≤100,1≤ai​≤n−1","text":"青木君特别喜欢数列和树，他觉得它们是世界上最美妙的事物。有一天，神仙给了青木君一个长度为 nnn 的整数数列 aaa。这让青木君特别想构造一棵美妙树。 美妙树的每条边长度都为 111。而且美妙树有一个最重要的性质：对于每一个点i(1≤i≤n)i(1\\le i\\le n)i(1≤i≤n)，在树中离它距离最远的点与它的距离应恰好等于aia_iai​。 青木君想了想就秒掉了这题，他决定考考你：对于一个给定的序列，是否存在一棵美妙树？[1]2≤n≤100,1≤ai≤n−12\\le n\\le 100,1\\le a_i\\le n−12≤n≤100,1≤ai​≤n−1 题解 首先根据这个序列我们可以很方便地求出直径。然后我们把树的直径上的点删掉，即 l,l−1,l−2,⋯ ,mid,mid+1,⋯ ,l−1,ll, l-1, l-2, \\cdots, mid, mid + 1, \\cdots, l - 1, ll,l−1,l−2,⋯,mid,mid+1,⋯,l−1,l，如果不存在那么一定是impossible。 然后还有就是不可能出现 aaa 比直径中点小的点，把它判掉就过了此题。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;set&gt;#include &lt;iostream&gt;using namespace std;// 读优略去const int maxn = 105;const int inf = 0x3f3f3f3f;int tong[maxn];int main()&#123; int n, zj = 0; read(n); for (int i = 1, a; i &lt;= n; ++i) &#123; read(a); tong[a]++; zj = max(a, zj); &#125; for (int i = 0; i &lt;= zj; ++i) &#123; int noww = max(i, zj - i); if (!tong[noww]) &#123; puts(\"Impossible\"); return 0; &#125; tong[noww]--; &#125; for (int i = 1; i &lt;= ((zj + 1) &gt;&gt; 1); ++i) &#123; if (tong[i]) &#123; puts(\"Impossible\"); return 0; &#125; &#125; puts(\"Possible\"); return 0;&#125; 翻译来自luogu ↩︎","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"}]},{"title":"ARC068E Snuke Line","slug":"arc068_c","date":"2019-04-13T16:00:00.000Z","updated":"2019-04-13T16:00:00.000Z","comments":true,"path":"arc068_c/","link":"","permalink":"https://pufanyi.pages.dev/arc068_c/","excerpt":"原题链接有一趟列车有M+1M+1M+1个车站，从000到MMM编号。有NNN种商品，第iii种只在编号[li,ri][l_i,r_i][li​,ri​]的车站出售。一辆列车有一个预设好的系数ddd，从000出发，只会在ddd的倍数车站停车。对于ddd从111到MMM的列车，求最多能买到多少种商品。1≤N≤3×105;1≤M≤105;1≤li≤ri≤M1\\le N \\le 3\\times 10^5;1\\le M\\le 10^5;1\\le l_i\\le r_i\\le M1≤N≤3×105;1≤M≤105;1≤li​≤ri​≤M。","text":"原题链接 有一趟列车有 M+1M+1M+1 个车站，从 000 到MMM编号。有 NNN 种商品，第 iii 种只在编号 [li,ri][l_i,r_i][li​,ri​] 的车站出售。一辆列车有一个预设好的系数 ddd，从000 出发，只会在 ddd 的倍数车站停车。对于 ddd 从111到 MMM 的列车，求最多能买到多少种商品。1≤N≤3×105;1≤M≤105;1≤li≤ri≤M1\\le N \\le 3\\times 10^5;1\\le M\\le 10^5;1\\le l_i\\le r_i\\le M1≤N≤3×105;1≤M≤105;1≤li​≤ri​≤M。 题解 我们考虑对于每个 ddd，如果区间[li,ri][l_i,r_i][li​,ri​] 有ri−li+1≥dr_i-l_i+1\\ge dri​−li​+1≥d，那么显然它一定会被覆盖，我们直接统计答案。我们考虑 ri−li+1&lt;dr_i-l_i+1&lt;dri​−li​+1&lt;d 的情况，显然它只会被覆盖一次，所以我们只要求这些区间与这些点的交点个数即可。于是我们由长度从小到大枚举区间，放入线段树中。对于每个 ddd 枚举点。由于点的总数是T(n)=∑i=1nni=O(nln⁡n)T(n)=\\sum_{i=1}^n\\frac{n}{i}=\\mathcal{O}(n\\ln n)T(n)=∑i=1n​in​=O(nlnn)，所以复杂度为O(nlog⁡2n)\\mathcal{O}(n\\log ^ 2 n)O(nlog2n)。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 300005;int n, m;#define lowbit(x) (x &amp; (-x))struct Tree&#123; int no[maxn]; inline void add(int pla, int x) &#123; for (; pla &lt;= m; pla += lowbit(pla)) no[pla] += x; &#125; inline void add_qj(int l, int r) &#123; add(l, 1); if (r &lt; m) add(r + 1, -1); &#125; inline int query(int pla) &#123; int ans = 0; for (; pla; pla -= lowbit(pla)) ans += no[pla]; return ans; &#125;&#125; tr;struct QJ&#123; int l, r; inline int len() &#123; return r - l + 1; &#125; friend bool operator &lt; (QJ a, QJ b) &#123; return a.r - a.l &lt; b.r - b.l; &#125;&#125; qj[maxn];int main()&#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", &amp;qj[i].l, &amp;qj[i].r); sort(qj + 1, qj + n + 1); int now = 1; for (int i = 1; i &lt;= m; ++i) &#123; while (now &lt;= n &amp;&amp; qj[now].len() &lt; i) &#123; tr.add_qj(qj[now].l, qj[now].r); now++; &#125; int ans = n - now + 1; for (int j = 0; j &lt;= m; j += i) ans += tr.query(j); printf(\"%d\\n\", ans); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"}]},{"title":"ARC080E Young Maids","slug":"arc080_c","date":"2019-04-13T16:00:00.000Z","updated":"2019-04-13T16:00:00.000Z","comments":true,"path":"arc080_c/","link":"","permalink":"https://pufanyi.pages.dev/arc080_c/","excerpt":"原题链接题意大概就是给你一个排列ppp，你每次可以找到ppp中相邻两个数并将其移至另一个初始为空的队列的开头，让最终ppp的字典序尽量小。过程大概就是这样：","text":"原题链接 题意大概就是给你一个排列 ppp，你每次可以找到ppp 中相邻两个数并将其移至另一个初始为空的队列的开头，让最终 ppp 的字典序尽量小。过程大概就是这样： 题解 由于字典序大小是从前往后决定的，所以我们考虑从前往后确定这个序列，也就是将题意中的过程倒着做。我们考虑在某一状态下，选择的两个数在原序列中是 pl,prp_l,p_rpl​,pr​，那么再次之前的选择中，不可能出现选择的数为pal,parp_{a_l},p_{a_r}pal​​,par​​ 使得 al&lt;l&lt;ara_l&lt;l&lt;a_ral​&lt;l&lt;ar​ 或al&lt;r&lt;ara_l&lt;r&lt;a_ral​&lt;r&lt;ar​。于是我们发现倒着考虑是，选择 pl,prp_l,p_rpl​,pr​ 时就是把序列分成了 [1,l−1],[l+1,r−1],[r+1,n][1,l-1],[l+1,r-1],[r+1,n][1,l−1],[l+1,r−1],[r+1,n] 这333段，这 333 段相互独立。我们考虑怎样的 &lt;l,r&gt;&lt;l,r&gt;&lt;l,r&gt; 是合法的。显然就是 [1,l−1],[l+1,r−1],[r+1,n][1,l-1],[l+1,r-1],[r+1,n][1,l−1],[l+1,r−1],[r+1,n] 长度均为偶数时（可能为空）。所以 lll 一定为奇数，rrr一定为偶数。我们可以维护出 ppp 中奇数位于偶数位的最小值，并用一个小根堆维护每一个 [l,r][l,r][l,r] 的最小值即可，每次选择后将 [l,r][l,r][l,r] 分成 333 段重新放入堆中。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;// 读入输出优化略去const int maxn = 200005;const int inf = 0x3f3f3f3f;int n;int xx[maxn]; // 题意中的 p#define ls(x) (x &lt;&lt; 1)#define rs(x) (x &lt;&lt; 1 | 1)struct Tree&#123; struct Node &#123; int jx, ox; // 奇数位的最小值与偶数位的最小值 &#125; no[maxn &lt;&lt; 2]; int k; inline int minn(int a, int b) &#123; if (!a || !b) return a | b; else return xx[a] &lt; xx[b] ? a : b; &#125; inline void push_up(int k) &#123; no[k].jx = minn(no[ls(k)].jx, no[rs(k)].jx); no[k].ox = minn(no[ls(k)].ox, no[rs(k)].ox); &#125; inline void build_tree(int n) &#123; for (k = 1; k &lt;= n; k &lt;&lt;= 1); for (int i = 1; i &lt;= n; ++i) &#123; if (i &amp; 1) no[i + k].jx = i; else no[i + k].ox = i; &#125; for (int i = k; i; --i) push_up(i); &#125; inline int query(int l, int r, int kk) &#123; int ans = 0; for (l += k - 1, r += k + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) &#123; if (~l &amp; 1) ans = minn(kk ? no[l ^ 1].jx : no[l ^ 1].ox, ans); if (r &amp; 1) ans = minn(kk ? no[r ^ 1].jx : no[r ^ 1].ox, ans); &#125; return ans; &#125;&#125; tr;struct QJ&#123; int l, r, ansl, ansr; // 现在可选区间为[l,r]，最优是选择 p[l] 和 p[r] friend bool operator &lt; (QJ a, QJ b) &#123; return xx[a.ansl] &gt; xx[b.ansl]; &#125; QJ (int l, int r) &#123; this-&gt;l = l; this-&gt;r = r; this-&gt;ansl = tr.query(l, r, 1); this-&gt;ansr = tr.query(ansl + 1, r, 0); &#125;&#125;;priority_queue&lt;QJ&gt; q;int main()&#123; read(n); for (int i = 1; i &lt;= n; ++i) read(xx[i]); tr.build_tree(n); q.push(QJ(1, n)); while (!q.empty()) &#123; QJ now = q.top(); q.pop(); writesp(xx[now.ansl]); writesp(xx[now.ansr]); if (now.ansl + 1 &lt; now.ansr - 1) q.push(QJ(now.ansl + 1, now.ansr - 1)); if (now.l &lt; now.ansl - 1) q.push(QJ(now.l, now.ansl - 1)); if (now.ansr + 1 &lt; now.r) q.push(QJ(now.ansr + 1, now.r)); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://pufanyi.pages.dev/tags/%E8%B4%AA%E5%BF%83/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"}]},{"title":"一道有趣的模拟赛题","slug":"20190409模拟赛T1","date":"2019-04-12T16:00:00.000Z","updated":"2019-04-12T16:00:00.000Z","comments":true,"path":"20190409模拟赛T1/","link":"","permalink":"https://pufanyi.pages.dev/20190409%E6%A8%A1%E6%8B%9F%E8%B5%9BT1/","excerpt":"一道有趣的题。","text":"一道有趣的题。3s+O2原题大概是 这道 。 看到模 333 显然是出题人精心构造的。于是我们打出一张组合数模 333 的表。好多 000 啊～于是我们考虑如何快速求出组合数不是 000 的位置。先说一下我考场上想到的 log⁡\\loglog 做法：我们考虑 lucas，对于组合数(mn)\\binom{m}{n}(nm​)，其实就是(MiNi)\\binom{M_i}{N_i}(Ni​Mi​​) 的乘积，其中 Mi,NiM_i,N_iMi​,Ni​ 表示 m,nm,nm,n 在333进制下的第 iii 位。我们发现 (MiNi)\\binom{M_i}{N_i}(Ni​Mi​​) 只要有一位是 000，最终结果就是000，所以我们只要枚举mmm 后枚举三进制下每一位是比 mmm 小的 nnn 就行了，这样每次找是 log⁡\\loglog 的，所以复杂度是 O(0 的个数×log⁡n)\\mathcal{O}(\\text{0 的个数}\\times\\log n)O(0 的个数 ×logn)，hdu 上过了，可惜模拟赛的时候被卡掉了……我们考虑 Lucas 是怎么递归下来的。对于每一层，我们只有 666 种方案使得 (mn)&gt;0\\binom{m}{n}&gt;0(nm​)&gt;0，我们直接反向递归上去，这样就能每次O(1)\\mathcal{O}(1)O(1) 搜出所有结果了。关于 000 的个数为什么这么多（打表可得 ），我们发现每次递归下去的时候，我们都可以把序列根据 mod 3\\bmod 3mod3 分成 333 段：0,1,20,1,20,1,2，而每一层只有 666 个组合数大于 000，这样我们有T(n)=6T(n/3)+O(n)\\mathcal{T}(n)=6\\mathcal{T}(n/3)+\\mathcal{O}(n)T(n)=6T(n/3)+O(n)。 下图截自出题人的 solution： 那就假装能过吧~~（反正比我的复杂度优）~~。我被卡的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100005;#define LL long long#define inf 0x3f3f3f3f#define put putchar('\\n')#define sqr(x) ((x)*(x))#define re register#define ret return puts(\"-1\"),0;inline char gc()&#123; static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;&#125;#define gc getcharinline int read()&#123; char c=getchar(); int tot=1; while ((c&lt;'0'|| c&gt;'9')&amp;&amp;c!='-') c=getchar(); if (c=='-') &#123; tot=-1; c=getchar(); &#125; int sum=0; while (c&gt;='0'&amp;&amp;c&lt;='9') &#123; sum=sum*10+c-'0'; c=getchar(); &#125; return sum*tot;&#125;inline void wr(int x)&#123; if (x&lt;0) &#123; putchar('-'); wr(-x); return; &#125; if(x&gt;=10)wr(x/10); putchar(x%10+'0');&#125;inline void wri(int x)&#123; wr(x); putchar(' ');&#125;int a[maxn], b[maxn];int C[3333][3333];inline int Lucas(int n, int m)&#123; if (!n) return 1; if (n &lt;= 3000 &amp;&amp; m &lt;= 3000) return C[m][n]; return Lucas(n / 3, m / 3) * C[m % 3][n % 3] % 3;&#125;int topp;int bit[20];int jbit[20];inline void pre(int x)&#123; memset(bit, 0, sizeof(bit)); memset(jbit, 0, sizeof(jbit)); topp = 0; if (!x) &#123; topp = 1; return; &#125; while (x) &#123; bit[++topp] = x % 3; x /= 3; &#125;&#125;inline int nxt()&#123; jbit[1]++; for (register int i = 1; i &lt; topp; ++i) &#123; if (jbit[i] &lt;= bit[i]) break; jbit[i] = 0; jbit[i + 1]++; &#125; if (jbit[topp] &gt; bit[topp]) return -1; register int ans = 0; for (register int i = topp; i; --i) &#123; ans *= 3; ans += jbit[i]; &#125; return ans;&#125;inline void solve()&#123; int cnt = 0; register int n = read(); for (register int i = 0; i &lt; n; ++i) a[i] = read(); for (register int i = 0; i &lt; n; ++i) b[i] = read(); for (register int i = 0, c, j; i &lt; (n &lt;&lt; 1) - 1; ++i) &#123; c = 0; pre(i); for (j = 0; ~j &amp;&amp; j &lt; n; j = nxt()) &#123; cnt++; if (i - j &lt; n &amp;&amp; a[j] &amp;&amp; b[i - j]) (c += Lucas(j, i) * a[j] * b[i - j]) %= 3; &#125; wri(c); &#125; puts(\"\");&#125;int main()&#123; freopen(\"cal.in\", \"r\", stdin); freopen(\"cal.out\", \"w\", stdout); for (register int i = 0; i &lt;= 3000; ++i) &#123; C[i][0] = 1; for (register int j = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % 3; &#125; register int T = read(); while (T--) solve(); fclose(stdin); fclose(stdout); return 0;&#125;正解：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;inline char gc()&#123; static const int L = 23333; static char sxd[L], *sss = sxd, *ttt = sxd; if (sss == ttt) &#123; ttt = (sss = sxd) + fread(sxd, 1, L, stdin); if (sss == ttt) return EOF; &#125; return *sss++;&#125;#define dd c = gc()template &lt;class T&gt;inline bool read(T&amp; x)&#123; x = 0; register char dd; register bool flag = false; for (; !isdigit(c); dd) &#123; if(c == '-') flag = true; else if(c == EOF) return false; &#125; for (; isdigit(c); dd) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag) x = -x; return true;&#125;#undef ddtemplate &lt;class T&gt;inline void write(T x)&#123; if(!x) &#123; putchar('0'); return; &#125; if (x &lt; 0) putchar('-'), x = -x; int buf[20]; *buf = 0; while (x) &#123; buf[++(*buf)] = x % 10; x /= 10; &#125; while (*buf) putchar(buf[(*buf)--] | 48);&#125;template &lt;class T&gt;inline void writesp(T x)&#123; write(x); putchar('');&#125;const int maxn = 100005;int a[maxn], b[maxn], c[maxn &lt;&lt; 1], n;const int x[] = &#123;0, 0, 1, 0, 1, 2&#125;;const int y[] = &#123;0, 1, 1, 2, 2, 2&#125;;const int z[] = &#123;1, 1, 1, 1, 2, 1&#125;;inline void dfs(const register int xx, const register int yy, const register int zz)&#123; for (register int i = 0, xxx, yyy; i &lt; 6; ++i) &#123; xxx = xx + x[i], yyy = yy + y[i]; if (yyy - xxx &lt; n &amp;&amp; xxx &lt; n) c[yyy] += zz * z[i] * a[xxx] * b[yyy - xxx]; if ((xxx || yyy) &amp;&amp; (xxx * 3 &lt; n) &amp;&amp; (yyy * 3 &lt; ((n &lt;&lt; 1) - 1)) &amp;&amp; ((yyy - xxx) * 3 &lt; n)) dfs(xxx * 3, yyy * 3, zz * z[i]); &#125;&#125;int main()&#123; freopen(\"cal.in\", \"r\", stdin); freopen(\"cal.out\", \"w\", stdout); int T; read(T); while (T--) &#123; memset(c, 0, sizeof(c)); read(n); for (register int i = 0; i &lt; n; ++i) read(a[i]); for (register int i = 0; i &lt; n; ++i) read(b[i]); dfs(0, 0, 1); for (register int i = 0; i &lt; (n &lt;&lt; 1) - 1; ++i) writesp(c[i] % 3); puts(\"\"); &#125; fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://pufanyi.pages.dev/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"数学","slug":"数学","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E5%AD%A6/"},{"name":"Lucas","slug":"Lucas","permalink":"https://pufanyi.pages.dev/tags/Lucas/"}]},{"title":"北京省选集训 2019 图的难题","slug":"[北京省选集训2019]图的难题","date":"2019-04-12T16:00:00.000Z","updated":"2019-04-12T16:00:00.000Z","comments":true,"path":"[北京省选集训2019]图的难题/","link":"","permalink":"https://pufanyi.pages.dev/[%E5%8C%97%E4%BA%AC%E7%9C%81%E9%80%89%E9%9B%86%E8%AE%AD2019]%E5%9B%BE%E7%9A%84%E9%9A%BE%E9%A2%98/","excerpt":"题目大意给定一张无向图，要求把边染成黑白两色，要求所有白色边构成的子图没有环，且所有黑色边构成的子图没有环。多组询问，输出是否有解。n≤500,m≤2n,T≤10n\\le 500,m\\le 2n,T\\le 10n≤500,m≤2n,T≤10。","text":"题目大意 给定一张无向图，要求把边染成黑白两色，要求所有白色边构成的子图没有环，且所有黑色边构成的子图没有环。多组询问，输出是否有解。n≤500,m≤2n,T≤10n\\le 500,m\\le 2n,T\\le 10n≤500,m≤2n,T≤10。 题解 显然，由白边构成的图是一个森林，黑边构成的图也是个森林。显然森林所有的导出子图也是森林。那么显然图是一个森林的充要条件为其最大导出子图的 ∣E∣−∣V∣≤−1|E|-|V|\\le -1∣E∣−∣V∣≤−1。 我们考虑原问题，如果一张图 GGG 要有解，那么 GGG 的所有导出子图都要有解，且该图的 ∣E∣≤2(∣V∣−1)|E|\\le 2(|V|-1)∣E∣≤2(∣V∣−1)，也就是让黑白两种颜色都能是一片森林。 有了这个 有理有据的 性质，我们就把问题转化成了：对于图 GGG，定义ρG=∣E∣−2∣V∣+2\\rho_G=|E|-2|V|+2ρG​=∣E∣−2∣V∣+2，求出一张图所有导出子图ρ?\\rho?ρ? 的最大值。我们考虑网络流，S?S?S?向所有原图的边（看作点）连边，容量为 1?1?1?，原图中每条边向与之相连的点连边，容量∞?\\infty?∞?，原图中点向T?T?T? 连边，容量为 2?2?2?。 考虑最小割，把割 S→ 原图中边 S\\to \\text{原图中边}S→ 原图中边 的边看成是不选该边，把 原图 中点 →T 原图中点 \\to T原 图中 点→T的边看成是选该点，这样 ρG=∣E∣− 不被选的边 + 被选的点 +2=∣E∣− 最小割 +2\\rho_G=|E|-\\text{不被选的边}+\\text{被选的点}+2=|E|-\\text{最小割}+2ρG​=∣E∣− 不被选的边 + 被选的点 +2=∣E∣− 最小割 +2。 然后发现输出 &quot;NO&quot;×∞\\times \\infty×∞，因为它把所有边全割了，这样其实就是选了一个空集，ρ=2\\rho=2ρ=2，GG。 我们强制选一个点，枚举一个点强行割掉，发现这样割使用了 2?2?2?，正好答案就是ρG=∣E∣− 最小割 ?\\rho_G=|E|-\\text{最小割}?ρG​=∣E∣− 最小割 ?。 直接判断正负即可。复杂度 O( 能过 )?\\mathcal{O}(\\text{能过})?O( 能过)?。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;bits/stdc++.h&gt;using namespace std;// 读入输出优化直接删了const int maxN = 505;const int maxn = maxN &lt;&lt; 2;const int maxm = maxn &lt;&lt; 3;const int inf = 0x3f3f3f3f;struct Edge&#123; int to, nxt, cap;&#125; e[maxm &lt;&lt; 1];int first[maxn], fb[maxn];int cnt;inline void add_edge(int from, int to, int cap)&#123; e[++cnt].nxt = fb[from]; fb[from] = cnt; e[cnt].to = to; e[cnt].cap = cap; e[++cnt].nxt = fb[to]; fb[to] = cnt; e[cnt].to = from; e[cnt].cap = 0;&#125;int n, m, S, T;struct EDGE&#123; int from, to;&#125; ee[maxn];inline void jiantu(int k)&#123; memset(fb, 0xff, sizeof(fb)); cnt = -1; for (int i = 1; i &lt;= n; ++i) if (i != k) add_edge(i, T, 2); for (int i = 1; i &lt;= m; ++i) &#123; add_edge(i + n, ee[i].from, inf); add_edge(i + n, ee[i].to, inf); add_edge(S, i + n, 1); &#125;&#125;int dep[maxn];inline bool bfs()&#123; memset(dep, 0x3f, sizeof(dep)); for (int i = S; i &lt;= T; ++i) first[i] = fb[i]; queue&lt;int&gt; q; q.push(S); dep[S] = 0; while (!q.empty()) &#123; int now = q.front(); q.pop(); for (int i = first[now]; ~i; i = e[i].nxt) &#123; int to = e[i].to; if (dep[to] &gt;= inf &amp;&amp; e[i].cap &gt; 0) &#123; q.push(to); dep[to] = dep[now] + 1; &#125; &#125; &#125; return dep[T] &lt; inf;&#125;inline int dfs(int now, int limit)&#123; if (now == T || !limit) return limit; int flow = 0; for (int i = first[now]; ~i; i = e[i].nxt) &#123; first[now] = i; int to = e[i].to, f; if (dep[to] == dep[now] + 1 &amp;&amp; (f = dfs(to, min(limit, e[i].cap)))) &#123; e[i].cap -= f; e[i ^ 1].cap += f; limit -= f; flow += f; if (!limit) break; &#125; &#125; return flow;&#125;inline int Dinic()&#123; int ans = 0; while (bfs()) ans += dfs(S, inf); return ans;&#125;inline void solve()&#123; read(n), read(m); S = 0; T = n + m + 1; for (int i = 1; i &lt;= m; ++i) read(ee[i].from), read(ee[i].to); int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; jiantu(i); ans = max(ans, m - Dinic()); &#125; puts(ans &gt; 0 ? \"No\" : \"Yes\");&#125;int main()&#123; int TT; read(TT); while (TT--) solve(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://pufanyi.pages.dev/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"图论","slug":"图论","permalink":"https://pufanyi.pages.dev/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"WF2019A Azulejos","slug":"WF2019A","date":"2019-04-04T16:00:00.000Z","updated":"2019-04-04T16:00:00.000Z","comments":true,"path":"WF2019A/","link":"","permalink":"https://pufanyi.pages.dev/WF2019A/","excerpt":"一道有趣的贪心题。","text":"一道有趣的贪心题。 题目大意 给你两种瓷砖 a,ba,ba,b，每种瓷砖有nnn 块，每块瓷砖有两个属性：高度 hhh 和价值 ppp。 现在要求你把这些瓷砖重新排成两行（2×n2\\times n2×n）。前一行放瓷砖 bbb，后一行放瓷砖aaa。 要求从左到右 ppp 递增（单调不减），对于任意一个位置 iii，后面的瓷砖要比前面的瓷砖高。 求一种方案或输出无解。n≤5×105n\\le 5\\times 10^5n≤5×105 题解 对于一段 ppp 相同的区间，我们可以将里面的瓷砖随意调换。考虑如何贪心。我们发现有两种不同的情况，我们的目的不同：此时我们是想让匹配完 aaa 中p=2p=2p=2情况后，bbb中剩余的 p=3p=3p=3 的瓷砖的 hhh 尽量小。我们可以将 aaa 中p=2p=2p=2的每块瓷砖都找到 bbb 中一个恰好比它小的瓷砖进行匹配。此时我们是想让匹配完 bbb 中p=2p=2p=2的情况后 aaa 中剩余的 p=3p=3p=3 的瓷砖的 hhh 尽量大。我们可以将 bbb 中p=2p=2p=2的每块瓷砖都找到 aaa 中一个恰好比它大的瓷砖进行匹配。我们维护目前第 iii 个位置可以填哪些数，如果 aaa 中可填的数比 bbb 中少，那么是情况一，否则就是情况二。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 500005;struct sxd&#123; int p, h, id; friend bool operator &lt; (sxd a, sxd b) &#123; return a.p &lt; b.p; &#125;&#125;;struct pii&#123; int x, y; friend bool operator &lt; (pii a, pii b) &#123; return a.x &lt; b.x; &#125; pii (int x = 0, int y = 0) &#123; this-&gt;x = x, this-&gt;y = y; &#125;&#125;;multiset&lt;pii&gt; sta, stb;int n;sxd aa[maxn];sxd bb[maxn];int ansa[maxn];int ansb[maxn];int main()&#123; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;aa[i].p); aa[i].id = i; &#125; for(int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;aa[i].h); for(int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;bb[i].p); bb[i].id = i; &#125; for(int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;bb[i].h); sort(aa + 1, aa + n + 1); sort(bb + 1, bb + n + 1); for(int i = 1, nowa = 0, nowb = 0; i &lt;= n; ++i) &#123; if(sta.empty()) &#123; nowa++; sta.insert(pii(aa[nowa].h, aa[nowa].id)); while(nowa + 1 &lt;= n &amp;&amp; aa[nowa].p == aa[nowa + 1].p) &#123; nowa++; sta.insert(pii(aa[nowa].h, aa[nowa].id)); &#125; &#125; if(stb.empty()) &#123; nowb++; stb.insert(pii(bb[nowb].h, bb[nowb].id)); while(nowb + 1 &lt;= n &amp;&amp; bb[nowb].p == bb[nowb + 1].p) &#123; nowb++; stb.insert(pii(bb[nowb].h, bb[nowb].id)); &#125; &#125; if(sta.size() &lt; stb.size()) &#123; set&lt;pii&gt;::iterator it = stb.lower_bound(pii((sta.rbegin())-&gt;x, 0)); if(it == stb.begin()) &#123; puts(\"impossible\"); return 0; &#125; --it; ansa[i] = (sta.rbegin())-&gt;y; ansb[i] = it-&gt;y; sta.erase(--sta.end()); stb.erase(it); &#125; else &#123; set&lt;pii&gt;::iterator it = sta.upper_bound(pii((stb.begin())-&gt;x, 0)); if(it == sta.end()) &#123; puts(\"impossible\"); return 0; &#125; ansa[i] = it-&gt;y; ansb[i] = (stb.begin())-&gt;y; sta.erase(it); stb.erase(stb.begin()); &#125; &#125; for(int i = 1; i &lt;= n; ++i) printf(\"%d\", ansa[i]); puts(\"\"); for(int i = 1; i &lt;= n; ++i) printf(\"%d \", ansb[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://pufanyi.pages.dev/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"AGC012D Colorful Balls","slug":"agc012_d","date":"2019-03-30T16:00:00.000Z","updated":"2019-03-30T16:00:00.000Z","comments":true,"path":"agc012_d/","link":"","permalink":"https://pufanyi.pages.dev/agc012_d/","excerpt":"原题链接n(n≤105)n(n\\le 10^5)n(n≤105)个球排成一排，第iii个球有颜色ci(ci≤n)c_i(c_i\\le n)ci​(ci​≤n)和重量wi(wi≤109)w_i(w_i\\le 10^9)wi​(wi​≤109)。 Snuke每次可以选择两个颜色相同，且重量之和不超过xxx的球，交换他们的位置。 Snuke每次可以选择两个颜色不同，且重量之和不超过yyy的球，交换他们的位置。 问可以得到多少种不同的颜色序列。1≤x,y≤1091\\le x,y\\le 10^91≤x,y≤109，答案对109+710^9+7109+7取模。[1]","text":"原题链接 n(n≤105)n(n\\le 10^5)n(n≤105) 个球排成一排，第 iii 个球有颜色 ci(ci≤n)c_i(c_i\\le n)ci​(ci​≤n) 和重量 wi(wi≤109)w_i(w_i\\le 10^9)wi​(wi​≤109)。 Snuke 每次可以选择两个颜色相同，且重量之和不超过xxx 的球，交换他们的位置。 Snuke 每次可以选择两个颜色不同，且重量之和不超过 yyy 的球，交换他们的位置。 问可以得到多少种不同的颜色序列。1≤x,y≤1091\\le x,y\\le 10^91≤x,y≤109，答案对 109+710^9+7109+7 取模。[1] 题解 我们考虑什么时候连个球能进行交换。显然如果有三个球 a,b,ca,b,ca,b,c，如果aaa 与bbb能交换，bbb与 ccc 能交换，那 aaa 与ccc一定能通过 bbb 的“媒介”交换（aaa先于 bbb 交换，bbb与 ccc 交换，aaa与 bbb 交换）。于是我们可以把 a,b,ca,b,ca,b,c 缩在同一个连通块里。由于不同颜色与相同颜色交换条件是不一样的，我们先考虑相同颜色。显然只需要用最小值做“媒介”即可。然后我们考虑跨颜色交换。我们发现只需要用全局最小值做“媒介”，也就是说对于某个点，先通过该颜色最小值换到全局最小值，再通过全局最小值换到其他点。如果与全局最小值颜色相同，那我们就只能用次小值做媒介。这样我们只需要记录某种颜色的最小值、全局最小值、全局次小值即可。然后我们不难发现含有不同颜色的连通块只有一个，那就是全局最小值所在的连通块。而只有一种颜色的连通块对答案没有影响。于是我们只考虑最小值所在的连通块。首先我们找到全局最小值、全局次小值与每种颜色的最小值。如果他们都不能交换，那显然是凉了（答案为 111）。我们对每种颜色数出能与该种颜色最小值交换的点数，然后用每种连通块的最小值与全局最小值（全局次小值）比较，求出这个联通块。我们发现就是求这个联通块排列方案数，其实就是可重集合排列。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn = 1000005;const int inf = 0x3f3f3f3f;const int mod = 1000000007;int n, A, B;int fac[maxn], inv[maxn];int c[maxn], w[maxn], minci[maxn];int Gs[maxn];inline int pow(int a, int b)&#123; int ans = 1; for(; b; b &gt;&gt;= 1, a = (LL) a * a % mod) if(b &amp; 1) ans = (LL) ans * a % mod; return ans;&#125;inline int C(int n, int m)&#123; if(!n) return 1; if(m &lt; n) return 0; return (LL) fac[m] * (LL) inv[m - n] % mod * (LL) inv[n] % mod;&#125;int main()&#123; scanf(\"%d%d%d\", &amp;n, &amp;A, &amp;B); memset(minci, 0x3f, sizeof(minci)); for(int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", &amp;c[i], &amp;w[i]); minci[c[i]] = min(minci[c[i]], w[i]); &#125; int minn = 0, minnn = 0; for(int i = 1; i &lt;= n; ++i) &#123; if(minci[i] &lt; minci[minn]) &#123; minnn = minn; minn = i; &#125; else if(minci[i] &lt; minci[minnn]) minnn = i; &#125; int gss = 0; for(int i = 1; i &lt;= n; ++i) &#123; if(w[i] + minci[c[i]] &lt;= A) w[i] = minci[c[i]]; if(c[i] == minn &amp;&amp; minci[minnn] + w[i] &lt;= B) &#123; Gs[c[i]]++; gss++; &#125; if(c[i] != minn &amp;&amp; minci[minn] + w[i] &lt;= B) &#123; Gs[c[i]]++; gss++; &#125; &#125; int ans = 1; fac[0] = 1; for(int i = 1; i &lt;= n; ++i) fac[i] = (LL) i * fac[i - 1] % mod; inv[n] = pow(fac[n], mod - 2); for(int i = n - 1; ~i; --i) inv[i] = (LL) inv[i + 1] * (i + 1) % mod; for(int i = 1; i &lt;= n; ++i) &#123; if(Gs[i]) &#123; ans = (LL) ans * (LL) C(Gs[i], gss) % mod; gss -= Gs[i]; &#125; &#125; printf(\"%d\\n\", ans); return 0;&#125; 翻译来自luogu，有删改 ↩︎","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E5%AD%A6/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"}]},{"title":"AGC013C Ants on a Circle","slug":"agc013_c","date":"2019-03-30T16:00:00.000Z","updated":"2019-03-30T16:00:00.000Z","comments":true,"path":"agc013_c/","link":"","permalink":"https://pufanyi.pages.dev/agc013_c/","excerpt":"题目链接有一个长度为LLL的圆环, 上面有nnn个蚂蚁, 位置分别为xix_ixi​，运动方向为did_idi​，111表示顺时针，222表示逆时针。每只蚂蚁将会同时开始以单位速度运动，如果两只蚂蚁相遇，那么它们会改变自己的方向继续运动。求TTT秒之后每只蚂蚁的位置。[1]1≤n≤105;1≤L,T≤109;0≤x1&lt;x2&lt;⋯&lt;xn≤L−11\\le n\\le 10^5;1\\le L,T\\le 10^9;0\\le x_1&lt;x_2&lt;\\cdots&lt;x_n\\le L - 11≤n≤105;1≤L,T≤109;0≤x1​&lt;x2​&lt;⋯&lt;xn​≤L−1。","text":"题目链接 有一个长度为 LLL 的圆环, 上面有 nnn 个蚂蚁, 位置分别为 xix_ixi​，运动方向为did_idi​，111 表示顺时针，222表示逆时针。每只蚂蚁将会同时开始以单位速度运动，如果两只蚂蚁相遇，那么它们会改变自己的方向继续运动。求 TTT 秒之后每只蚂蚁的位置。[1]1≤n≤105;1≤L,T≤109;0≤x1&lt;x2&lt;⋯&lt;xn≤L−11\\le n\\le 10^5;1\\le L,T\\le 10^9;0\\le x_1&lt;x_2&lt;\\cdots&lt;x_n\\le L - 11≤n≤105;1≤L,T≤109;0≤x1​&lt;x2​&lt;⋯&lt;xn​≤L−1。 题解 显然我们先来看如果没有标号，那么可以把两只蚂蚁的“掉头”无视掉，这样我们就已经知道了蚂蚁的位置。不难发现每只蚂蚁的相对位置不变，即它左边和右边的蚂蚁是不会变的。于是我们只要确定其中一只蚂蚁即可。我们可以记录一下坐标最小的蚂蚁是那只，即越过 000 坐标的蚂蚁有几只，这样就确定了一只蚂蚁。 代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;int n, t, l;int hou[maxn];int main()&#123; scanf(\"%d%d%d\", &amp;n, &amp;l, &amp;t); int fromm = 0; for (int i = 1, x, fx; i &lt;= n; ++i) &#123; scanf(\"%d%d\", &amp;x, &amp;fx); if (fx == 2) &#123; hou[i] = x - t; (fromm -= (l - hou[i] - 1) / l) %= n; ((hou[i] %= l) += l) %= l; &#125; else &#123; hou[i] = x + t; (fromm += hou[i] / l) %= n; hou[i] %= l; &#125; &#125; (fromm += n) %= n; sort(hou + 1, hou + n + 1); for (int i = fromm + 1; i &lt;= n; ++i) printf(\"%d\\n\", hou[i]); for (int i = 1; i &lt;= fromm; ++i) printf(\"%d\\n\", hou[i]); return 0;&#125; 翻译来自luogu。 ↩︎","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"}]},{"title":"AGC014D Black and White Tree","slug":"agc014_d","date":"2019-03-30T16:00:00.000Z","updated":"2019-03-30T16:00:00.000Z","comments":true,"path":"agc014_d/","link":"","permalink":"https://pufanyi.pages.dev/agc014_d/","excerpt":"题目链接给出一颗n(n≤105)n(n\\le 10^5)n(n≤105)个节点组成的树，每个节点都可以被染成白色或者黑色。有高桥（先手）和青木（后手）两个人，高桥可以把任意某个点染成白色，青木则可以把任意一个点染成黑色，每个点只可染色一次。当所有点都被染色后，只执行一次执行以下操作：把所有青木染成黑色的节点的相邻的白点感染成“次黑色”；次黑色不能继续感染白点。若操作完毕后仍还有白点存在，即高桥（先手）胜，反之则青木（后手）胜。现在给出这棵树，问当前此树是先手必胜or后手必胜。[1]","text":"题目链接 给出一颗 n(n≤105)n(n\\le 10^5)n(n≤105) 个节点组成的树，每个节点都可以被染成白色或者黑色。有高桥（先手）和青木（后手）两个人，高桥可以把任意某个点染成白色，青木则可以把任意一个点染成黑色，每个点只可染色一次。当所有点都被染色后，只执行一次执行以下操作：把所有青木染成黑色的节点的相邻的白点感染成“次黑色”；次黑色不能继续感染白点。若操作完毕后仍还有白点存在，即高桥（先手）胜，反之则青木（后手）胜。现在给出这棵树，问当前此树是先手必胜 or 后手必胜。[1] 题解 问题显然就是青木不能让任意一个白点旁边没有黑点。如果该树有完美匹配，那么显然是后手赢。因为不管先手选什么，后手只要选先手对应的点就可以。于是我们就来考虑没有完美匹配的情况。最特殊的应该是叶子节点，因为只有一个点与它相邻。如果叶子节点是白点，那么叶子节点的“父亲”必须是黑点；而如果叶子是黑点，那么叶子节点的“父亲”必须是白点。这里的“父亲”是指它相邻的点。我们考虑先手先任意一个叶子节点的“父亲”，那后手必须跟着选叶子。然后我们发现我们可以把这两个点删掉，并不会影响结果。于是我们可以每次这样删下去。由于这棵树没有完美匹配，最后肯定是一些零散的点。而此时先手选择其中的任意一个点即可。我们考虑如何求出是否存在完美匹配。我们可以考虑直接模拟上面的游戏过程，因为如果先手按这个策略没有赢，那么肯定没有完美匹配。我们任选一个节点为根进行 dfs，将儿子处理完后如果这个点还没被删，那么把它就已经变成叶子节点了，把它和它父亲一起删掉。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;struct Edge&#123; int to, nxt;&#125; e[maxn &lt;&lt; 1];int first[maxn];inline void add_edge(int from, int to)&#123; static int cnt = 0; e[++cnt].nxt = first[from]; first[from] = cnt; e[cnt].to = to; e[++cnt].nxt = first[to]; first[to] = cnt; e[cnt].to = from;&#125;bool shan[maxn];int n;inline void dfs(int now, int fa)&#123; for(int i = first[now]; i; i = e[i].nxt) &#123; register int to = e[i].to; if(to != fa) dfs(to, now); &#125; if(!shan[now]) &#123; if(shan[fa]) &#123; puts(\"First\"); exit(0); &#125; shan[now] = shan[fa] = true; &#125;&#125;int main()&#123; shan[0] = true; scanf(\"%d\", &amp;n); for(int i = 1, f, t; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;f, &amp;t); add_edge(f, t); &#125; dfs(1, 0); puts(\"Second\"); return 0;&#125; 翻译来自luogu。 ↩︎","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"},{"name":"博弈","slug":"博弈","permalink":"https://pufanyi.pages.dev/tags/%E5%8D%9A%E5%BC%88/"}]},{"title":"ARC078F Mole and Abandoned Mine","slug":"arc078_d","date":"2019-03-30T16:00:00.000Z","updated":"2019-03-30T16:00:00.000Z","comments":true,"path":"arc078_d/","link":"","permalink":"https://pufanyi.pages.dev/arc078_d/","excerpt":"题目链接给一个n(n≤15)n(n\\le 15)n(n≤15)个点mmm条边的无向连通图（不存在自环或重边），每条边有一个边权，要求割掉若干条边，使111到nnn只有111条路径（不经过重复点），问割掉的边权和最小是多少。[1]","text":"题目链接 给一个 n(n≤15)n(n\\le 15)n(n≤15) 个点 mmm 条边的无向连通图（不存在自环或重边），每条边有一个边权，要求割掉若干条边，使 111 到nnn只有 111 条路径（不经过重复点），问割掉的边权和最小是多少。[1] 题解 问题其实就是需要保留的边权和最大。问题是有关点集 + 路径的，不难想到状态：fi,j​f_{i,j}​fi,j​​表示遍历了集合 i​i​i​，这条唯一的路径的已经是从1​1​1​ 到j​j​j​的答案。我们考虑选择路径的形状，大概应该应该是这样的：就是 1∼n1\\sim n1∼n 的一条，然后中间许多分叉，连向一些连通块，而这些联通块中所有的边都连上。于是我们考虑转移。当 j=1j=1j=1 时，fi,j=Eif_{i,j}=E_ifi,j​=Ei​，其中 EiE_iEi​ 表示 i​i​i​ 集合中所有边的权值和。可以连下一个链上的点：fi∖{j},k+dk,j→fi,jf_{i\\setminus \\{j\\},k}+d_{k,j}\\to f_{i,j}fi∖{j},k​+dk,j​→fi,j​，就是在 kkk 后面新增一个点 jjj，当然这个转移的时候dk,jd_{k,j}dk,j​ 应大于 000。 还可以从 jjj 向一个伸出去一个连通块：fi∖k,j+Ek⋃{j}→fi,jf_{i\\setminus k,j}+E_{k\\bigcup\\{j\\}}\\to f_{i,j}fi∖k,j​+Ek⋃{j}​→fi,j​，当然其中 j∉k​j\\notin k​j∈/​k​。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;bitset&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn = 15;const int inf = 0x3f3f3f3f;int mmap[maxn][maxn];LL in[1 &lt;&lt; maxn];LL dp[1 &lt;&lt; maxn][maxn];int n, m;int main()&#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0, f, t, d; i &lt; m; ++i) &#123; scanf(\"%d%d%d\", &amp;f, &amp;t, &amp;d); mmap[t - 1][f - 1] = mmap[f - 1][t - 1] = d; &#125; for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) for (int j = 0; j &lt; n; ++j) if (i &amp; (1 &lt;&lt; j)) for (int k = j + 1; k &lt; n; ++k) if (i &amp; (1 &lt;&lt; k)) in[i] += mmap[j][k]; for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) for (int j = 0; j &lt; n; ++j) dp[i][j] = -inf; for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (i &amp; (1 &lt;&lt; j)) &#123; if (!j) dp[i][j] = in[i]; else &#123; for (int k = 0; k &lt; n; ++k) if (j != k &amp;&amp; (i &amp; (1 &lt;&lt; k)) &amp;&amp; mmap[k][j]) dp[i][j] = max(dp[i][j], dp[i ^ (1 &lt;&lt; j)][k] + mmap[k][j]); for (int tmp = (i ^ (1 &lt;&lt; j)), k = tmp; k; k = (k - 1) &amp; tmp) dp[i][j] = max(dp[i][j], dp[i ^ k][j] + in[k | (1 &lt;&lt; j)]); &#125; &#125; &#125; &#125; printf(\"%lld\\n\", in[(1 &lt;&lt; n) - 1] - dp[(1 &lt;&lt; n) - 1][n - 1]); return 0;&#125; 翻译来自luogu。 ↩︎","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://pufanyi.pages.dev/tags/DP/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"}]},{"title":"CodeForces 1137F Matches Are Not a Child's Play","slug":"CF1137F","date":"2019-03-26T16:00:00.000Z","updated":"2019-03-26T16:00:00.000Z","comments":true,"path":"CF1137F/","link":"","permalink":"https://pufanyi.pages.dev/CF1137F/","excerpt":"题目大意我们定义一棵树的删除序列为：每一次将树中编号最小的叶子删掉，将该节点编号加入到当前序列的最末端，最后只剩下一个节点时将该节点的编号加入到结尾。例如对于上图中的树，它的删除序列为：2 4 3 1 5。现在给出一棵nnn个节点的树，有mmm次操作：up v：将vvv号节点的编号变为当前所有节点编号的max⁡+1\\max + 1max+1；when v：查询vvv在当前树的删除序列中是第几号元素；compare u v：查询uuu和vvv在当前树的删除序列中谁更靠前。","text":"题目大意 我们定义一棵树的删除序列为：每一次将树中编号最小的叶子删掉，将该节点编号加入到当前序列的最末端，最后只剩下一个节点时将该节点的编号加入到结尾。例如对于上图中的树，它的删除序列为：2 4 3 1 5。现在给出一棵 nnn 个节点的树，有 mmm 次操作：up v：将 vvv 号节点的编号变为当前所有节点编号的 max⁡+1\\max + 1max+1；when v：查询vvv 在当前树的删除序列中是第几号元素；compare u v：查询 uuu 和vvv在当前树的删除序列中谁更靠前。 输入格式 第一行两个正整数 n,q(1≤n,q≤200000)n,q(1 \\leq n , q \\leq 200000)n,q(1≤n,q≤200000) 表示树的点数和操作数。接下来 n−1n-1n−1 行每行 222 个正整数 u,v(1≤u,v≤n)u,v(1 \\leq u,v \\leq n)u,v(1≤u,v≤n) 表示树上的一条边。接下来 qqq 行每行描述一个操作。 输出格式 每一个询问输出一行。对于 when v 询问，输出一个正整数表示 vvv 是当前删除序列的哪一个元素。对于 compare u v 询问，如果 uuu 在删除序列中更靠前则输出 uuu，否则输出vvv。[1] 题解 显然在任意时刻最大的那个节点一定是在最后被删的。于是我们考虑 up 操作带来的影响。假设 up 了xxx，上一次（up前）最大的那个点是 yyy。 我们发现最后删着删着一定只剩下了 xxx 到yyy路径上的这几个点。然后从 yyy 开始一个一个往 xxx 那边删。于是 y∼xy\\sim xy∼x 这条链上的点移到了删除序列的末尾。我们可以把 y∼xy\\sim xy∼x 看成一个缩起来的点，我们发现其它点的相对位置不变。接下来的思路感觉跟 这题 很像。我们考虑用 LCT 维护这棵树，LCT中的每棵 splay 表示一段连续的删除区间。开始时根当然是最大的。样例大概是这样一幅图：graph g {2[color=\"red\"]; 4[color=\"green\"]; 3[color=\"green\"]; 1[color=\"green\"]; 5[color=\"green\"]; 5--1--3--4[color=\"green\"]; 1--2; }删除序列应该是 2 4 3 1 5。 根当然就是最大的那个点。由于一个 splay 是连续删的。所以我们给每个 splay 一个标号（具体到实现就是给 splay 上每个点染色，可以参考下面的代码），把它放在树状数组上，即在该 splay 的color上加上该 splay 的size。12345678910111213141516171819inline void dfs(int now)&#123; col[now] = now, siz[now] = 1; for(int i = first[now]; i; i = e[i].nxt) &#123; register int to = e[i].to; if(to != fa[now]) &#123; fa[to] = now; dfs(to); if(col[to] &gt; col[now]) // 如果它后代有比它大的节点，那么一定会影响他它 &#123; col[now] = col[to]; s[now][1] = to; siz[now] = siz[to] + 1; &#125; &#125; &#125; tr.add(col[now], 1); // 树状数组在该 color 上加 1&#125; 我们考虑查询，就是该点所在 splay 之前的所有点数加上该 splay 上所有该结点后面的点数。大概就是 树状数组.query(col[x] - 1) + splay.query(在 x 之前的节点个数)。当然也可以写成：12345inline int query(int x)&#123; splay(x); return tr.query(col[x]) - siz[s[x][0]];&#125;最后考虑修改。我们发现修改就是 make_root，当然因为make_root 里已经有 access 了。至于轻重链切换的时候，只要在树状数组里把原有的 splay 删掉，新增的 splay 加上就可以了，具体可以见代码。12345678910111213141516171819202122inline void access(int x)&#123; for(int y = 0; x; x = fa[y = x]) &#123; splay(x); s[x][1] = 0; // 假装它右边什么都没有，这样就可以把需要新增的 splay 整个提取出来了 push_up(x); tr.add(col[x], -siz[x]); tr.add(nowcol, siz[x]); s[x][1] = y; // 然后在接上 y push_up(x); &#125;&#125;inline void make_root(int x)&#123; nowcol++; access(x); splay(x); fan(x); // 翻转 col[x] = nowcol; // 最后再把整个 splay 的 color 标记打上&#125; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 200005;const int maxq = 200005;int n, q;struct Edge&#123; int to, nxt;&#125; e[maxn &lt;&lt; 1];int first[maxn];inline void add_edge(int from, int to)&#123; static int cnt = 0; e[++cnt].nxt = first[from]; e[cnt].to = to; first[from] = cnt; e[++cnt].nxt = first[to]; e[cnt].to = from; first[to] = cnt;&#125;#define lowbit(x) (x &amp; -x)struct BIT&#123; int xx[maxn &lt;&lt; 1]; inline void add(int pla, int x) &#123; for(; pla &lt;= n + q; pla += lowbit(pla)) xx[pla] += x; &#125; inline int query(int pla) &#123; int ans = 0; for(; pla; pla -= lowbit(pla)) ans += xx[pla]; return ans; &#125;&#125; tr;int fa[maxn];int s[maxn][2];int siz[maxn];int col[maxn];int lzy[maxn];inline void dfs(int now)&#123; col[now] = now; siz[now] = 1; for(int i = first[now]; i; i = e[i].nxt) &#123; register int to = e[i].to; if(to != fa[now]) &#123; fa[to] = now; dfs(to); if(col[to] &gt; col[now]) &#123; col[now] = col[to]; s[now][1] = to; siz[now] = siz[to] + 1; &#125; &#125; &#125; tr.add(col[now], 1);&#125;inline bool nroot(int x)&#123; return s[fa[x]][0] == x || s[fa[x]][1] == x;&#125;inline void push_up(int x)&#123; siz[x] = siz[s[x][0]] + siz[s[x][1]] + 1;&#125;inline void fan(int x)&#123; lzy[x] ^= 1; swap(s[x][0], s[x][1]);&#125;inline void push_down(int x)&#123; if(lzy[x]) &#123; lzy[x] = 0; if(s[x][0]) fan(s[x][0]); if(s[x][1]) fan(s[x][1]); &#125; if(s[x][0]) col[s[x][0]] = col[x]; if(s[x][1]) col[s[x][1]] = col[x];&#125;inline void rotate(int x)&#123; int y = fa[x], z = fa[y]; int d = s[y][1] == x, k = s[x][!d]; if(nroot(y)) s[z][s[z][1] == y] = x; fa[x] = z; s[x][!d] = y; fa[y] = x; s[y][d] = k; if(k) fa[k] = y; push_up(y); push_up(x);&#125;int sta[maxn];inline void splay(int x)&#123; int tx = x; int top = 0; sta[++top] = tx; while(nroot(tx)) sta[++top] = (tx = fa[tx]); while(top) push_down(sta[top--]); while(nroot(x)) &#123; register int y = fa[x]; if(nroot(y)) &#123; register int z = fa[y]; rotate(((s[z][1] == y) ^ (s[y][1] == x)) ? x : y); &#125; rotate(x); &#125;&#125;int nowcol;inline void access(int x)&#123; for(int y = 0; x; x = fa[y = x]) &#123; splay(x); s[x][1] = 0; push_up(x); tr.add(col[x], -siz[x]); tr.add(nowcol, siz[x]); s[x][1] = y; push_up(x); &#125;&#125;inline void make_root(int x)&#123; nowcol++; access(x); splay(x); fan(x); col[x] = nowcol;&#125;char opt[23];inline int query(int x)&#123; splay(x); return tr.query(col[x]) - siz[s[x][0]];&#125;int main()&#123; scanf(\"%d%d\", &amp;n, &amp;q); nowcol = n; for(int i = 1, f, t; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;f, &amp;t); add_edge(f, t); &#125; dfs(n); int _u, _v; for(int i = 1; i &lt;= q; ++i) &#123; scanf(\"%s\", opt); if(opt[0] == 'u') &#123; scanf(\"%d\", &amp;_v); make_root(_v); &#125; else if(opt[0] == 'w') &#123; scanf(\"%d\", &amp;_v); printf(\"%d\\n\", query(_v)); &#125; else &#123; scanf(\"%d%d\", &amp;_u, &amp;_v); int ans1 = query(_u); int ans2 = query(_v); printf(\"%d\\n\", ans1 &lt; ans2 ? _u : _v); &#125; &#125; return 0;&#125; 翻译来自luogu ↩︎","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"LCT","slug":"LCT","permalink":"https://pufanyi.pages.dev/tags/LCT/"}]},{"title":"CodeForces 434D Nanami's Power Plant","slug":"CF434D","date":"2019-03-16T16:00:00.000Z","updated":"2019-03-16T16:00:00.000Z","comments":true,"path":"CF434D/","link":"","permalink":"https://pufanyi.pages.dev/CF434D/","excerpt":"原题链接有nnn个二次函数，第iii个形如fi(x)=aix2+bix+cif_i(x)=a_ix^2+b_ix+c_ifi​(x)=ai​x2+bi​x+ci​你的总收益是∑i=1nfi(xi)\\sum_{i=1}^nf_i(x_i)∑i=1n​fi​(xi​)，但是有几个限制：xi​x_i​xi​​是[li,ri]​[l_i,r_i]​[li​,ri​]​中的一个整数还给了mmm条额外的限制，每条形如u v d，表示的是xu≤xv+dx_u\\leq x_v+dxu​≤xv​+d求最大的总收益。n≤50;m≤100;∣ai∣≤10;∣bi∣,∣ci∣≤1000;−100≤li≤ri≤100;∣di∣≤200n\\le 50; m\\le 100; |a_i|\\le 10;|b_i|,|c_i|\\le1000;-100\\le l_i\\le r_i\\le 100;|d_i|\\le 200n≤50;m≤100;∣ai​∣≤10;∣bi​∣,∣ci​∣≤1000;−100≤li​≤ri​≤100;∣di​∣≤200。[1]","text":"原题链接 有nnn个二次函数，第 iii 个形如 fi(x)=aix2+bix+cif_i(x)=a_ix^2+b_ix+c_ifi​(x)=ai​x2+bi​x+ci​ 你的总收益是 ∑i=1nfi(xi)\\sum_{i=1}^nf_i(x_i)∑i=1n​fi​(xi​)，但是有几个限制：xi​x_i​xi​​ 是[li,ri]​[l_i,r_i]​[li​,ri​]​中的一个整数 还给了 mmm 条额外的限制，每条形如 u v d，表示的是xu≤xv+dx_u\\leq x_v+dxu​≤xv​+d 求最大的总收益。n≤50;m≤100;∣ai∣≤10;∣bi∣,∣ci∣≤1000;−100≤li≤ri≤100;∣di∣≤200n\\le 50; m\\le 100; |a_i|\\le 10;|b_i|,|c_i|\\le1000;-100\\le l_i\\le r_i\\le 100;|d_i|\\le 200n≤50;m≤100;∣ai​∣≤10;∣bi​∣,∣ci​∣≤1000;−100≤li​≤ri​≤100;∣di​∣≤200。[1] 题解 感觉和刚刚做过一场模拟赛的一道题很类似……考虑网络流，对每个函数都建立 [li,ri]​[l_i,r_i]​[li​,ri​]​ 的点，点 (i,j)​(i,j)​(i,j)​ 表示函数 fi​f_i​fi​​ 当xi=j​x_i=j​xi​=j​时的点。我们考虑最小损失。设一个极大值 limlimlim（大于所有的fi(x)f_i(x)fi​(x)），将也就是要求lim−fi(x)lim-f_i(x)lim−fi​(x) 的最小值。我们从点 (i,j)(i,j)(i,j) 向点 (i,j+1)(i,j+1)(i,j+1)（如果j=rij=r_ij=ri​ 那就是超汇 TTT）流lim−fi(j)lim - f_i(j)lim−fi​(j)，从超源SSS 向点 (i,li)(i,l_i)(i,li​) 流∞\\infty∞。大概就是这样一张图：digraph flow {\"dot1\"[label=\"...\"]; \"dot2\"[label=\"...\"]; \"dot3\"[label=\"...\"];&quot;S&quot;-&gt;&quot;(1,l[1])&quot;[label=&quot;inf&quot;]; &quot;(1,l[1])&quot;-&gt;&quot;(1,l[1]+1)&quot;[label=&quot;lim-f(1,l[1])&quot;]; &quot;(1,l[1]+1)&quot;-&gt;&quot;dot1&quot;[label=&quot;lim-f(1,l[1])&quot;]; &quot;dot1&quot;-&gt;&quot;(1,r[1])&quot;; &quot;(1,r[1])&quot;-&gt;T[label=&quot;lim-f(1,r[1])&quot;]; &quot;S&quot;-&gt;&quot;(2,l[2])&quot;[label=&quot;inf&quot;]; &quot;(2,l[2])&quot;-&gt;&quot;(2,l[2]+1)&quot;[label=&quot;lim-f(2,l[2])&quot;]; &quot;(2,l[2]+1)&quot;-&gt;&quot;dot2&quot;[label=&quot;lim-f(2,l[2])&quot;]; &quot;dot2&quot;-&gt;&quot;(2,r[2])&quot;; &quot;(2,r[2])&quot;-&gt;T[label=&quot;lim-f(2,r[2])&quot;]; &quot;S&quot;-&gt;&quot;(3,l[3])&quot;[label=&quot;inf&quot;]; &quot;(3,l[3])&quot;-&gt;&quot;(3,l[3]+1)&quot;[label=&quot;lim-f(3,l[3])&quot;]; &quot;(3,l[3]+1)&quot;-&gt;&quot;dot3&quot;[label=&quot;lim-f(3,l[3])&quot;]; &quot;dot3&quot;-&gt;&quot;(3,r[3])&quot;; &quot;(3,r[3])&quot;-&gt;T[label=&quot;lim-f(3,r[3])&quot;]; }如果这些函数的取值互补干涉，那么 n×lim− 最小割 n\\times lim-\\text{最小割}n×lim− 最小割 就是答案。我们考虑如何加入这些限制。如果现在有限制 xu≤xv+dx_u\\le x_v+dxu​≤xv​+d，也就是xv≥xu−dx_v\\ge x_u-dxv​≥xu​−d。如果我们割了xux_uxu​ 这条边，在 vvv 这条链上我们只能割 xu−dx_u-dxu​−d 以后的边。那就不妨从 uuu 这条表上所有的 xxx 向vvv这条边上所有的 x−dx-dx−d 连一条 ∞​\\infty​∞​ 的边。如果割绿色的那两条边：digraph flow {\"dot1\",\"dot4\"[label=\"...\", color=\"red\"]; \"dot2\",\"dot3\"[label=\"...\"]; \"(u,x)\",\"(u,x+1)\",\"(v,x-d+1)\",\"(v,x-d+2)\"[color=\"red\"];&quot;dot1&quot;-&gt;&quot;(u,x)&quot;-&gt;&quot;(u,x+1)&quot;[color=&quot;red&quot;]; &quot;(u,x+1)&quot;-&gt;&quot;(u,x+2)&quot;[color=&quot;green&quot;,label=&quot;(cut)&quot;]; &quot;(u,x+2)&quot;-&gt;&quot;dot2&quot;; &quot;dot3&quot;-&gt;&quot;(v,x-d)&quot;; &quot;(v,x-d)&quot;-&gt;&quot;(v,x-d+1)&quot;[color=&quot;green&quot;,label=&quot;(cut)&quot;]; &quot;(v,x-d+1)&quot;-&gt;&quot;(v,x-d+2)&quot;-&gt;&quot;dot4&quot;[color=&quot;red&quot;]; &quot;(u,x)&quot;-&gt;&quot;(v,x-d)&quot;[label=&quot;inf&quot;]; &quot;(u,x+1)&quot;-&gt;&quot;(v,x-d+1)&quot;[label=&quot;inf&quot;, color=&quot;red&quot;]; &quot;(u,x+2)&quot;-&gt;&quot;(v,x-d+2)&quot;[label=&quot;inf&quot;]; }很开心地测一下样例，炸了……我们来看这种情形（对样例 1 略有改动）：12345672 20 1 00 1 12 31 21 2 02 1 0建出来的图大概是长这样的：digraph flow {\"S\"->\"(1,2)\"[label=\"inf\"]; \"(1,2)\"->\"(1,3)\"[label=\"lim-2\"]; \"(1,3)\"->\"T\"[label=\"lim-3\"];&quot;S&quot;-&gt;&quot;(2,1)&quot;[label=&quot;inf&quot;]; &quot;(2,1)&quot;-&gt;&quot;(2,2)&quot;[label=&quot;lim-2&quot;]; &quot;(2,2)&quot;-&gt;&quot;T&quot;[label=&quot;lim-3&quot;]; &quot;(1,2)&quot;-&gt;&quot;(2,2)&quot;[label=&quot;inf&quot;]; &quot;(2,2)&quot;-&gt;&quot;(1,2)&quot;[label=&quot;inf&quot;]; }最小割是选 (1,3)→T(1,3)\\to T(1,3)→T 和(2,3)→T(2,3)\\to T(2,3)→T。但显然 (1,3)→T​(1,3)\\to T​(1,3)→T​ 是不能选的。因为由 x1≤x2​x_1\\le x_2​x1​≤x2​​ 和x2≤x1​x_2\\le x_1​x2​≤x1​​可知 x1=x2​x_1=x_2​x1​=x2​​。 于是我们只得再建一个 (i,ri+1)(i,r_i+1)(i,ri​+1) 点，(i,ri)→(i,ri+1)(i,r_i)\\to (i,r_i+1)(i,ri​)→(i,ri​+1)流 fi(ri)f_i(r_i)fi​(ri​)，(i,ri+1)→T(i,r_i+1)\\to T(i,ri​+1)→T 流∞\\infty∞。digraph flow {\"S\"->\"(1,2)\"[label=\"inf\"]; \"(1,2)\"->\"(1,3)\"[label=\"lim-2\"]; \"(1,3)\"->\"(1,4)\"[label=\"lim-3\"]; \"(1,4)\"->\"T\"[label=\"inf\"];&quot;S&quot;-&gt;&quot;(2,1)&quot;[label=&quot;inf&quot;]; &quot;(2,1)&quot;-&gt;&quot;(2,2)&quot;[label=&quot;lim-2&quot;]; &quot;(2,2)&quot;-&gt;&quot;(2,3)&quot;[label=&quot;lim-3&quot;]; &quot;(2,3)&quot;-&gt;&quot;T&quot;[label=&quot;inf&quot;]; &quot;(1,2)&quot;-&gt;&quot;(2,2)&quot;[label=&quot;inf&quot;]; &quot;(2,2)&quot;-&gt;&quot;(1,2)&quot;[label=&quot;inf&quot;]; &quot;(1,3)&quot;-&gt;&quot;(2,3)&quot;[label=&quot;inf&quot;]; &quot;(2,3)&quot;-&gt;&quot;(1,3)&quot;[label=&quot;inf&quot;]; }这样就完美了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const LL maxn = 10005;const LL maxm = 5000005;const LL inf = 0x3f3f3f3f3f3f3f3f;const LL lim = 1000000000000;struct Edge&#123; LL to, nxt, cap;&#125; e[maxm &lt;&lt; 1];LL first[maxn], first_bak[maxn];inline void add_edge(LL from, LL to, LL cap)&#123; static LL cnt = -1; e[++cnt].nxt = first[from]; first[from] = cnt; e[cnt].to = to; e[cnt].cap = cap; e[++cnt].nxt = first[to]; first[to] = cnt; e[cnt].to = from; e[cnt].cap = 0;&#125;LL n, m, S, T;LL bh[105][205];LL a[maxn], b[maxn], c[maxn];LL ll[maxn];LL rr[maxn];LL dep[maxn];inline LL getans(LL I, LL x)&#123; return a[I] * x * x + b[I] * x + c[I];&#125;inline bool bfs()&#123; memset(dep, 0x3f, sizeof(dep)); queue&lt;LL&gt; q; q.push(S); dep[S] = 0; for(int i = S; i &lt;= T; ++i) first[i] = first_bak[i]; while(!q.empty()) &#123; LL now = q.front(); q.pop(); for(int i = first[now]; ~i; i = e[i].nxt) &#123; LL to = e[i].to; if(dep[to] &gt;= inf &amp;&amp; e[i].cap &gt; 0) &#123; dep[to] = dep[now] + 1; q.push(to); &#125; &#125; &#125; return dep[T] &lt; inf;&#125;inline LL dfs(LL now, LL lim)&#123; if(!lim || now == T) return lim; LL flow = 0; for(int i = first[now]; ~i; i = e[i].nxt) &#123; first[now] = i; register LL to = e[i].to, f; if(dep[to] == dep[now] + 1 &amp;&amp; (f = dfs(to, min(lim, e[i].cap))) &gt; 0) &#123; lim -= f; flow += f; e[i].cap -= f; e[i ^ 1].cap += f; if(lim &lt;= 0) break; &#125; &#125; return flow;&#125;inline LL dinic()&#123; LL flow = 0; while(bfs()) flow += dfs(S, inf); return flow;&#125;int main()&#123; memset(first, 0xff, sizeof(first)); scanf(\"%lld%lld\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) scanf(\"%lld%lld%lld\", &amp;a[i], &amp;b[i], &amp;c[i]); for(int i = 1; i &lt;= n; ++i) &#123; scanf(\"%lld%lld\", &amp;ll[i], &amp;rr[i]); add_edge(S, T + 1, inf); for(LL j = ll[i] + 100; j &lt;= rr[i] + 101; ++j) &#123; bh[i][j] = ++T; if(j != ll[i] + 100) add_edge(bh[i][j - 1], bh[i][j], lim - getans(i, j - 1 - 100)); &#125; &#125; T++; for(LL i = 1; i &lt;= n; ++i) add_edge(bh[i][rr[i] + 101], T, inf); for(int i = 1, u, v, d; i &lt;= m; ++i) &#123; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); for(int j = ll[u]; j &lt;= rr[u] + 1; ++j) if(ll[v] &lt;= j - d &amp;&amp; j - d &lt;= rr[v] + 1) add_edge(bh[u][j + 100], bh[v][j - d + 100], inf); &#125; for(int i = S; i &lt;= T; ++i) first_bak[i] = first[i]; printf(\"%lld\\n\", n * lim - dinic()); return 0;&#125;翻译来自luogu，略有改动。 ↩︎","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"网络流","slug":"网络流","permalink":"https://pufanyi.pages.dev/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"SPOJ4063 Sell Pigs","slug":"SP4063","date":"2019-03-10T16:00:00.000Z","updated":"2019-03-10T16:00:00.000Z","comments":true,"path":"SP4063/","link":"","permalink":"https://pufanyi.pages.dev/SP4063/","excerpt":"原题链接有m​m​m​个猪圈，开始时第i​i​i​个猪圈有ai​a_i​ai​​头猪，每个猪圈都是锁门的，要是不相同。管理员没有猪圈的钥匙。依次来了m​m​m​个顾客，第i​i​i​个顾客有Ai​A_i​Ai​​把猪圈钥匙（哪几个都告诉你）话说为什么钥匙会在顾客手中啊，需要至多Bi​B_i​Bi​​头猪。每个顾客打开这几个猪圈，然后管理员可以把打开门的几个猪圈里的猪进行调整（比如把A​\\text{A}​A​猪圈的其中一头猪带到B​\\text{B}​B​猪圈）。要求的是管理员最多能卖出多少猪。n≤100,m≤1000n\\le 100,m\\le 1000n≤100,m≤1000。","text":"原题链接 有m​m​m​个猪圈，开始时第 i​i​i​ 个猪圈有 ai​a_i​ai​​ 头猪，每个猪圈都是锁门的，要是不相同。管理员没有猪圈的钥匙。依次来了 m​m​m​ 个顾客，第 i​i​i​ 个顾客有 Ai​A_i​Ai​​ 把猪圈钥匙（哪几个都告诉你）话说为什么钥匙会在顾客手中啊 ，需要至多Bi​B_i​Bi​​ 头猪。每个顾客打开这几个猪圈，然后管理员可以把打开门的几个猪圈里的猪进行调整（比如把 A​\\text{A}​A​ 猪圈的其中一头猪带到 B​\\text{B}​B​ 猪圈）。要求的是管理员最多能卖出多少猪。n≤100,m≤1000n\\le 100,m\\le 1000n≤100,m≤1000。 题解 一道有趣的网络流建模题……首先当然要建超源（SSS）和超汇（TTT）。把每个顾客都看成一个点。每个顾客向 TTT 连一条容量为 BiB_iBi​ 的边，表示每个顾客最多买 BiB_iBi​ 头猪。首先是 SSS 向每个猪圈第一个打开门的顾客连边，边权为 aia_iai​，即猪圈内猪的数量，表示猪圈一开始能供应给顾客的猪。 如果某个顾客打开了猪圈 X​\\text{X}​X​（即有猪圈X​\\text{X}​X​ 的钥匙），那么他所能“看”到的猪（即如果 Bi=∞​B_i=\\infty​Bi​=∞​ 时他所能买到的猪）下一个打开 X​\\text{X}​X​ 的顾客也能买到，所以每个顾客都像下一个打开这些门的顾客连边，边权为 $\\infty$。建图代码如下：123456789101112131415161718192021222324252627inline int solve()&#123; memset(first, 0xff, sizeof(first)); scanf(\"%d%d\", &amp;m, &amp;n); for(int i = 1; i &lt;= m; ++i) scanf(\"%d\", &amp;yuan[i]); // 原来猪圈里的猪 for(int i = 1; i &lt;= n; ++i) &#123; int tn; scanf(\"%d\", &amp;tn); for(int j = 1, x; j &lt;= tn; ++j) &#123; scanf(\"%d\", &amp;x); mmap[lst[x]][i] = lst[x] ? inf : mmap[lst[x]][i] + yuan[x]; // lst 数组一开始是 0 lst[x] = i; // 最近那次打开猪圈的人是 i &#125; scanf(\"%d\", &amp;tn); add_edge(i, n + 1, tn); // 向最后的 &#125; for(int i = 0; i &lt;= n; ++i) for(int j = 0; j &lt;= n; ++j) if(mmap[i][j]) add_edge(i, j, mmap[i][j]); // 由于可能有重边所以先用邻接矩阵暂存一下，然后统一加入 for(register int i = 0; i &lt;= n + 1; ++i) first_bak[i] = first[i]; // dinic 当前弧优化是用，不用理他 return Dinic();&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://pufanyi.pages.dev/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"SPOJ","slug":"SPOJ","permalink":"https://pufanyi.pages.dev/tags/SPOJ/"}]},{"title":"HEOI2015 公约数数列","slug":"[HEOI2015]公约数数列","date":"2019-03-09T16:00:00.000Z","updated":"2019-03-09T16:00:00.000Z","comments":true,"path":"[HEOI2015]公约数数列/","link":"","permalink":"https://pufanyi.pages.dev/[HEOI2015]%E5%85%AC%E7%BA%A6%E6%95%B0%E6%95%B0%E5%88%97/","excerpt":"设计一个数据结构. 给定一个正整数数列a0,a1,...,an−1a_0, a_1, ..., a_{n - 1}a0​,a1​,...,an−1​，你需要支持以下两种操作：MODIFY id x：将aida_{id}aid​修改为xxx。QUERY x：求最小的整数p(0≤p&lt;n)p (0 \\le p &lt; n)p(0≤p&lt;n)，使得gcd⁡i=0pai×⨂i=0pai=x\\gcd_{i=0}^pa_i\\times \\bigotimes_{i=0}^p a_i= xgcdi=0p​ai​×⨂i=0p​ai​=x。无解输出no。n≤100000n \\le 100000n≤100000，q≤10000q \\le 10000q≤10000，ai≤109(0≤i&lt;n)a_i \\le 10^9 (0 \\le i &lt; n)ai​≤109(0≤i&lt;n)，QUERY x 中的x≤1018x \\le 10^{18}x≤1018，MODIFY id x中的 0≤id&lt;n0 \\le id &lt; n0≤id&lt;n，1≤x≤1091 \\le x \\le 10^91≤x≤109。","text":"设计一个数据结构. 给定一个正整数数列 a0,a1,...,an−1a_0, a_1, ..., a_{n - 1}a0​,a1​,...,an−1​，你需要支持以下两种操作：MODIFY id x：将aida_{id}aid​ 修改为 xxx。QUERY x：求最小的整数p(0≤p&lt;n)p (0 \\le p &lt; n)p(0≤p&lt;n)，使得gcd⁡i=0pai×⨂i=0pai=x\\gcd_{i=0}^pa_i\\times \\bigotimes_{i=0}^p a_i= xgcdi=0p​ai​×⨂i=0p​ai​=x。无解输出no。n≤100000n \\le 100000n≤100000，q≤10000q \\le 10000q≤10000，ai≤109(0≤i&lt;n)a_i \\le 10^9 (0 \\le i &lt; n)ai​≤109(0≤i&lt;n)，QUERY x 中的x≤1018x \\le 10^{18}x≤1018，MODIFY id x 中的 0≤id&lt;n0 \\le id &lt; n0≤id&lt;n，1≤x≤1091 \\le x \\le 10^91≤x≤109。 题解 前缀 gcd⁡\\gcdgcd 序列有一个有趣的性质，那就是后一个数一定是前一个数的因数，所以至少会除 222。 于是我们发现前缀 gcd⁡\\gcdgcd 序列之多只会有 log⁡\\loglog 个不同的数。考虑到 gcd⁡\\gcdgcd 与⨂\\bigotimes⨂没有什么太大的联系，我们考虑枚举 gcd⁡\\gcdgcd，然后找出⨂i=0pai=xgcd⁡i=0pai\\bigotimes_{i=0}^p a_i=\\frac{x}{\\gcd_{i=0}^pa_i}⨂i=0p​ai​=gcdi=0p​ai​x​。 发现仍然很难维护，于是我们考虑分块。对于每个块维护块内最后一个元素的前缀 gcd⁡\\gcdgcd，块内gcd⁡\\gcdgcd，以及每个元素的前缀异或和。 首先是修改异或和。修改单点后，要将后面所有的 xor\\text{xor}xor 值全部修改。直接对每个块打一个标记即可。修改 gcd⁡\\gcdgcd 也很方便，块内 gcd⁡\\gcdgcd 与前缀 gcd⁡\\gcdgcd 均可暴力维护。查询某块时，如果其第一个数的前缀 gcd⁡\\gcdgcd（上一个块最后一个数的前缀gcd⁡\\gcdgcd 与这一个块的第一个数的 gcd⁡\\gcdgcd）与其最后一个数的前缀gcd⁡\\gcdgcd 不相等，直接暴力修改。由于前缀 gcd⁡\\gcdgcd 序列只有 log⁡\\loglog 个不同的数。单次复杂度是O(nlog⁡n)\\mathcal{O}(\\sqrt n\\log n)O(n​logn)。如果相等，那也就意味着块内所有数的前缀 gcd⁡\\gcdgcd 均相等。只要查询前缀 xor\\text{xor}xor 即可。对每个块开一个 map/hash 查一下就可以了。单次操作复杂度O(nlog⁡n)\\mathcal{O}(\\sqrt n\\log n)O(n​logn)。所以总复杂度是O(qnlog⁡n)\\mathcal{O}(q\\sqrt n\\log n)O(qn​logn)，需要卡常。博主太菜 luogu 过了 bzoj 没卡过去，假装过了的样子。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;typedef long long LL;template &lt;class T&gt;inline void writeln(T x)&#123; if(!x) &#123; puts(\"0\"); return; &#125; if(x &lt; 0) &#123; putchar('-'); x = -x; &#125; int bit[20] = &#123;0&#125;; while(x) &#123; bit[++(*bit)] = (x % 10) | 48; x /= 10; &#125; do putchar(bit[*bit]); while(--(*bit)); puts(\"\");&#125;inline int gcd(int a, int b)&#123; int t; while (b) &#123; t = a % b; a = b; b = t; &#125; return a;&#125;int n;int kc, ds;int hgcd[maxn]; // 块后的前缀 gcdint kgcd[maxn]; // 块内 gcdint belong[maxn];int ll[maxn], rr[maxn];map&lt;int, int&gt; mp[maxn];int yuan[maxn];int qz_xor[maxn];int lzy_xor[maxn];inline void modify(int id, int x)&#123; int tx = x; // 先改 xor x ^= yuan[id]; for (register int i = id; i &lt;= rr[belong[id]]; ++i) qz_xor[i] ^= x; mp[belong[id]].clear(); for (register int i = ll[belong[id]]; i &lt;= rr[belong[id]]; ++i) &#123; qz_xor[i] ^= lzy_xor[belong[i]]; if (!mp[belong[id]][qz_xor[i]]) mp[belong[id]][qz_xor[i]] = i; &#125; lzy_xor[belong[id]] = 0; if (rr[belong[id]] != n) for (register int i = belong[id] + 1; i &lt;= ds; ++i) lzy_xor[i] ^= x; // 然后是 gcd yuan[id] = tx; kgcd[belong[id]] = 0; for (register int i = ll[belong[id]]; i &lt;= rr[belong[id]]; ++i) kgcd[belong[id]] = gcd(kgcd[belong[id]], yuan[i]); for (register int i = belong[id]; i &lt;= ds; ++i) &#123; int tmp = gcd(hgcd[i - 1], kgcd[i]); if (tmp == hgcd[i]) break; else hgcd[i] = tmp; &#125;&#125;inline int query(LL x)&#123; for (int i = 1; i &lt;= ds; ++i) &#123; if (!(x % (LL) hgcd[i])) &#123; int qiangcd = gcd(hgcd[i - 1], yuan[i]); if (qiangcd != hgcd[i]) &#123; for(int j = ll[i], nowg = hgcd[i - 1]; j &lt;= rr[i]; ++j) &#123; nowg = gcd(nowg, yuan[j]); if(nowg * (LL) (qz_xor[j] ^ lzy_xor[i]) == x) return j; &#125; &#125; else &#123; LL xx = (x / (LL) hgcd[i]) ^ lzy_xor[i]; if(mp[i][xx]) return mp[i][xx]; &#125; &#125; &#125; return -1;&#125;inline void pre()&#123; scanf(\"%d\", &amp;n); kc = sqrt(n); ds = n / kc; if (n % kc) ds++; for (int i = 1; i &lt;= ds; ++i) &#123; ll[i] = rr[i - 1] + 1; rr[i] = min(ll[i] + kc - 1, n); for (int j = ll[i]; j &lt;= rr[i]; ++j) &#123; scanf(\"%d\", &amp;yuan[j]); kgcd[i] = gcd(yuan[j], kgcd[i]); qz_xor[j] = qz_xor[j - 1] ^ yuan[j]; if (!mp[i][qz_xor[j]]) mp[i][qz_xor[j]] = j; belong[j] = i; hgcd[i] = gcd(hgcd[i - 1], kgcd[i]); &#125; &#125;&#125;int main()&#123; pre(); char s[233]; int Q; scanf(\"%d\", &amp;Q); while(Q--) &#123; scanf(\"%s\", s); if(s[0] == 'M') &#123; int id, x; scanf(\"%d%d\", &amp;id, &amp;x); modify(id + 1, x); &#125; else &#123; LL x; scanf(\"%lld\", &amp;x); int ans = query(x); if(~ans) writeln(ans - 1); else puts(\"no\"); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"分块","slug":"分块","permalink":"https://pufanyi.pages.dev/tags/%E5%88%86%E5%9D%97/"},{"name":"卡常","slug":"卡常","permalink":"https://pufanyi.pages.dev/tags/%E5%8D%A1%E5%B8%B8/"}]},{"title":"四道大水题","slug":"第二次出模拟赛","date":"2019-03-09T16:00:00.000Z","updated":"2019-03-09T16:00:00.000Z","comments":true,"path":"第二次出模拟赛/","link":"","permalink":"https://pufanyi.pages.dev/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%87%BA%E6%A8%A1%E6%8B%9F%E8%B5%9B/","excerpt":"给下一届出题，自然是出得水一点比较好咯～","text":"给下一届出题，自然是出得水一点比较好咯～ 题面 完整的选手文件夹 戳这里下载 题解 数据 由于数据太大，放百度网盘上去了，戳这里下载 提取码：xc6z 标程 戳这里下载，包括一些暴力","categories":[{"name":"出题","slug":"出题","permalink":"https://pufanyi.pages.dev/categories/%E5%87%BA%E9%A2%98/"}],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://pufanyi.pages.dev/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"数学","slug":"数学","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数论","slug":"数论","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E8%AE%BA/"},{"name":"数据结构","slug":"数据结构","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DP","slug":"DP","permalink":"https://pufanyi.pages.dev/tags/DP/"},{"name":"树状数组/线段树","slug":"树状数组-线段树","permalink":"https://pufanyi.pages.dev/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"最短路","slug":"最短路","permalink":"https://pufanyi.pages.dev/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"出题","slug":"出题","permalink":"https://pufanyi.pages.dev/tags/%E5%87%BA%E9%A2%98/"}]},{"title":"浮点数开根","slug":"浮点数开根","date":"2019-02-22T16:00:00.000Z","updated":"2019-02-22T16:00:00.000Z","comments":true,"path":"浮点数开根/","link":"","permalink":"https://pufanyi.pages.dev/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%BC%80%E6%A0%B9/","excerpt":"给你讲个鬼故事。有一只神犇叫Wzp，模拟赛时出了一道计算几何题，精度开到了1e-13。","text":"给你讲个鬼故事。有一只 神犇 叫 Wzp，模拟赛时出了一道 计算几何题 ， 精度开到了 1e-13。题目大意就是给你一个 ΔABC\\Delta ABCΔABC 和n(n≤1000)n(n\\le 1000)n(n≤1000)个向量，你可以在其中选至多 kkk 个作用在 AAA 上，使最终得到的三角形周长最长。特别的，这个三角形可以退化成一条线，其实只要算 AB+BC+ACAB+BC+ACAB+BC+AC 就可以了。其中所有给出的数据（包括向量的 x,yx, yx,y）都是整数。 正解在这里就不说了 我才不会告诉你是因为我不会做这道题 ，重点是那个细节，也就是1e-13 的精度应该怎么整。重点就是那个 sqrt，这玩意考场上测了一下（用long double）精度大概只有10−8∼10−910^{-8}\\sim 10^{-9}10−8∼10−9，直接悲惨爆 0…… 有一个很妙的trick，我们设需要计算s=xs=\\sqrt{x}s=x​，我们设 sss 的整数部分是 aaa，小数部分是bbb，我们有：x=(a+b)2=a2+b2+2ab=a2+b(a+b)+ab=a2+bs+ab=a2+b(s+a)\\begin{aligned} x&amp;=(a+b)^2\\\\ &amp;=a^2+b^2+2ab\\\\ &amp;=a^2+b(a+b)+ab\\\\ &amp;=a^2+bs+ab\\\\ &amp;=a^2+b(s+a) \\end{aligned}x​=(a+b)2=a2+b2+2ab=a2+b(a+b)+ab=a2+bs+ab=a2+b(s+a)​ 所以：b=x−a2s+a\\begin{aligned} b=\\frac{x-a^2}{s+a} \\end{aligned}b=s+ax−a2​​其中的 s 直接调用 sqrt() 即可。这样我们就可以用一个 long long 和一个double（甚至不用long double）来表示浮点数，精度也会高很多。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://pufanyi.pages.dev/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://pufanyi.pages.dev/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"数学","slug":"数学","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"一道有趣的计数问题","slug":"一道有趣的计数问题bywzp","date":"2019-02-22T16:00:00.000Z","updated":"2019-02-22T16:00:00.000Z","comments":true,"path":"一道有趣的计数问题bywzp/","link":"","permalink":"https://pufanyi.pages.dev/%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98bywzp/","excerpt":"给你一块巧克力，横着最多切aaa刀，竖着最多切bbb刀，定义每切一刀的收益为切完后所有巧克力的和，每次随机在能切的所有地方等概率随机切一刀，求切k(k≤a+b)k(k\\le a + b)k(k≤a+b)到刀得到收益的期望。答案对998244353998244353998244353取模。a,b≤1018a, b\\le 10^{18}a,b≤1018。","text":"给你一块巧克力，横着最多切 aaa 刀，竖着最多切 bbb 刀，定义每切一刀的收益为切完后所有巧克力的和，每次随机在能切的所有地方等概率随机切一刀，求切 k(k≤a+b)k(k\\le a + b)k(k≤a+b) 到刀得到收益的期望。答案对 998244353998244353998244353 取模。a,b≤1018a, b\\le 10^{18}a,b≤1018。我们考虑每个正方形左下角（如下图）为贡献，如黄色格子的贡献我们看成是点 PPP 的贡献，那我们可以把点分成三类：中间的（红色点），边缘的（蓝色点），左下角的（绿色点）。如果一个点“暴露在了外面”，即该点对应的方块成为了整个方块的左下角，那么之后每切一次它就会对答案有 111 的贡献。首先我们来看中间的点（红点）。对于每个点，如果第 iii 次切割后它暴露在外面，那么前 iii 次切割必定有一次切了它所在竖列，还有一次且了它所在横行。所以有 (i2)\\binom{i}{2}(2i​) 中排列方案。而从这么多横行于纵列中选 222 条线的方案数为 (a+b2)\\binom{a+b}{2}(2a+b​)，所以第iii 次切完后该点暴露在外面的概率为：E(i)=(i2)(a+b2)E(i)=\\frac{\\binom{i}{2}}{\\binom{a+b}{2}}E(i)=(2a+b​)(2i​)​由于切了 kkk 次，所以每个点贡献的期望为：∑i=1kE(i)=∑i=1k(i2)(a+b2)=∑i=1k(i2)(a+b2)=(k+13)(a+b2)=(k+1)⋅k⋅(k−1)6(a+b)(a+b−1)2=(k+1)⋅k⋅(k−1)3⋅(a+b)⋅(a+b−1)\\sum_{i=1}^k E(i)=\\sum_{i=1}^k\\frac{\\binom{i}{2}}{\\binom{a+b}{2}}=\\frac{\\sum_{i=1}^k\\binom{i}{2}}{\\binom{a+b}{2}}=\\frac{\\binom{k+1}{3}}{\\binom{a+b}{2}}=\\frac{\\frac{(k+1)\\cdot k\\cdot(k-1)}{6}}{\\frac{(a+b)(a+b-1)}{2}}=\\frac{(k+1)\\cdot k\\cdot(k-1)}{3\\cdot(a+b)\\cdot(a+b-1)}i=1∑k​E(i)=i=1∑k​(2a+b​)(2i​)​=(2a+b​)∑i=1k​(2i​)​=(2a+b​)(3k+1​)​=2(a+b)(a+b−1)​6(k+1)⋅k⋅(k−1)​​=3⋅(a+b)⋅(a+b−1)(k+1)⋅k⋅(k−1)​总共有 ababab 个红点，所以总的期望为：(k+1)⋅k⋅(k−1)3⋅(a+b)⋅(a+b−1)⋅ab\\frac{(k+1)\\cdot k\\cdot(k-1)}{3\\cdot(a+b)\\cdot(a+b-1)}\\cdot ab3⋅(a+b)⋅(a+b−1)(k+1)⋅k⋅(k−1)​⋅ab然后是边上的点（蓝点）。每次切都会多一个蓝点，所以贡献一定为：∑i=1ki=k(k+1)2\\sum_{i=1}^k i=\\frac{k(k+1)}{2}i=1∑k​i=2k(k+1)​最后是左下角的绿点，每次切都会它都会有 111 的贡献，所以是 kkk。 所以总的贡献为：(k+1)⋅k⋅(k−1)⋅ab3⋅(a+b)⋅(a+b−1)+k⋅(k+1)2+k\\frac{(k+1)\\cdot k\\cdot(k-1)\\cdot ab}{3\\cdot(a+b)\\cdot(a+b-1)}+\\frac{k\\cdot(k+1)}{2}+k3⋅(a+b)⋅(a+b−1)(k+1)⋅k⋅(k−1)⋅ab​+2k⋅(k+1)​+k优秀的 O(1)\\mathcal{O}(1)O(1) 算法。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://pufanyi.pages.dev/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://pufanyi.pages.dev/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"数学","slug":"数学","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"NOI2010 航空管制","slug":"航空管制","date":"2019-02-16T16:00:00.000Z","updated":"2019-02-16T16:00:00.000Z","comments":true,"path":"航空管制/","link":"","permalink":"https://pufanyi.pages.dev/%E8%88%AA%E7%A9%BA%E7%AE%A1%E5%88%B6/","excerpt":"成功抢到luogu最劣解+bzoj最劣解（至少我提交的时候是这样）……题意是给你一张拓扑图，求出一个拓扑序使得第iii个点在第kik_iki​个位置之前。先构造一组解，然后输出每个点可以到的最小的位置。","text":"成功抢到 luogu 最劣解 +bzoj最劣解（至少我提交的时候是这样）……题意是给你一张拓扑图，求出一个拓扑序使得第 iii 个点在第 kik_iki​ 个位置之前。先构造一组解，然后输出每个点可以到的最小的位置。构造一组解很简单，建个反图之后按 kik_iki​ 为关键字排序一下，从小到大一个一个遍历即可。因为如果 kik_iki​ 小的航班都没有开出，开 kik_iki​ 大的显然没有意义。123456789101112131415161718192021inline void shan(int now) // 遍历 now 点，但在遍历 now 点时显然先要遍历 now 之前（即反图之后）的点 &#123; for(int i = ff[now]; i; i = ee[i].nxt) &#123; int to = ee[i].to; // ee 是反图中的边 if(!vis[to]) shan(to); &#125; printf(\"%d\", now); vis[now] = true;&#125;int main()&#123; for(int i = 1; i &lt;= n; ++i) kkk[i] = mp(k[i], i); // #define mp make_pair sort(kkk + 1, kkk + n + 1); for(int i = 1; i &lt;= n; ++i) if(!vis[kkk[i].second]) shan(kkk[i].second);&#125; 然后我们发现如果给出的 kkk 序列无解，那么输出的序列一定不合法（怎么可能合法？），然后我们发现可以二分。复杂度？O(nmlog⁡n)\\mathcal{O}(nm\\log n)O(nmlogn)……显然 T，T 了 4 个点。然后开始 O( 松)\\mathcal{O}(\\text{松})O(松 ) 卡常。然后发现它过了。虽然我卡了一年……下面是卡完的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194// luogu-judger-enable-o2 开 O2 还是最劣解……#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 2005;const int maxm = 10005;int n, m;// 快读快输显然得加 inline char gc()&#123; static char sxd[1 &lt;&lt; 16], *sss = sxd, *ttt = sxd; return (sss == ttt) &amp;&amp; (ttt = (sss = sxd) + fread(sxd, 1, 1 &lt;&lt; 16, stdin), sss == ttt) ? EOF : *sss++;&#125;#define dd c = gc()inline int read(int &amp;x)&#123; char dd; x = 0; bool f = false; for(; !isdigit(c); dd) &#123; if(c == '-') f = true; if(c == EOF) return -1; &#125; for(; isdigit(c); dd) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if(f) x = -x; return 1;&#125;#undef ddinline void write(register int x)&#123; int c[10]; *c = 0; while(x) &#123; c[++(*c)] = x % 10; x /= 10; &#125; if(!(*c)) x = 1; while(*c) putchar(c[(*c)--] | 48); putchar('');&#125;struct pii // 并不知道手打pair 会不会快一点&#123; int first, second; inline bool operator &lt; (const pii&amp; other) const &#123; return this-&gt;first &lt; other.first; &#125;&#125;;pii kkk[maxn];struct EDGE&#123; int to, nxt;&#125; ee[maxm]; // 注意是反图的边，原图的边似乎不用建int du[maxn];int first[maxn];int ff[maxn];int dz[maxn];inline void add_edge(register int from, register int to)&#123; static int cnt = 0; ee[++cnt].nxt = ff[to]; ff[to] = cnt; ee[cnt].to = from;&#125;int k[maxn];int top;int vis[maxn];inline void shan(register int now) // 回答第一个问题 &#123; for(register int i = ff[now]; i; i = ee[i].nxt) if(!vis[ee[i].to]) shan(ee[i].to); write(now); dz[now] = ++top; // 记录一下每个点至少可以在那个时刻被遍历，这样缩小的二分的范围 vis[now] = true;&#125;pii kx[maxn];bool viss[maxn];int X, KK;inline bool shann(register int now)&#123; for(register int i = ff[now]; i; i = ee[i].nxt) if(!viss[ee[i].to]) if(!shann(ee[i].to)) return false; if(++top &gt; ((now != X) ? k[now] : KK)) // 直接边跑边判断，常数应该会小一点 return false; return viss[now] = true;&#125;inline bool pan(register int x, register int kk)&#123; KK = kk; register int now = 0; for(register int i = 1; i &lt;= n; ++i) &#123; kx[i] = kkk[i]; if(kx[i].second == x) &#123; kx[i].first = kk; now = i; &#125; &#125; pii T; // 本来下面一段只是一句 sort，但那个常数是在太大了，只能插排 while(now &gt; 1 &amp;&amp; kx[now].first &lt; kx[now - 1].first) &#123; T = kx[now]; kx[now] = kx[now - 1]; kx[now - 1] = T; now--; &#125; while(now &lt;= n &amp;&amp; kx[now].first &gt; kx[now + 1].first) &#123; T = kx[now]; kx[now] = kx[now + 1]; kx[now + 1] = T; now++; &#125; memset(viss, 0, sizeof(viss)); top = 0; for(register int i = 1; i &lt;= n; ++i) if(!viss[kx[i].second]) if(!shann(kx[i].second)) return false; return true;&#125;inline int solve(const register int x)&#123; X = x; register int l = 1, r = dz[x], mid; // 二分，r 直接就是上面的 dz 了，即第一个问题 x 在那个位置 while(l &lt; r) &#123; mid = (l + r) &gt;&gt; 1; if(!pan(x, mid)) l = mid + 1; else r = mid; &#125; return r;&#125;int main()&#123; read(n), read(m); for(register int i = 1; i &lt;= n; ++i) &#123; read(k[i]); kkk[i].first = k[i]; kkk[i].second = i; &#125; sort(kkk + 1, kkk + n + 1); int f, t; for(register int i = 1; i &lt;= m; ++i) &#123; read(f), read(t); add_edge(f, t); &#125; for(register int i = 1; i &lt;= n; ++i) if(!vis[kkk[i].second]) shan(kkk[i].second); puts(\"\"); for(register int i = 1; i &lt;= n; ++i) write(solve(i)); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://pufanyi.pages.dev/tags/%E4%BA%8C%E5%88%86/"},{"name":"卡常","slug":"卡常","permalink":"https://pufanyi.pages.dev/tags/%E5%8D%A1%E5%B8%B8/"}]},{"title":"一个有趣的问题","slug":"整数分解求乘积最大","date":"2019-02-05T16:00:00.000Z","updated":"2019-02-05T16:00:00.000Z","comments":true,"path":"整数分解求乘积最大/","link":"","permalink":"https://pufanyi.pages.dev/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3%E6%B1%82%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7/","excerpt":"把正整数nnn分解成几个正整数的和，是它们的乘积最大。","text":"把正整数 nnn 分解成几个正整数的和，是它们的乘积最大。以下纯口胡，如果有问题求在下面留言。根据均值不等式（证明在最下面）：∏i=1nxi≤(∑i=1nxin)n\\prod_{i=1}^n x_i\\le \\left(\\frac{\\sum_{i=1}^nx_i}{n}\\right)^ni=1∏n​xi​≤(n∑i=1n​xi​​)n先不考虑整数的限制，我们应将一个数均匀地分成 kkk 份，每个数为 xxx，那么有：n=kxn=kxn=kx 另乘积为 yyy，有：y=xk=xnx=(x1x)ny=x^k=x^{\\frac{n}{x}}=(x^{\\frac{1}{x}})^ny=xk=xxn​=(xx1​)n 于是问题就变成了求 y=x1x​y=x^{\\frac{1}{x}}​y=xx1​​ 在x&gt;0​x&gt;0​x&gt;0​上的极值。两边同取对数：ln⁡y=1xln⁡x\\ln y = \\frac{1}{x}\\ln xlny=x1​lnx两边同时关于 xxx 求导：y′y=−1x2ln⁡x+1x2=1−ln⁡xx2\\frac{y&#x27;}{y}=-\\frac{1}{x^2}\\ln x+\\frac{1}{x^2}=\\frac{1-\\ln x}{x^2}yy′​=−x21​lnx+x21​=x21−lnx​右边应该没问题，那左边为什么不是 1y​\\frac{1}{y}​y1​​ 呢？因为 yyy 是个因变量，其导数不一定就是 111，即xxx 增加 dx\\mathrm{d}xdx，yyy 不一定增加 dx\\mathrm{d}xdx。 但我们有：f[g(x)]=f′(x)g′(x)f[g(x)]=f&#x27;(x)g&#x27;(x)f[g(x)]=f′(x)g′(x)于是：y′=1−ln⁡xx2y=1−ln⁡xx2x1xy&#x27;=\\frac{1-\\ln x}{x^2}y=\\frac{1-\\ln x}{x^2}x^{\\frac{1}{x}}y′=x21−lnx​y=x21−lnx​xx1​当 y′=0y&#x27;=0y′=0 时：1−ln⁡xx2x1x=0\\frac{1-\\ln x}{x^2}x^{\\frac{1}{x}}=0x21−lnx​xx1​=0由于 x&gt;0x&gt;0x&gt;0：1−ln⁡x=01-\\ln x=01−lnx=0 即：x=ex=ex=e但 eee 不是整数，由于 ⌊e⌋=2,⌈e⌉=3\\lfloor e\\rfloor=2,\\lceil e\\rceil=3⌊e⌋=2,⌈e⌉=3，且212≈1.4142135623730950488016887242097313≈1.44224957030740838232163831078012^{\\frac{1}{2}}\\approx1.4142135623730950488016887242097\\\\ 3^{\\frac{1}{3}}\\approx1.4422495703074083823216383107801221​≈1.4142135623730950488016887242097331​≈1.4422495703074083823216383107801 所以 212&lt;3132^{\\frac{1}{2}}&lt;3^{\\frac{1}{3}}221​&lt;331​ 因此应该尽量取 333，多出来的取222。 下面给出均值不等式的一种证法：有一种叫“反向归纳法”的东西，它是从 nnn 到n−1n-1n−1来证明命题。我们令原命题为 P(n)​P(n)​P(n)​。 首先，n=2​n=2​n=2​时显然为真：ab≤a+b2\\sqrt{ab}\\le \\frac{a+b}{2}ab​≤2a+b​然后证明 P(n)P(n)P(n) 和P(2)P(2)P(2)蕴涵着 P(2n)P(2n)P(2n)： 因为：∏i=1nxi≤(∑i=1nxin)n∏i=n+12nxi≤(∑i=n+12nxin)n\\prod_{i=1}^n x_i\\le \\left(\\frac{\\sum_{i=1}^nx_i}{n}\\right)^n\\\\ \\prod_{i=n+1}^{2n} x_i\\le \\left(\\frac{\\sum_{i=n+1}^{2n}x_i}{n}\\right)^ni=1∏n​xi​≤(n∑i=1n​xi​​)ni=n+1∏2n​xi​≤(n∑i=n+12n​xi​​)n两式相乘：∏i=12nxi≤(∑i=1nxin)n×(∑i=n+12nxin)n≤(∑i=12nxi2n)2n\\prod_{i=1}^{2n} x_i\\le \\left(\\frac{\\sum_{i=1}^{n}x_i}{n}\\right)^n\\times\\left(\\frac{\\sum_{i=n+1}^{2n}x_i}{n}\\right)^n\\le \\left(\\frac{\\sum_{i=1}^{2n}x_i}{2n}\\right)^{2n}i=1∏2n​xi​≤(n∑i=1n​xi​​)n×(n∑i=n+12n​xi​​)n≤(2n∑i=12n​xi​​)2n最后证明 P(n)P(n)P(n) 蕴涵着 P(n−1)P(n-1)P(n−1)： 令xn=∑i=1n−1xin−1​x_n=\\frac{\\sum_{i=1}^{n-1}x_i}{n-1}​xn​=n−1∑i=1n−1​xi​​​即 xn​x_n​xn​​ 为前 n−1​n-1​n−1​ 项的平均值，我们发现这 n​n​n​ 项的平均值为前 n−1​n-1​n−1​ 项的平均值，即：∏i=1n−1xi×∑i=1n−1xin−1≤(∑i=1n−1xin−1)n\\prod_{i=1}^{n-1} x_i\\times\\frac{\\sum_{i=1}^{n-1}x_i}{n-1}\\le \\left(\\frac{\\sum_{i=1}^{n-1}x_i}{n-1}\\right)^ni=1∏n−1​xi​×n−1∑i=1n−1​xi​​≤(n−1∑i=1n−1​xi​​)n两边同除∑i=1n−1xin−1\\frac{\\sum_{i=1}^{n-1}x_i}{n-1}n−1∑i=1n−1​xi​​：∏i=1n−1xi≤(∑i=1n−1xin−1)n−1\\prod_{i=1}^{n-1} x_i \\le \\left(\\frac{\\sum_{i=1}^{n-1}x_i}{n-1}\\right)^{n-1}i=1∏n−1​xi​≤(n−1∑i=1n−1​xi​​)n−1","categories":[{"name":"随笔","slug":"随笔","permalink":"https://pufanyi.pages.dev/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"自适应辛普森法","slug":"simpson","date":"2019-02-03T16:00:00.000Z","updated":"2019-02-03T16:00:00.000Z","comments":true,"path":"simpson/","link":"","permalink":"https://pufanyi.pages.dev/simpson/","excerpt":"并没想打算开篇小小结，只是随便写写（感觉开小小结的成本太高了啊……）","text":"并没想打算开篇小小结，只是随便写写（感觉开小小结的成本太高了啊……）感觉还是挺妙的。以前听 zyy 大佬 讲课的时候说过，函数的积分用二次函数拟合一下。加入我们要算 ∫lrF(x)dx\\int_l^r F(x)\\mathrm{d}x∫lr​F(x)dx，我们用二次函数f(x)=ax2+bx+cf(x)=ax^2+bx+cf(x)=ax2+bx+c 来拟合。我们发现：∫lrf(x)dx=a3r3+b2r2+cr−a3l3−b2l2−cl=a3(r−l)(r2+l2+lr)+b2(r−l)(r+l)+c(r−l)=r−l6(2ar2+2al2+2alr+3br+3bl+6c)=r−l6(ar2+br+c+al2+bl+c+ar2+al2+2alr+2br+2bl+4c)=r−l6(f(l)+f(r)+a(l+r)2+2b(l+r)+4c)=r−l6(f(l)+f(r)+4(a(l+r2)2+b(l+r2)+c))=r−l6(f(l)+f(r)+4f(l+r2))\\begin{aligned} \\int_l^r f(x)\\mathrm{d}x&amp;=\\frac{a}{3}r^3+\\frac{b}{2}r^2+cr-\\frac{a}{3}l^3-\\frac{b}{2}l^2-cl\\\\ &amp;=\\frac{a}{3}\\left(r-l\\right)\\left(r^2+l^2+lr\\right)+\\frac{b}{2}\\left(r-l\\right)\\left(r+l\\right)+c\\left(r-l\\right)\\\\ &amp;=\\frac{r-l}{6}\\left(2ar^2+2al^2+2alr+3br+3bl+6c\\right)\\\\ &amp;=\\frac{r-l}{6}\\left(ar^2+br+c+al^2+bl+c+ar^2+al^2+2alr+2br+2bl+4c\\right)\\\\ &amp;=\\frac{r-l}{6}\\left(f(l)+f(r)+a(l+r)^2+2b(l+r)+4c\\right)\\\\ &amp;=\\frac{r-l}{6}\\left(f(l)+f(r)+4\\left(a\\left(\\frac{l+r}{2}\\right)^2+b\\left(\\frac{l+r}{2}\\right)+c\\right)\\right)\\\\ &amp;=\\frac{r-l}{6}\\left(f(l)+f(r)+4f\\left(\\frac{l+r}{2}\\right)\\right) \\end{aligned}∫lr​f(x)dx​=3a​r3+2b​r2+cr−3a​l3−2b​l2−cl=3a​(r−l)(r2+l2+lr)+2b​(r−l)(r+l)+c(r−l)=6r−l​(2ar2+2al2+2alr+3br+3bl+6c)=6r−l​(ar2+br+c+al2+bl+c+ar2+al2+2alr+2br+2bl+4c)=6r−l​(f(l)+f(r)+a(l+r)2+2b(l+r)+4c)=6r−l​(f(l)+f(r)+4(a(2l+r​)2+b(2l+r​)+c))=6r−l​(f(l)+f(r)+4f(2l+r​))​于是我们有：∫lrF(x)dx≈r−l6(F(l)+F(r)+4F(l+r2))\\int_l^r F(x)\\mathrm{d}x\\approx\\frac{r-l}{6}\\left(F(l)+F(r)+4F\\left(\\frac{l+r}{2}\\right)\\right)∫lr​F(x)dx≈6r−l​(F(l)+F(r)+4F(2l+r​))然后就可以拟合辣！1234inline double simpson(double l, double r)&#123; return (F(l) + F(r) + 4 * F((l + r) / 2)) * (r - l) / 6;&#125;然而就是要么 WA（炸精度）要么 T……有一种叫自适应辛普森的方法解决这个问题，我们用辛普森计算 ∫lrF(x)dx\\int_l^rF(x)\\mathrm{d}x∫lr​F(x)dx，∫l(l+r)/2F(x)dx\\int_l^{(l+r)/2}F(x)\\mathrm{d}x∫l(l+r)/2​F(x)dx，∫(l+r)/2rF(x)dx\\int_{(l+r)/2}^rF(x)\\mathrm{d}x∫(l+r)/2r​F(x)dx 的值，如果 ∣∫lrF(x)dx−(∫l(l+r)/2F(x)dx+∫(l+r)/2rF(x)dx)∣≤eps\\left|\\int_l^rF(x)\\mathrm{d}x-\\left(\\int_l^{(l+r)/2}F(x)\\mathrm{d}x+\\int_{(l+r)/2}^rF(x)\\mathrm{d}x\\right)\\right|\\le \\mathrm{eps}∣∣∣​∫lr​F(x)dx−(∫l(l+r)/2​F(x)dx+∫(l+r)/2r​F(x)dx)∣∣∣​≤eps，那么直接返回值，否则递归下去算。upd：忽然发现我学了个假的simpson。其实eps 应该是相对误差，所以每次递归下去时 eps\\mathrm{eps}eps 都应该除 222。听说最后判定时应该是≤15⋅eps\\le 15\\cdot \\mathrm{eps}≤15⋅eps，虽然我并不知道是为什么。 话说这和 eps 乘上 15 有什么区别吗 这样复杂度就是 O( 玄学 )\\mathcal{O}\\left(\\text{玄学}\\right)O( 玄学)，交之前洗把脸就行了。12345678inline double asr(double l, double r, double ans, double eps)&#123; double mid = (l + r) * .5; double ll = simpson(l, mid), rr = simpson(mid, r); if(fabs(ll + rr - ans) &lt; 15 * eps) return ll + rr; return asr(l, mid, ll, eps * .5) + asr(mid, r, rr, eps * .5);&#125;","categories":[{"name":"随笔","slug":"随笔","permalink":"https://pufanyi.pages.dev/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Uva12421 (Jiandan) Mua (I) - Lexical Analyzer","slug":"UVa12421","date":"2019-01-31T16:00:00.000Z","updated":"2019-01-31T16:00:00.000Z","comments":true,"path":"UVa12421/","link":"","permalink":"https://pufanyi.pages.dev/UVa12421/","excerpt":"一道毒瘤的大模拟。","text":"一道毒瘤的大模拟。 题目大意 题目大概就是让你写一个叫“Mua语言”解释器，这是第一步，就是把输入代码中的每个“token”（词法单元）都分开来。一共有六种 token（Mua语言严格区分大小写）：RESERVED（保留字）：下面列出所有保留字（福利：附赠 c++ 代码）：1234567string all[21] =&#123; \"and\", \"break\", \"do\", \"else\", \"elseif\", \"end\", \"false\", \"for\", \"function\", \"if\", \"in\", \"local\", \"nil\", \"not\", \"or\", \"repeat\", \"return\", \"then\", \"true\", \"until\", \"while\"&#125;;NUMBER（数字常量）：十进制整数：包含 0∼90\\sim 90∼9 的数字，如 233333，可以有前导000。 十六进制整数：以 0x 或0X开头，然后是一个或多个十六进制数字（0∼90\\sim 90∼9，a∼fa\\sim fa∼f，A∼FA\\sim FA∼F），可以有前导 000。如0X3F3a3f3F 浮点数：浮点数总是十进制的，如 1.23，可以用科学记数法表示，方法是在后面加上字符e 或者 E，然后是十进制整数（如1.23e2，它等于1.230），小数点和指数不能同时省略，但整数部分可以省略（如.2e3 是合法的）。如果省略可整数部分，则必须要有小数点和至少一位小数（因此 .e2 是非法的）。不支持十六进制浮点小数。注意指数的前面可以有一个前缀 + 或者 -，如1e+10 和4e-3都是合法的。需要注意的是负数包含两个 token，“-”是单独的一个 token，下面会说。STRING（字符串）：由双引号 &quot;&quot; 或单引号 '' 包围的字符串常量，只支持四种转义字符：\\&quot;，\\'，\\\\，\\n。字符串内部不能有物理换行符。SYMBOL（符号）：英文 pdf 假掉了，有几个 SYMBOL 没有完全显示。直接赠送 c++ 代码：1234567string all[26] =&#123; \"+\", \"-\", \"*\", \"/\", \"%\", \"^\", \"#\", \"==\", \"~=\", \"&lt;=\", \"&gt;=\", \"&lt;\", \"&gt;\", \"=\", \"(\", \")\", \"&#123;\", \"&#125;\", \"[\", \"]\", \";\", \":\", \",\", \".\", \"..\", \"...\"&#125;;NAME（标识符）：必须以字母开头，后跟若干个字母、数字或者下划线。注意，保留字不能作为标识符。EOL（物理换行符）：不多说，都懂。COMMENT（注释）：以 -- 开头，换行符结束。注意换行符不是注释中的一部分，而是单独的 EOL。 注意，字符串常量外的所有空白字符都应忽略，因此 1+1 和1 + 1对于词法分析器来说没有任何区别。另外，词法分析器应当是贪心的，即总是让第一个 token 尽量长，在此前提下让第二个尽量长，依此类推。比如，abc123&lt;=123应分成 abc123，&lt;= 和123。此外，在输出时，注释应当直接忽略，不用输出。（感觉我的翻译几乎就是抄《训练指南》的……） 题解 感觉近期好 tf 于是逼自己刷了道模拟题（虽然没猪国杀那么巨大）。其实感觉如果能耐心打下去并不会感觉很烦。下面大致整理一下思路。为了方便，先把几个 Token 类型变成数字：12345678910string TYPE[] =&#123; \"RESERVED\", // 保留字 1 \"NUMBER\", // 数字 2 \"STRING\", // 字符串 3 \"SYMBOL\", // 符号 4 \"NAME\", // 变量名 5 \"EOL\", // 换行符 6 \"COMMENT\" // 注释 7&#125;;还有把 SYMBOL 和RESERVED的几个字符串全塞 set 里（由于直接在 struct 里定义初始化变量值，所以需要 c++11）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct SYMBOL&#123; string all[26] = // -std=c++11 &#123; \"+\", \"-\", \"*\", \"/\", \"%\", \"^\", \"#\", \"==\", \"~=\", \"&lt;=\", \"&gt;=\", \"&lt;\", \"&gt;\", \"=\", \"(\", \")\", \"&#123;\", \"&#125;\", \"[\", \"]\", \";\", \":\", \",\", \".\", \"..\", \"...\" &#125;; set&lt;string&gt; all_symbol; SYMBOL () &#123; all_symbol.clear(); for(int i = 0; i &lt; 26; ++i) all_symbol.insert(all[i]); &#125; inline bool is_symbol(string s) &#123; return all_symbol.count(s); &#125;&#125; symb;struct RESERVED&#123; string all[21] = // -std=c++11 &#123; \"and\", \"break\", \"do\", \"else\", \"elseif\", \"end\", \"false\", \"for\", \"function\", \"if\", \"in\", \"local\", \"nil\", \"not\", \"or\", \"repeat\", \"return\", \"then\", \"true\", \"until\", \"while\" &#125;; set&lt;string&gt; all_reserved; RESERVED () &#123; all_reserved.clear(); for(int i = 0; i &lt; 21; ++i) all_reserved.insert(all[i]); &#125; inline bool is_reserved(string s) &#123; return all_reserved.count(s); &#125;&#125; rese; 定义一个 Token 类型：12345678struct Token&#123; int typ; string s; Token (int tp = 6, string ss = \"\") // 默认换行符 &#123; typ = tp, s = ss; &#125;&#125;; 当然先要读入：123456789if(nowl == s.length())&#123; if(!getline(cin, s)) return Token(-1); nowl = 0; s.push_back('\\n');&#125;while(s[nowl] == ' ') nowl++;然后最先判断换行符和注释：12345678910if(s[nowl] == '\\n')&#123; nowl++; return ans; // ans 是个 Token 类型，初始化就是换行符，下同 &#125;if(s[nowl] == '-' &amp;&amp; s[nowl + 1] == '-')&#123; nowl = s.length(); return ans;&#125; 字符串直接分成单引号和双引号两种，复制一下就可以了：12345678910111213141516171819202122232425262728293031if(s[nowl] == '\"') // 用双引号包裹的字符串 &#123; bool zy = false; ans.s.push_back(s[nowl++]); while(zy || s[nowl] != '\"') &#123; if(!zy &amp;&amp; s[nowl] == '\\\\') zy = true; else zy = false; ans.s.push_back(s[nowl++]); &#125; ans.s.push_back(s[nowl++]); ans.typ = 3; return ans;&#125;if(s[nowl] == '\\'') // 用单引号包裹的字符串&#123; bool zy = false; ans.s.push_back(s[nowl++]); while(zy || s[nowl] != '\\'') &#123; if(!zy &amp;&amp; s[nowl] == '\\\\') zy = true; else zy = false; ans.s.push_back(s[nowl++]); &#125; ans.typ = 3; return ans;&#125; 接下来是判断 NAME 和RESERVED：12345678910if(isalpha(s[nowl]))&#123; while(can_be_a_name(s[nowl])) ans.s.push_back(s[nowl++]); if(rese.is_reserved(ans.s)) ans.typ = 1; else ans.typ = 5; return ans;&#125;关于 can_be_a_name 和can_be_a_number：123456789101112inline bool can_be_a_name(char c)&#123; return isalpha(c) || c == '_' || isdigit(c);&#125;inline bool can_be_a_number(char c)&#123; return isdigit(c) || c == '.' || c == '-' || c == '+' || c == 'E' || c == 'e' || c == 'x' || c == 'X' || ('a' &lt;= c &amp;&amp; c &lt;= 'f') || ('A' &lt;= c &amp;&amp; c &lt;= 'F');&#125;最后判断数字了，果断选择先写好一个判断一个 string 是不是 NUMBER 的函数，然后 O(n3)\\mathcal{O}(n^3)O(n3) 判断（感觉方法很 zz，但调起来很爽，还顺便把 SYMBOL 给判掉了）。这里是判断 NUMBER 的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104struct NUMBER&#123; inline bool is_zf(char c) &#123; return c == '+' || c == '-'; &#125; inline bool is_10_int(const register string&amp; s) // 是十进制整型 &#123; unsigned l = 0; while(l &lt; s.length() &amp;&amp; is_zf(s[l])) l++; if(l &gt;= s.length()) return false; while(l &lt; s.length() &amp;&amp; isdigit(s[l])) l++; return l == s.length(); &#125; inline bool is_0x_char(char c) &#123; return isdigit(c) || ('a' &lt;= c &amp;&amp; c &lt;= 'f') || ('A' &lt;= c &amp;&amp; c &lt;= 'F'); &#125; inline bool is_0x_int(const register string&amp; s) // 是十六进制整型 &#123; unsigned l = 0; while(l &lt; s.length() &amp;&amp; is_zf(s[l])) l++; if(l + 1 &gt;= s.length()) return false; if(s[l] != '0' || (s[l + 1] != 'x' &amp;&amp; s[l + 1] != 'X')) return false; l += 2; while(l &lt; s.length() &amp;&amp; is_0x_char(s[l])) l++; return l == s.length(); &#125; inline bool is_float(const register string&amp; s) // 是浮点型 &#123; unsigned l = 0; while(l &lt; s.length() &amp;&amp; is_zf(s[l])) l++; if(l + 1 &gt;= s.length()) return false; int hav_e = -1, hav_d = -1; // hav_e 记录 e 的位置，hav_d 记录. 的位置 for(unsigned i = l; i &lt; s.length(); ++i) &#123; if(s[i] == '.') &#123; if(~hav_d) return false; else hav_d = i + 1; &#125; else if(s[i] == 'E' || s[i] == 'e') &#123; if(~hav_e) return false; else hav_e = i + 1; &#125; else if(s[i] != '-' &amp;&amp; s[i] != '+' &amp;&amp; !isdigit(s[i])) return false; &#125; // 把开始到小数点、小数点到 e、e 到结尾分开来看 if((~hav_e) &amp;&amp; (~hav_d)) &#123; if(hav_e &lt; hav_d || (hav_d == 1 &amp;&amp; hav_e - hav_d == 1)) return false; return ((hav_d == 1) || is_10_int(s.substr(0, hav_d - 1))) &amp;&amp; (is_10_int(s.substr(hav_d, hav_e - hav_d - 1)) ||(hav_e - hav_d == 1)) &amp;&amp; is_10_int(s.substr(hav_e)); &#125; else if(~hav_e) &#123; return is_10_int(s.substr(0, hav_e - 1)) &amp;&amp; is_10_int(s.substr(hav_e)); &#125; else if(~hav_d) &#123; return ((hav_d == 1) || is_10_int(s.substr(0, hav_d - 1))) &amp;&amp; is_10_int(s.substr(hav_d)); &#125; else return false; &#125; inline int is_number(const register string&amp; s) // 合并起来 &#123; if(s[0] == '+' || s[0] == '-') return 0; if(is_10_int(s)) return 1; else if(is_0x_int(s)) return 2; else if(is_float(s)) return 3; else return 0; &#125;&#125; numb; 然后把 NUMBER 读出来，顺便把 SYMBOL 也给判掉：123456789101112131415161718192021222324252627int r = 0;if(s[nowl] != '+' &amp;&amp; s[nowl] != '-')&#123; while(can_be_a_number(s[nowl + r])) r++; while(r &amp;&amp; !numb.is_number(s.substr(nowl, r))) r--;&#125;if(r)&#123; ans.s = s.substr(nowl, r); nowl += r; ans.typ = 2;&#125;else // 如果不可能是数字，那就只能是 SYMBOL 了 &#123; string lst = ans.s = \"\"; lst.push_back(s[nowl++]); while(symb.is_symbol(lst)) &#123; ans.s.push_back(s[nowl - 1]); lst.push_back(s[nowl++]); &#125; nowl--; ans.typ = 4;&#125;return ans; 完结撒花。最后把完整的代码贴一下，毕竟是一道细节题，再加上数据水（交完就把自己 hack 掉了，然后发现过了），如果把我的代码 hack 掉了求在下面留言：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;string TYPE[] =&#123; \"RESERVED\", // 保留字 1 \"NUMBER\", // 数字 2 \"STRING\", // 字符串 3 \"SYMBOL\", // 符号 4 \"NAME\", // 变量名 5 \"EOL\", // 换行符 6 \"COMMENT\" // 注释 7&#125;;struct SYMBOL&#123; string all[26] = &#123; \"+\", \"-\", \"*\", \"/\", \"%\", \"^\", \"#\", \"==\", \"~=\", \"&lt;=\", \"&gt;=\", \"&lt;\", \"&gt;\", \"=\", \"(\", \")\", \"&#123;\", \"&#125;\", \"[\", \"]\", \";\", \":\", \",\", \".\", \"..\", \"...\" &#125;; set&lt;string&gt; all_symbol; SYMBOL () &#123; all_symbol.clear(); for(int i = 0; i &lt; 26; ++i) all_symbol.insert(all[i]); &#125; inline bool is_symbol(string s) &#123; return all_symbol.count(s); &#125;&#125; symb;struct RESERVED&#123; string all[21] = &#123; \"and\", \"break\", \"do\", \"else\", \"elseif\", \"end\", \"false\", \"for\", \"function\", \"if\", \"in\", \"local\", \"nil\", \"not\", \"or\", \"repeat\", \"return\", \"then\", \"true\", \"until\", \"while\" &#125;; set&lt;string&gt; all_reserved; RESERVED () &#123; all_reserved.clear(); for(int i = 0; i &lt; 21; ++i) all_reserved.insert(all[i]); &#125; inline bool is_reserved(string s) &#123; return all_reserved.count(s); &#125;&#125; rese;struct Token&#123; int typ; string s; Token (int tp = 6, string ss = \"\") &#123; typ = tp, s = ss; &#125;&#125;;struct NUMBER&#123; inline bool is_zf(char c) &#123; return c == '+' || c == '-'; &#125; inline bool is_10_int(const register string&amp; s) &#123; unsigned l = 0; while(l &lt; s.length() &amp;&amp; is_zf(s[l])) l++; if(l &gt;= s.length()) return false; while(l &lt; s.length() &amp;&amp; isdigit(s[l])) l++; return l == s.length(); &#125; inline bool is_0x_char(char c) &#123; return isdigit(c) || ('a' &lt;= c &amp;&amp; c &lt;= 'f') || ('A' &lt;= c &amp;&amp; c &lt;= 'F'); &#125; inline bool is_0x_int(const register string&amp; s) &#123; unsigned l = 0; while(l &lt; s.length() &amp;&amp; is_zf(s[l])) l++; if(l + 1 &gt;= s.length()) return false; if(s[l] != '0' || (s[l + 1] != 'x' &amp;&amp; s[l + 1] != 'X')) return false; l += 2; while(l &lt; s.length() &amp;&amp; is_0x_char(s[l])) l++; return l == s.length(); &#125; inline bool is_float(const register string&amp; s) &#123; unsigned l = 0; while(l &lt; s.length() &amp;&amp; is_zf(s[l])) l++; if(l + 1 &gt;= s.length()) return false; int hav_e = -1, hav_d = -1; for(unsigned i = l; i &lt; s.length(); ++i) &#123; if(s[i] == '.') &#123; if(~hav_d) return false; else hav_d = i + 1; &#125; else if(s[i] == 'E' || s[i] == 'e') &#123; if(~hav_e) return false; else hav_e = i + 1; &#125; else if(s[i] != '-' &amp;&amp; s[i] != '+' &amp;&amp; !isdigit(s[i])) return false; &#125; if((~hav_e) &amp;&amp; (~hav_d)) &#123; if(hav_e &lt; hav_d || (hav_d == 1 &amp;&amp; hav_e - hav_d == 1)) return false; return ((hav_d == 1) || is_10_int(s.substr(0, hav_d - 1))) &amp;&amp; (is_10_int(s.substr(hav_d, hav_e - hav_d - 1)) ||(hav_e - hav_d == 1)) &amp;&amp; is_10_int(s.substr(hav_e)); &#125; else if(~hav_e) &#123; return is_10_int(s.substr(0, hav_e - 1)) &amp;&amp; is_10_int(s.substr(hav_e)); &#125; else if(~hav_d) &#123; return ((hav_d == 1) || is_10_int(s.substr(0, hav_d - 1))) &amp;&amp; is_10_int(s.substr(hav_d)); &#125; else return false; &#125; inline int is_number(const register string&amp; s) &#123; if(s[0] == '+' || s[0] == '-') return 0; if(is_10_int(s)) return 1; else if(is_0x_int(s)) return 2; else if(is_float(s)) return 3; else return 0; &#125;&#125; numb;class BUF&#123; private: string s; unsigned nowl; inline bool can_be_a_name(char c) &#123; return isalpha(c) || c == '_' || isdigit(c); &#125; inline bool can_be_a_number(char c) &#123; return isdigit(c) || c == '.' || c == '-' || c == '+' || c == 'E' || c == 'e' || c == 'x' || c == 'X' || ('a' &lt;= c &amp;&amp; c &lt;= 'f') || ('A' &lt;= c &amp;&amp; c &lt;= 'F'); &#125; public: BUF() &#123; nowl = 0; s = \"\"; &#125; inline Token read() &#123; Token ans; if(nowl == s.length()) &#123; if(!getline(cin, s)) return Token(-1); nowl = 0; s.push_back('\\n'); &#125; while(s[nowl] == '') nowl++; if(s[nowl] == '\\n') &#123; nowl++; return ans; &#125; if(s[nowl] == '-' &amp;&amp; s[nowl + 1] == '-') &#123; nowl = s.length(); return ans; &#125; if(s[nowl] == '\"') &#123; bool zy = false; ans.s.push_back(s[nowl++]); while(zy || s[nowl] != '\"') &#123; if(!zy &amp;&amp; s[nowl] == '\\\\') zy = true; else zy = false; ans.s.push_back(s[nowl++]); &#125; ans.s.push_back(s[nowl++]); ans.typ = 3; return ans; &#125; if(s[nowl] == '\\'') &#123; bool zy = false; ans.s.push_back(s[nowl++]); while(zy || s[nowl] != '\\'') &#123; if(!zy &amp;&amp; s[nowl] == '\\\\') zy = true; else zy = false; ans.s.push_back(s[nowl++]); &#125; ans.typ = 3; return ans; &#125; if(isalpha(s[nowl])) &#123; while(can_be_a_name(s[nowl])) ans.s.push_back(s[nowl++]); if(rese.is_reserved(ans.s)) ans.typ = 1; else ans.typ = 5; return ans; &#125; else &#123; int r = 0; if(s[nowl] != '+' &amp;&amp; s[nowl] != '-') &#123; while(can_be_a_number(s[nowl + r])) r++; while(r &amp;&amp; !numb.is_number(s.substr(nowl, r))) r--; &#125; if(r) &#123; ans.s = s.substr(nowl, r); nowl += r; ans.typ = 2; &#125; else &#123; string lst = ans.s = \"\"; lst.push_back(s[nowl++]); while(symb.is_symbol(lst)) &#123; ans.s.push_back(s[nowl - 1]); lst.push_back(s[nowl++]); &#125; nowl--; ans.typ = 4; &#125; return ans; &#125; &#125;&#125; buf;int main()&#123; Token s; while(s = buf.read(), ~s.typ) &#123; s.typ--; if(s.typ == 5) cout &lt;&lt; '[' &lt;&lt; TYPE[s.typ] &lt;&lt; ']' &lt;&lt; '\\n'; else cout &lt;&lt; '[' &lt;&lt; TYPE[s.typ] &lt;&lt; ']' &lt;&lt; '' &lt;&lt; s.s &lt;&lt; '\\n'; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"UVa","slug":"UVa","permalink":"https://pufanyi.pages.dev/tags/UVa/"},{"name":"模拟","slug":"模拟","permalink":"https://pufanyi.pages.dev/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"CodeForces 77C Beavermuncher-0xFF","slug":"CF77C","date":"2019-01-11T16:00:00.000Z","updated":"2019-01-11T16:00:00.000Z","comments":true,"path":"CF77C/","link":"","permalink":"https://pufanyi.pages.dev/CF77C/","excerpt":"原题链接有一棵树，第iii个节点上有kik_iki​只海狸。现在，有一只吃海狸的机器&quot;Beavermuncher-0xFF&quot;从根节点sss出发，每吃一只海狸，它就能够且必须走到与该节点两边的下一个节点并吃掉那个节点上的一只海狸。该机器每到一个节点，一次都只能吃一只海狸。要求最终机器回到根节点。问该机器最多能吃多少只海狸。","text":"原题链接 有一棵树，第 iii 个节点上有 kik_iki​ 只海狸。现在，有一只吃海狸的机器 &quot;Beavermuncher-0xFF&quot; 从根节点 sss 出发，每吃一只海狸，它就能够且必须走到与该节点两边的下一个节点并吃掉那个节点上的一只海狸。该机器每到一个节点，一次都只能吃一只海狸。要求最终机器回到根节点。问该机器最多能吃多少只海狸。先输入节点个数 n(n≤105)n(n\\le 10^5)n(n≤105)，然后是nnn 个整数 kik_iki​，后面n−1n−1n−1 行描述一棵树，最后一个整数表示根节点 sss。 样例一大概是这样一幅图：graph tree {\"4(3)\"--\"3(1)\",\"5(2)\" \"5(2)\"--\"2(3)\",\"1(1)\" } 题解 不难发现从一个节点出发，没前往它的一棵子树，都要花费 111 的代价（废话）。回到父亲又要花费 111 的代价。所以一个显然的贪心策略就是先花费 ki−1k_{i-1}ki−1​ 的代价“游历”各个儿子，然后再返回父亲。令 dp[i]dp[i]dp[i] 表示从 iii 节点“游历”儿子后回到父亲最大所能吃掉的海狸数。但有些节点走完所有儿子后海狸数量还是大于 111。我们记录下每个儿子返回父亲后仍留下的海狸数kx[i]kx[i]kx[i]，当父亲“游历”完所有儿子后，考虑在父亲与儿子之间往返跑，即i→fa[i]→i→⋯i\\to fa[i]\\to i\\to \\cdotsi→fa[i]→i→⋯。但有些节点无法“游历”所有儿子，那么就把儿子的dpdpdp 值从大到小排序即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;cctype&gt;#include &lt;cstdio&gt;namespace IO&#123; const int maxl = 23333; char buf[maxl], *sss = buf, *ttt = buf; inline char gc() &#123; if(sss == ttt) &#123; ttt = (sss = buf) + fread(buf, 1, maxl, stdin); if(sss == ttt) return EOF; &#125; return *sss++; &#125; #define dd c = gc() template &lt;class T&gt; inline bool read(T&amp; x) &#123; x = 0; bool f = false; char dd; for(; !isdigit(c); dd) &#123; if(c == '-') f = true; else if(c == EOF) return false; &#125; for(; isdigit(c); dd) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if(f) x = -x; return true; &#125; #undef dd&#125;using IO::read;#include &lt;set&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;typedef pair&lt;LL, int&gt; pii;const int maxn = 100005;int n, k[maxn], kx[maxn], rt;LL dp[maxn];struct Edge&#123; int to, nxt;&#125; e[maxn &lt;&lt; 1];int first[maxn];inline void add_edge(int from, int to)&#123; static int cnt = 0; e[++cnt].nxt = first[from]; first[from] = cnt; e[cnt].to = to; e[++cnt].nxt = first[to]; first[to] = cnt; e[cnt].to = from;&#125;inline void dfs(int now, int fa)&#123; set&lt;pii&gt; st; st.clear(); dp[now] = (now != rt); k[now] -= (now != rt); // 直接把去父亲的代价减掉 for(int i = first[now]; i; i = e[i].nxt) &#123; int to = e[i].to; if(fa != to) &#123; dfs(to, now); st.insert(make_pair(dp[to], to)); &#125; &#125; int tmp = 0; // 儿子节点 kx 的 sum int tmpk = k[now]; set&lt;pii&gt;::reverse_iterator it; // 倒序遍历 set for(it = st.rbegin(); tmpk &amp;&amp; it != st.rend(); tmpk--, ++it) &#123; dp[now] += it-&gt;first + 1; tmp += kx[it-&gt;second]; &#125; dp[now] += min(tmpk, tmp) &lt;&lt; 1; kx[now] = max(tmpk - tmp, 0);&#125;int main()&#123; read(n); for(int i = 1; i &lt;= n; ++i) read(k[i]); for(int i = 1, f, t; i &lt; n; ++i) read(f), read(t), add_edge(f, t); read(rt); dfs(rt, 0); printf(\"%lld\\n\", dp[rt]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"DP","slug":"DP","permalink":"https://pufanyi.pages.dev/tags/DP/"},{"name":"贪心","slug":"贪心","permalink":"https://pufanyi.pages.dev/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"CodeForces 875E Delivery Club","slug":"CF875E","date":"2019-01-11T16:00:00.000Z","updated":"2019-01-11T16:00:00.000Z","comments":true,"path":"CF875E/","link":"","permalink":"https://pufanyi.pages.dev/CF875E/","excerpt":"有两个快递员，分别在s1,s2(0≤s1,s2≤109)s_1, s_2(0\\le s_1,s_2\\le 10^9)s1​,s2​(0≤s1​,s2​≤109)，现在有n(1≤n≤100000)n(1\\le n\\le 100000)n(1≤n≤100000)个任务，每个任务xix_ixi​表示要将货物送到xix_ixi​，让任何一个快递员到xix_ixi​都可以。由于快递员之间需要有对讲机联系，请你设计一种方案使得两个快递员之间的最长距离最短。","text":"有两个快递员，分别在 s1,s2(0≤s1,s2≤109)s_1, s_2(0\\le s_1,s_2\\le 10^9)s1​,s2​(0≤s1​,s2​≤109)，现在有n(1≤n≤100000)n(1\\le n\\le 100000)n(1≤n≤100000) 个任务，每个任务 xix_ixi​ 表示要将货物送到 xix_ixi​，让任何一个快递员到xix_ixi​ 都可以。由于快递员之间需要有对讲机联系，请你设计一种方案使得两个快递员之间的最长距离最短。先输入 n,s1,s2n,s_1,s_2n,s1​,s2​，在一行nnn 个整数 xix_ixi​。 题解CF 如此多的二分 + 贪心，但我就是想不出来…… 首先二分答案。难点是在如何判断答案合法。显然正着做是不行的，所以我们考虑倒着做。我们考虑现在二分的距离为 LLL，枚举到第iii 步，如果两个快递员中至少有一个的起点出现在 [li,ri][l_i,r_i][li​,ri​] 的范围内，且两个快递员相距不超过 LLL，那么是合法的。 现在考虑从 [li+1,ri+1][l_{i+1},r_{i+1}][li+1​,ri+1​] 向[li,ri][l_{i},r_{i}][li​,ri​]转移。显然，两个快递员中只有一个快递员动，而不动的那个快递员必须已经在 [xi−L,xi+L][x_i-L,x_i+L][xi​−L,xi​+L]。 我们考虑下面两种情况：如果 xi∈[li,ri]x_i\\in[l_i,r_i]xi​∈[li​,ri​]，那么只要有一个快递员已经在[xi−L,xi+L][x_i-L,x_i+L][xi​−L,xi​+L] 里即可，我们让另一个快递员走到 xix_ixi​，而因为xi∈[li,ri]x_i\\in[l_i,r_i]xi​∈[li​,ri​]，所以这位快递员在[li,ri][l_i,r_i][li​,ri​] 里了，且两个快递员相距不超过 LLL。所以li=xi−L,ri=xi+Ll_i=x_i-L, r_i=x_i+Lli​=xi​−L,ri​=xi​+L。 如果 xi∉[li,ri]x_i\\notin [l_i,r_i]xi​∈/​[li​,ri​]，考虑不动的快递员，首先必须在[xi−L,xi+L][x_i-L,x_i+L][xi​−L,xi​+L] 里，又由于 xi∉[li,ri]x_i\\notin[l_i,r_i]xi​∈/​[li​,ri​]，故他也必须在[li,ri][l_i,r_i][li​,ri​] 里，而到 xix_ixi​ 的那个快递员没有什么特殊的要求了。所以li=max⁡(li+1,xi−L),ri=min⁡(ri+1,xi+L)l_i=\\max(l_{i+1},x_i-L),r_i=\\min(r_{i+1},x_i+L)li​=max(li+1​,xi​−L),ri​=min(ri+1​,xi​+L)。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;const int inf = 0x3f3f3f3f;int n, s1, s2;int aa[maxn];inline bool check(int x)&#123; int l = -inf, r = inf; for(int i = n; i; --i) &#123; if(l &lt;= aa[i] &amp;&amp; aa[i] &lt;= r) l = aa[i] - x, r = aa[i] + x; else l = max(l, aa[i] - x), r = min(r, aa[i] + x); &#125; return (l &lt;= s1 &amp;&amp; s1 &lt;= r) || (l &lt;= s2 &amp;&amp; s2 &lt;= r);&#125;int main()&#123; scanf(\"%d%d%d\", &amp;n, &amp;s1, &amp;s2); for(int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;aa[i]); int l = abs(s1 - s2), r = inf; while(l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; &#125; printf(\"%d\\n\", l); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"贪心","slug":"贪心","permalink":"https://pufanyi.pages.dev/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二分","slug":"二分","permalink":"https://pufanyi.pages.dev/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"FFT 小小结","slug":"FFT小小结","date":"2019-01-11T16:00:00.000Z","updated":"2019-01-11T16:00:00.000Z","comments":true,"path":"FFT小小结/","link":"","permalink":"https://pufanyi.pages.dev/FFT%E5%B0%8F%E5%B0%8F%E7%BB%93/","excerpt":"未完待续……听说现在全人类都会FFT了？这里做个小小结。","text":"未完待续……听说现在全人类都会 FFT 了？这里做个小小结。 多项式 大概就是这样的一个东西：A(x)=∑i=0n−1aixiA(x) = \\sum_{i=0}^{n-1}a_ix^iA(x)=i=0∑n−1​ai​xi系数 ：a0,a1,a2,⋯ ,an−1a_0, a_1, a_2,\\cdots, a_{n-1}a0​,a1​,a2​,⋯,an−1​。 次数 ：如果最高位非000 系数是 aka_kak​，那就称A(x)A(x)A(x) 的次数为 kkk。 多项式运算 多项式加法 ：若A(x)=∑i=0n−1aixi,B(x)=∑i=0n−1bixi,C(x)=∑i=0n−1cixiA(x) = \\sum_{i=0}^{n-1}a_ix^i, B(x) = \\sum_{i=0}^{n-1}b_ix^i, C(x) = \\sum_{i=0}^{n-1}c_ix^iA(x)=∑i=0n−1​ai​xi,B(x)=∑i=0n−1​bi​xi,C(x)=∑i=0n−1​ci​xi，A(x)+B(x)=C(x)A(x) + B(x) = C(x)A(x)+B(x)=C(x)，那么ci=ai+bic_i=a_i+b_ici​=ai​+bi​。 多项式乘法 ：用乘法结合率算一下即可。如A(x)=−10x+9,B(x)=4x−5A(x) =-10x+9,B(x) = 4x-5A(x)=−10x+9,B(x)=4x−5，则A(x)⋅B(x)=(−10x+9)⋅(4x−5)=−40x2+86x−45A(x)\\cdot B(x)=(-10x+9)\\cdot(4x-5)=-40x^2+86x-45A(x)⋅B(x)=(−10x+9)⋅(4x−5)=−40x2+86x−45 离散卷积 ：我们常说“A(x)A(x)A(x) 与B(x)B(x)B(x)的卷积”其实可以 简单理解为 A(x)A(x)A(x) 和B(x)B(x)B(x)的乘积，记作 a⊗ba\\otimes ba⊗b。[1] 系数表达 就是把 A(x)=∑i=0n−1aixiA(x) = \\sum_{i=0}^{n-1}a_ix^iA(x)=∑i=0n−1​ai​xi 记录为 (a1,a2,⋯ ,an−1)(a_1,a_2,\\cdots,a_{n-1})(a1​,a2​,⋯,an−1​)。朴素算法需要O(n2)\\mathcal{O}(n^2)O(n2) 进行乘法。 点值表达 随便代 nnn 个不同的值进去，可以得到 {(x0,y0),(x1,y1),⋯ ,(xn−1,yn−1)}\\{(x_0,y_0),(x_1,y_1),\\cdots,(x_{n-1},y_{n-1})\\}{(x0​,y0​),(x1​,y1​),⋯,(xn−1​,yn−1​)}。这就是点值表达。 如果两个多项式有 2n2n2n 个不同值的答案一直，那么把它们的 yyy 乘起来，就可以的到这两个多项式相乘后的多项式点值表达，复杂度 O(n)\\mathcal{O}(n)O(n)。 两种表达方式的转化 从系数表达到点值表达，我们常使用 秦九韶算法 （或称为 霍纳法则 ）A(x0)=a0+x0(a1+x0(a2+⋯+(x0(an−2+x0an−1))⋯ ))A(x_0)=a_0+x_0(a_1+x_0(a_2+\\cdots+(x_0(a_{n-2}+x_0a_{n-1}))\\cdots))A(x0​)=a0​+x0​(a1​+x0​(a2​+⋯+(x0​(an−2​+x0​an−1​))⋯)) 从点值表达到系数表达，我们叫做 插值 ，常使用 拉格朗日公式 ：A(x)=∑k=0n−1yk∏j≠k(x−xj)(xk−xj)A(x)=\\sum_{k=0}^{n-1}y_k\\prod_{j\\neq k}\\frac{(x-x_j)}{(x_k-x_j)}A(x)=k=0∑n−1​yk​j​=k∏​(xk​−xj​)(x−xj​)​ 如果你把 xix_ixi​ 代进去，就会发现仅有当 kkk 枚举到 iii 时∏j≠k(x−xj)(xk−xj)=1\\prod_{j\\neq k}\\frac{(x-x_j)}{(x_k-x_j)}=1∏j​=k​(xk​−xj​)(x−xj​)​=1，其余情况都为 ∏j≠k(x−xj)(xk−xj)=0\\prod_{j\\neq k}\\frac{(x-x_j)}{(x_k-x_j)}=0∏j​=k​(xk​−xj​)(x−xj​)​=0（因为分子的xj−xj=0x_j-x_j=0xj​−xj​=0）。[2] 那就假装它是对的吧。[3]。 几道有趣的题 Codeforces 933B A Determined Cleanup 给定两个整数 p,k(1≤p≤1018,2≤k≤2000)p, k (1\\le p\\le 10^{18},2\\le k\\le 2000)p,k(1≤p≤1018,2≤k≤2000)，求构造多项式f(x)=∑i=0d−1aixif(x)=\\sum_{i=0}^{d-1}a_ix^if(x)=∑i=0d−1​ai​xi，使得存在多项式p(x)p(x)p(x) 满足 f(x)=q(x)⋅(x+k)+pf(x)=q(x)\\cdot(x+k)+pf(x)=q(x)⋅(x+k)+p，且ai∈[0,k),i∈[0,d)a_i\\in[0,k),i\\in[0,d)ai​∈[0,k),i∈[0,d)。[4] 题解 假设 q(x)=∑i=0d−2bixiq(x)=\\sum_{i=0}^{d-2}b_ix^iq(x)=∑i=0d−2​bi​xi，那么有：ai={p+kbii=0bi−1+kbii≥1a_i = \\begin{cases} p + kb_i &amp;&amp; i=0\\\\ b_{i-1} + kb_i &amp;&amp; i \\ge 1 \\end{cases}ai​={p+kbi​bi−1​+kbi​​​i=0i≥1​ 我们把上式反过来：{p=a0−kb0bi−1=ai−kbi\\begin{cases} p=a_0-kb_0\\\\ b_{i-1}=a_i-kb_i \\end{cases}{p=a0​−kb0​bi−1​=ai​−kbi​​往上迭代上去，我们就发现这个式子很像上面秦九韶算法的那个式子，所以我们得到：p=anan−1⋯a1‾(−k)p=\\overline{a_na_{n-1}\\cdots a_{1}}_{(-k)}p=an​an−1​⋯a1​​(−k)​。所以我们只要对 ppp 进行 −k-k−k 进制分解即可。 代码 12345678910111213141516171819202122232425#include &lt;cstdio&gt;typedef long long LL;const int maxn = 2333;LL ans[maxn];LL p, k;int main()&#123; scanf(\"%lld%lld\", &amp;p, &amp;k); int top = 0; while(p) &#123; ans[++top] = p % (-k); p /= -k; if(ans[top] &lt; 0) p++, ans[top] += k; &#125; printf(\"%d\\n\", top); for(int i = 1; i &lt;= top; ++i) printf(\"%d\", ans[i]); return 0;&#125; 复数 为解决复数开方问题，我们引入新数 iii，叫做 虚数单位 ，定义i2+1=0i^2+1=0i2+1=0。又把形如a+bi(a,b∈R)a+bi(a, b\\in \\mathbb{R})a+bi(a,b∈R) 的数叫做 复数 ，复数集用C\\mathbb{C}C 表示。 复平面 先把坐标轴画出来，横的叫实轴，竖的叫虚轴，然后确定 000 的位置，z=a+biz=a+biz=a+bi可以用二维空间来表示出来。大概就是这样 [5]： 模长 ：上图中的rrr。 辐角 ：上图中的φ\\varphiφ。 复数运算 加减法 ：(a+bi)+(c+di)=(a+c)+(b+d)i(a+bi)+(c+di)=(a+c)+(b+d)i(a+bi)+(c+di)=(a+c)+(b+d)i。与向量一样，可以使用三角形定则。 乘法 ：(a+bi)(c+di)=ac+bci+adi+bdi2=(ac−bd)+(bc+ad)i(a+bi)(c+di)=ac+bci+adi+bdi^{2}=(ac-bd)+(bc+ad)i(a+bi)(c+di)=ac+bci+adi+bdi2=(ac−bd)+(bc+ad)i。复数相乘，模长相乘，幅角相加。 考虑模长为 111 的复数 ω\\omegaω。一个复数xxx 与它相乘，得到的答案 yyy 与xxx模长相等，辐角是 xxx 加上了 ω\\omegaω 的辐角。想到什么？旋转 ？ 欧拉公式eiu=cos⁡u+isin⁡ue^{iu}=\\cos u+i\\sin ueiu=cosu+isinu 我才不会告诉你我不会证。[6] 单位根 考虑方程 xn−1=0 (n∈N+)x^n-1=0\\,(n\\in \\mathbb{N_+})xn−1=0(n∈N+​)，考虑到复数旋转的性质，我们发现就是将单位圆划分成nnn 等分。所得的解就叫 单位根 ，记为ωn\\omega_nωn​。 画成图大概就是这样的 [7]： 显然，l=1,θ=2πnl=1, \\theta=\\frac{2\\pi}{n}l=1,θ=n2π​。所以 ωn=cos⁡θ+isin⁡θ=cos⁡2πn+isin⁡2πn=e2πn\\omega_n=\\cos \\theta+i\\sin\\theta=\\cos\\frac{2\\pi}{n}+i\\sin\\frac{2\\pi}{n}=e^{\\frac{2\\pi}{n}}ωn​=cosθ+isinθ=cosn2π​+isinn2π​=en2π​。 消去引理ωdndk=(e2πdn)dk=(e2πn)k=ωnk\\omega_{dn}^{dk}={(e^{\\frac{2\\pi}{dn}})}^{dk}=(e^{\\frac{2\\pi}{n}})^k=\\omega_n^kωdndk​=(edn2π​)dk=(en2π​)k=ωnk​ 折半引理ωnk+n2=ωnk⋅ωnn2=−ωnk\\omega_n^{k+\\frac{n}{2}}=\\omega_n^k\\cdot\\omega_n^\\frac{n}{2}=-\\omega_n^kωnk+2n​​=ωnk​⋅ωn2n​​=−ωnk​ 所以：(ωnk+n2)2=(ωnk)2(\\omega_n^{k+\\frac{n}{2}})^2=(\\omega_n^k)^2(ωnk+2n​​)2=(ωnk​)2也就是说，如果我们要算 f(ωnk)f(\\omega^k_n)f(ωnk​) 的值（k∈Z,k∈[0,n)k\\in\\mathbb{Z},k\\in[0, n)k∈Z,k∈[0,n)），我们只需要计算 k∈[0,n2)k\\in[0,\\frac{n}{2})k∈[0,2n​) 时的值即可。 求和引理 由：x⋅∑i=0n−1xi=∑i=1nxix\\cdot\\sum_{i=0}^{n-1}x^i=\\sum_{i=1}^{n}x^ix⋅i=0∑n−1​xi=i=1∑n​xi两边同减去 ∑i=0n−1xi\\sum_{i=0}^{n-1}x^i∑i=0n−1​xi 得：(x−1)∑i=0n−1xi=xn−x0=xn−1(x-1)\\sum_{i=0}^{n-1}x^i=x^n-x^0=x^n-1(x−1)i=0∑n−1​xi=xn−x0=xn−1故当 x≠1x\\neq 1x​=1 时：∑i=0n−1xi=xn−1x−1\\sum_{i=0}^{n-1}x^i=\\frac{x^n-1}{x-1}i=0∑n−1​xi=x−1xn−1​所以当 ωnk≠1\\omega_n^k\\neq 1ωnk​​=1，即n∤kn\\nmid kn∤k 时：∑i=0n−1(ωnk)i=(ωnk)n−1ωnk−1=0\\sum_{i=0}^{n-1}(\\omega_n^k)^i=\\frac{(\\omega_n^k)^n-1}{\\omega_n^k-1}=0i=0∑n−1​(ωnk​)i=ωnk​−1(ωnk​)n−1​=0而当 ωnk=1\\omega_n^k=1ωnk​=1，即n∣kn\\mid kn∣k 时：∑i=0n−1(ωnk)i=n\\sum_{i=0}^{n-1}(\\omega_n^k)^i=ni=0∑n−1​(ωnk​)i=n综上：∑i=0n−1(ωnk)i={0n∤knn∣k\\sum_{i=0}^{n-1}(\\omega_n^k)^i = \\begin{cases} 0&amp; n\\nmid k\\\\ n&amp; n\\mid k \\end{cases}i=0∑n−1​(ωnk​)i={0n​n∤kn∣k​或者我们可以写成：∑i=0n−1(ωnk)i=[n∣k]×n\\sum_{i=0}^{n-1}(\\omega_n^k)^i = [n\\mid k]\\times ni=0∑n−1​(ωnk​)i=[n∣k]×n其中 [ 命题 a][\\text{命题 a}][命题 a] 表示如果命题 a 成立，那么该值为 111，否则为000。 板子1234567891011struct Complex&#123; double x, y; Complex(double x = 0, double y = 0) &#123; this-&gt;x = x, this-&gt;y = y; &#125; friend Complex operator + (Complex a, Complex b) &#123; return Complex(a.x + b.x, a.y + b.y); &#125; friend Complex operator - (Complex a, Complex b) &#123; return Complex(a.x - b.x, a.y - b.y); &#125; friend Complex operator * (Complex a, Complex b) &#123; return Complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); &#125;&#125;; 多项式乘法的基本原理 首先，我们所说的多项式乘法显然是两个用系数表达的多项式之间的算法。我们发现朴素算法的复杂度是 O(n2)\\mathcal{O}(n^2)O(n2)。 然后我们发现用系数表达好像很难优化，但多项式乘法有一个天然的优化方案，也就是如果多项式是用点值表示的，那么乘起来是 O(n)\\mathcal{O}(n)O(n) 的。所以能不能先把它们转化为点值表达，然后乘起来之后把它们插值回去呢？很高兴的是我们有 FFT。所以，多项式乘法就是这样完成的。[8] DFT 与 FFT对于多项式 A(x)=∑i=0naixiA(x)=\\sum_{i=0}^na_ix^iA(x)=∑i=0n​ai​xi，我们记a=(a0,a1,⋯ ,an−1)a=(a_0, a_1, \\cdots, a_{n-1})a=(a0​,a1​,⋯,an−1​)，y=(A(ωn0),A(ωn1),⋯ ,A(ωnn−1))y=(A(\\omega_n^0), A(\\omega_n^1), \\cdots, A(\\omega_n^{n-1}))y=(A(ωn0​),A(ωn1​),⋯,A(ωnn−1​))。则称yyy 是aaa的 离散傅里叶变换 （DFT），记作y=DFT⁡n(a)y=\\operatorname{DFT}_n(a)y=DFTn​(a)。求一个多项式的DFT⁡\\operatorname{DFT}DFT，朴素算法的复杂度为O(n2)\\mathcal{O}(n^2)O(n2)，而如果用一种称为 快速傅里叶变换 （FFT）的方法，利用上面所介绍的几个单位根的性质，可以将该过程优化到O(nlog⁡n)\\mathcal{O}(n\\log n)O(nlogn)。（感觉终于进入正题了） 分治！ 折半引理使单位有了其他数没有的优势——它可以分治。为了让分治能顺利进行，下面所涉及到的多项式的长度都可以表示为 2k(k∈Z)2^k(k\\in \\mathbb{Z})2k(k∈Z)。如果多项式长度不足2k2^k2k，我们就用000 将它补齐。我们把需要计算的多项式 A(x)=∑i=0naixiA(x)=\\sum_{i=0}^na_ix^iA(x)=∑i=0n​ai​xi 按系数编号的奇偶分成两部分，即 A0(x)=∑i=0n/2a2ixiA_0(x)=\\sum_{i=0}^{n/2}a_{2i}x^iA0​(x)=∑i=0n/2​a2i​xi 和A1(x)=∑i=0n/2a2i+1xiA_1(x)=\\sum_{i=0}^{n/2}a_{2i+1}x^iA1​(x)=∑i=0n/2​a2i+1​xi。我们不难发现：A(x)=A0(x2)+xA1(x2)A(x) = A_0(x^2) + xA_1(x^2)A(x)=A0​(x2)+xA1​(x2)平方出现了！我们仅需计算 x=ωnk(k=0∼n2)x=\\omega_n^k(k=0\\sim \\frac{n}{2})x=ωnk​(k=0∼2n​)，然后我们就会发现：A(ωnk)={A0((ωnk)2)+ωnkA1((ωnk)2)k&lt;n2A0((ωnk−n/2)2)−ωnk/2A1((ωnk/2)2)k≥n2A(\\omega_n^k) = \\begin{cases} A_0((\\omega_n^k)^2) + \\omega_n^kA_1((\\omega_n^k)^2) &amp;&amp; k&lt;\\frac{n}{2}\\\\ A_0((\\omega_n^{k-n/2})^2) - \\omega_n^{k/2}A_1((\\omega_n^{k/2})^2) &amp;&amp; k \\ge \\frac{n}{2} \\end{cases}A(ωnk​)={A0​((ωnk​)2)+ωnk​A1​((ωnk​)2)A0​((ωnk−n/2​)2)−ωnk/2​A1​((ωnk/2​)2)​​k&lt;2n​k≥2n​​ 又x2=(ωnk)2=ωn/2kx^2=(\\omega_n^k)^2=\\omega_{n/2}^kx2=(ωnk​)2=ωn/2k​，所以递归下去是我们使用的单位根其实是 ωn/2\\omega_{n/2}ωn/2​。 具体可以看代码。 代码实现 123456789101112131415161718192021inline void FFT(Complex* a, int n)&#123; if(n == 1) return; Complex *a0 = new Complex[n &gt;&gt; 1]; Complex *a1 = new Complex[n &gt;&gt; 1]; for(int i = 0; i &lt; n; i += 2) // 奇偶分类 &#123; a0[i &gt;&gt; 1] = a[i]; a1[i &gt;&gt; 1] = a[i ^ 1]; &#125; FFT(a0, n &gt;&gt; 1); FFT(a1, n &gt;&gt; 1); // 分治 Complex w(1., 0.), w1(cos(pi2 / n), sin(pi2 / n)); // w1 是 1 次单位根，w 是 k 次单位根 for(int i = 0; (i &lt;&lt; 1) &lt; n; ++i) &#123; a[i] = a0[i] + a1[i] * w; a[i + (n &gt;&gt; 1)] = a0[i] - a1[i] * w; w = w * w1; &#125;&#125; IDFT？ 这样就完了吗？不是的。现在我们所的到的是点值表示，而我们所需要的是把系数表达。所以我们需要把它插值回去。我们把这个操作叫做 离散傅里叶变换的逆变换 （IDFT）。 拉格朗日公式？O(n2)\\mathcal{O}(n^2)O(n2)我们假设得到 y=DFT⁡(a)y=\\operatorname{DFT}(a)y=DFT(a)，我们构造向量ccc：ck=∑i=0n−1yi(ωn−k)i=∑i=0n−1∑j=0n−1ωn−kiajωnij=∑i=0n−1∑j=0n−1ωni(j−k)aj=∑j=0n−1∑i=0n−1ωni(j−k)aj=∑j=0n−1aj∑i=0n−1(ωn(j−k))i\\begin{aligned} c_k&amp;=\\sum_{i=0}^{n-1}y_i(\\omega_n^{-k})^i\\\\ &amp;=\\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1}\\omega_n^{-ki}a_j\\omega_n^{ij}\\\\ &amp;=\\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1}\\omega_n^{i(j-k)}a_j\\\\ &amp;=\\sum_{j=0}^{n-1}\\sum_{i=0}^{n-1}\\omega_n^{i(j-k)}a_j\\\\ &amp;=\\sum_{j=0}^{n-1}a_j\\sum_{i=0}^{n-1}(\\omega_n^{(j-k)})^i \\end{aligned}ck​​=i=0∑n−1​yi​(ωn−k​)i=i=0∑n−1​j=0∑n−1​ωn−ki​aj​ωnij​=i=0∑n−1​j=0∑n−1​ωni(j−k)​aj​=j=0∑n−1​i=0∑n−1​ωni(j−k)​aj​=j=0∑n−1​aj​i=0∑n−1​(ωn(j−k)​)i​ 然后根据求和引理我们就可以得到：ck=∑j=0n−1aj∑i=0n−1(ωn(j−k))i=∑j=0n−1[j−k∣n]naj\\begin{aligned} c_k&amp;=\\sum_{j=0}^{n-1}a_j\\sum_{i=0}^{n-1}(\\omega_n^{(j-k)})^i\\\\ &amp;=\\sum_{j=0}^{n-1}[j-k\\mid n]na_j \\end{aligned}ck​​=j=0∑n−1​aj​i=0∑n−1​(ωn(j−k)​)i=j=0∑n−1​[j−k∣n]naj​​由于 0≤j,k&lt;n0\\le j,k&lt;n0≤j,k&lt;n，所以j−k∣nj-k\\mid nj−k∣n 当且仅当 j−k=0j-k=0j−k=0 即j=kj=kj=k。故我们可以把等式写成 ck=∑j=0n−1[j=k]naj=nakc_k=\\sum_{j=0}^{n-1}[j=k]na_j=na_kck​=j=0∑n−1​[j=k]naj​=nak​ 所以：ak=1ncka_k=\\frac{1}{n}c_kak​=n1​ck​所以我们只需计算 ckc_kck​ 即可。[9]我们发现我们就是把普通的 FFT 单位根 ωn\\omega_nωn​ 改成了 ωn−1\\omega_n^{-1}ωn−1​。 回顾上面那幅图：我们发现让 θ\\thetaθ 到这转，也就是把图上下翻转一下就可以了。其中的单位根 ωn−1=cos⁡2πn−isin⁡2πn\\omega_n^{-1}=\\cos\\frac{2\\pi}{n}-i\\sin\\frac{2\\pi}{n}ωn−1​=cosn2π​−isinn2π​。 具体可以看代码实现。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const double pi = acos(-1.);const double pi2 = 2. * pi;struct Complex&#123; double x, y; Complex(double x = 0, double y = 0) &#123; this-&gt;x = x, this-&gt;y = y; &#125; friend Complex operator + (Complex a, Complex b) &#123; return Complex(a.x + b.x, a.y + b.y); &#125; friend Complex operator - (Complex a, Complex b) &#123; return Complex(a.x - b.x, a.y - b.y); &#125; friend Complex operator * (Complex a, Complex b) &#123; return Complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); &#125;&#125;;inline void FFT(Complex* a, int n, int tp) // 加了个 tp，表示单位根的幂次是否为正&#123; if(n == 1) return; Complex *a0 = new Complex[n &gt;&gt; 1]; Complex *a1 = new Complex[n &gt;&gt; 1]; for(int i = 0; i &lt; n; i += 2) &#123; a0[i &gt;&gt; 1] = a[i]; a1[i &gt;&gt; 1] = a[i ^ 1]; &#125; FFT(a0, n &gt;&gt; 1, tp); FFT(a1, n &gt;&gt; 1, tp); Complex w(1., 0.), w1(cos(pi2 / n), tp * sin(pi2 / n)); // 如果单位根的幂次为负那么 sin 的值应取负 for(int i = 0; (i &lt;&lt; 1) &lt; n; ++i) &#123; a[i] = a0[i] + a1[i] * w; a[i + (n &gt;&gt; 1)] = a0[i] - a1[i] * w; w = w * w1; &#125;&#125;const int maxn = 1000005;Complex aa[maxn &lt;&lt; 2], bb[maxn &lt;&lt; 2];int main()&#123; int n, m, k; scanf(\"%d%d\", &amp;n, &amp;m); for(k = 1; k &lt;= n + m; k &lt;&lt;= 1); for(int i = 0; i &lt;= n; ++i) scanf(\"%lf\", &amp;aa[i].x); for(int i = 0; i &lt;= m; ++i) scanf(\"%lf\", &amp;bb[i].x); FFT(aa, k, 1); FFT(bb, k, 1); for(int i = 0; i &lt; k; ++i) aa[i] = aa[i] * bb[i]; FFT(aa, k, -1); for(int i = 0; i &lt;= n + m; ++i) printf(\"%d\", (int) (aa[i].x / k + .5)); return 0;&#125; 卡常大法好 蝴蝶操作 我们来看这段代码：123456for(int i = 0; (i &lt;&lt; 1) &lt; n; ++i)&#123; a[i] = a0[i] + a1[i] * w; a[i + (n &gt;&gt; 1)] = a0[i] - a1[i] * w; w = w * w1;&#125;由于复杂度主要集中在复数运算上，所以我们可以把它优化：1234567for(int i = 0; (i &lt;&lt; 1) &lt; n; ++i)&#123; t = a1[i] * w; a[i] = a0[i] + t; a[i + (n &gt;&gt; 1)] = a0[i] - t; w = w * w1;&#125;虽然也不知道这有什么用。我们把上面这段代码叫做 蝴蝶操作 。 从递归到迭代 我们来看一下 FFT 递归的全过程 [10]： 第一次递归时，我们把下标二进制最后一位为 000 的放在左边，最后一位为 111 的放在右边。接着，我们把下标倒数第二位为 000 的放在坐标，倒数第二位为 111 的放在右边……我们把下标二进制分解来看看：graph g {node[shape=box];&quot;000,001,010,011,100,101,110,111&quot;--&quot;000,010,100,110&quot;,&quot;001,011,101,111&quot;; &quot;000,010,100,110&quot;--&quot;000,100&quot;,&quot;010,110&quot;; &quot;001,011,101,111&quot;--&quot;001,101&quot;,&quot;011,111&quot;; &quot;001,101&quot;--&quot;001&quot;,&quot;101&quot; &quot;011,111&quot;--&quot;011&quot;,&quot;111&quot; &quot;000,100&quot;--&quot;000&quot;,&quot;100&quot; &quot;010,110&quot;--&quot;010&quot;,&quot;110&quot; }不知道大家有没有发现一个特点：这棵树从下往上好像做了一个二进制下的基数排序：先比较最后一位，在比较倒数第二位……也就是说，如果我们把这些数的二进制串倒过来，比如 110 就变成了 011，001 就变成了 100，我们其实是对它进行了一遍排序。 于是我们把一个数的下标倒过来就是递归树底层的位置了。O(nlog⁡n)\\mathcal{O}(n\\log n)O(nlogn)暴力？当然我们还可以 O(n)\\mathcal{O}(n)O(n) 解决，有一个很显然的 dp：rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; cs)，rev[i]表示 iii 翻转后的数字，cs表示这个二进制数字的长度（含前导 000）。(i &amp; 1) &lt;&lt; cs 表示 i 最后一位翻转后的数字，rev[i &gt;&gt; 1] &gt;&gt; 1是 i 出最后一位外翻转得到的数字。比如 0101101，(i &amp; 1) &lt;&lt; cs 是1000000，而 i &gt;&gt; 1 是0010110，翻转之后得到 0110100，右移1 之后是 0011010，在或上前面的1000000，得到的是1011010。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1000005;const double pi2 = 2. * acos(-1.);struct Complex&#123; double x, y; Complex(double x = 0, double y = 0) &#123; this-&gt;x = x, this-&gt;y = y; &#125; friend Complex operator + (Complex a, Complex b) &#123; return Complex(a.x + b.x, a.y + b.y); &#125; friend Complex operator - (Complex a, Complex b) &#123; return Complex(a.x - b.x, a.y - b.y); &#125; friend Complex operator * (Complex a, Complex b) &#123; return Complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); &#125;&#125;;int rev[maxn &lt;&lt; 2];Complex aa[maxn &lt;&lt; 2], bb[maxn &lt;&lt; 2];inline void FFT(Complex* a, int n, int tp)&#123; for(int i = 0; i &lt; n; ++i) if(i &lt; rev[i]) swap(a[i], a[rev[i]]); for(int s = 2; s &lt;= n; s &lt;&lt;= 1) &#123; Complex w1(cos(pi2 / s), tp * sin(pi2 / s)), w, tmp; for(int i = 0; i &lt; n; i += s) &#123; w = Complex(1., 0.); for(int j = 0; (j &lt;&lt; 1) &lt; s; ++j, w = w * w1) &#123; tmp = w * a[i + j + (s &gt;&gt; 1)]; a[i + j + (s &gt;&gt; 1)] = a[i + j] - tmp; a[i + j] = a[i + j] + tmp; &#125; &#125; &#125;&#125;int main()&#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 0; i &lt;= n; ++i) scanf(\"%lf\", &amp;aa[i].x); for(int i = 0; i &lt;= m; ++i) scanf(\"%lf\", &amp;bb[i].x); int l = 1, cs = 0; while(l &lt;= n + m) &#123; l &lt;&lt;= 1; cs++; &#125; for(int i = 0; i &lt; l; ++i) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cs - 1)); FFT(aa, l, 1); FFT(bb, l, 1); for(int i = 0; i &lt; l; ++i) aa[i] = aa[i] * bb[i]; FFT(aa, l, -1); for(int i = 0; i &lt;= n + m; ++i) printf(\"%d\", (int) (aa[i].x / l + .5)); return 0;&#125; 代码长度差不多（上面的是迭代实现），但速度和内存上的差距是很大的。 FFT 优化高精乘法 高精乘法就是把两个大数当成多项式乘起来，其实就是普通 FFT，就直接上代码了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn = 60005;const double pi2 = 2. * acos(-1);struct Complex&#123; double x, y; Complex(double x = 0, double y = 0) &#123; this-&gt;x = x, this-&gt;y = y; &#125; friend Complex operator + (Complex a, Complex b) &#123; return Complex(a.x + b.x, a.y + b.y); &#125; friend Complex operator - (Complex a, Complex b) &#123; return Complex(a.x - b.x, a.y - b.y); &#125; friend Complex operator * (Complex a, Complex b) &#123; return Complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); &#125;&#125;;int rev[maxn &lt;&lt; 2];inline void FFT(Complex* a, int n, int tp)&#123; for(int i = 0; i &lt; n; ++i) if(i &lt; rev[i]) swap(a[i], a[rev[i]]); for(int s = 2; s &lt;= n; s &lt;&lt;= 1) &#123; Complex w1(cos(pi2 / s), tp * sin(pi2 / s)), w, t; for(int i = 0; i &lt; n; i += s) &#123; w = Complex(1., 0.); for(int j = 0; (j &lt;&lt; 1) &lt; s; ++j, w = w1 * w) &#123; t = a[i + j + (s &gt;&gt; 1)] * w; a[i + j + (s &gt;&gt; 1)] = a[i + j] - t; a[i + j] = a[i + j] + t; &#125; &#125; &#125;&#125;Complex aa[maxn &lt;&lt; 2], bb[maxn &lt;&lt; 2];LL ans[maxn &lt;&lt; 2];char s[maxn];int main()&#123; int n; scanf(\"%d\", &amp;n); scanf(\"%s\", s); for(int i = 0; i &lt; n; ++i) aa[i].x = s[n - i - 1] ^ 48; scanf(\"%s\", s); for(int i = 0; i &lt; n; ++i) bb[i].x = s[n - i - 1] ^ 48; int l = 1, cs = 0; while(l &lt; (n &lt;&lt; 1)) &#123; l &lt;&lt;= 1; cs++; &#125; for(int i = 0; i &lt; l; ++i) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cs - 1)); FFT(aa, l, 1); FFT(bb, l, 1); for(int i = 0; i &lt; l; ++i) aa[i] = aa[i] * bb[i]; FFT(aa, l, -1); for(int i = 0; i &lt; l; ++i) &#123; ans[i] += (LL) (aa[i].x / l + .5); ans[i + 1] += ans[i] / 10; ans[i] %= 10; &#125; while(!ans[l] &amp;&amp; l) --l; while(~l) printf(\"%lld\", ans[l--]); return 0;&#125; 一些简单的题 UVa 12298 Super Poker II 按照国际惯例，uva 的题是一定要放 pdf 的： 题目大意 有一副扑克，对于每个正合数 ppp，恰好有444 张不同花色的牌。其中有一些牌丢失（题目会提供已经丢失牌的列表，四种花色分别用 S,H,C,D\\text{S,H,C,D}S,H,C,D 表示）。从四种不同花色牌中分别取出一张牌，求这四张牌构成点数为 nnn 的方案数。多组数据，每组数据输入 a,b,ca, b, ca,b,c，ccc 为丢失牌的数量，分别输出 n=a,n=a+1,⋯ ,n=bn=a,n=a+1,\\cdots,n=bn=a,n=a+1,⋯,n=b 时的答案。[8:1] 题解 我们令 f[i]f[i]f[i] 表示用现有的牌组成 iii 的方案数。正常的 dpdpdp 加入每种花色的复杂度都是 O(n2)\\mathcal{O}(n^2)O(n2)，但是我们发现对两种花色的合并，如果我们有f1[i],f2[i]f_1[i],f_2[i]f1​[i],f2​[i] 两种花色，那么得到的 f[i]f[i]f[i] 其实就是 f1f_1f1​ 与f2f_2f2​的卷积，因为根据乘法原理与加法原理，我们可以得到 f[i]=∑j+k=if1[j]+f2[k]f[i] = \\sum_{j+k=i} f_1[j]+f_2[k]f[i]=∑j+k=i​f1​[j]+f2​[k]。 然后大力 FFT。对了这题要开 long double。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;bitset&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long double LD;typedef long long LL;inline char gc()&#123; static const int L = 23333; static char sxd[L], *sss = sxd, *ttt = sxd; if(sss == ttt) &#123; ttt = (sss = sxd) + fread(sxd, 1, L, stdin); if(sss == ttt) return EOF; &#125; return *sss++;&#125;#define dd c = gc()inline char read(int&amp; x)&#123; x = 0; char dd; for(; !isdigit(c); dd) if(c == EOF) return EOF; for(; isdigit(c); dd) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); return c;&#125;#undef ddconst int maxn = 50005 &lt;&lt; 2;const LD pi2 = acos(-1.) * (LD) 2.;int pp[maxn &lt;&lt; 2];inline void pre()&#123; int n = 50000; for(int i = 2; i &lt;= n; ++i) &#123; if(!pp[i]) &#123; for(int j = i &lt;&lt; 1; j &lt;= n; j += i) pp[j] = 1; &#125; &#125;&#125;struct Complex&#123; LD x, y; Complex(LD a = 0., LD b = 0.) &#123; x = a, y = b; &#125; friend Complex operator + (Complex a, Complex b) &#123; return Complex(a.x + b.x, a.y + b.y); &#125; friend Complex operator - (Complex a, Complex b) &#123; return Complex(a.x - b.x, a.y - b.y); &#125; friend Complex operator * (Complex a, Complex b) &#123; return Complex(a.x * b.x - a.y * b.y, a.x * b.y + b.x * a.y); &#125;&#125;;int rev[maxn &lt;&lt; 2];inline void FFT(Complex* a, int n, int tp)&#123; for(int i = 0; i &lt; n; ++i) if(i &lt; rev[i]) swap(a[i], a[rev[i]]); for(int s = 2; s &lt;= n; s &lt;&lt;= 1) &#123; Complex w, w1 = Complex(cos(pi2 / s), tp * sin(pi2 / s)), tmp; for(int i = 0; i &lt; n; i += s) &#123; w = Complex(1., 0.); for(int l = 0; (l &lt;&lt; 1) &lt; s; ++l, w = w * w1) &#123; tmp = a[i + l + (s &gt;&gt; 1)] * w; a[i + l + (s &gt;&gt; 1)] = a[i + l] - tmp; a[i + l] = a[i + l] + tmp; &#125; &#125; &#125;&#125;Complex aa[maxn &lt;&lt; 2], bb[maxn &lt;&lt; 2], cc[maxn &lt;&lt; 2], dd[maxn &lt;&lt; 2];inline void solve(int n, int l, int r)&#123; int L = r + 1; int len = 1, cs = -1; while(len &lt;= (L &lt;&lt; 2)) // 4 个多项式相乘，长度当然要乘 4 了 &#123; len &lt;&lt;= 1; cs++; &#125; memset(aa, 0, sizeof(aa)); memset(bb, 0, sizeof(bb)); memset(cc, 0, sizeof(cc)); memset(dd, 0, sizeof(dd)); for(int i = 0; i &lt; len; ++i) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; cs); for(int i = 1; i &lt; r; ++i) aa[i] = bb[i] = cc[i] = dd[i] = Complex((LD) pp[i], 0.); for(int i = 1, t; i &lt;= n; ++i) &#123; char c = read(t); switch(c) &#123; case 'S': aa[t].x = 0.; break; case 'H': bb[t].x = 0.; break; case 'C': cc[t].x = 0.; break; case 'D': dd[t].x = 0.; break; &#125; &#125; FFT(aa, len, 1), FFT(bb, len, 1), FFT(cc, len, 1), FFT(dd, len, 1); for(int i = 0; i &lt; len; ++i) aa[i] = aa[i] * bb[i] * cc[i] * dd[i]; FFT(aa, len, -1); for(int i = l; i &lt;= r; ++i) printf(\"%lld\\n\", (LL) ((aa[i].x / len) + .5)); puts(\"\");&#125;signed main()&#123; pre(); int x, y, z; while(read(x) != EOF &amp;&amp; read(y) != EOF &amp;&amp; read(z) != EOF &amp;&amp; (x || y || z)) solve(z, x, y); return 0;&#125; NTT 我们发现 FFT 的复杂度很优秀，然而不能取模。那我们有没有什么办法让它能取模呢？我们考虑从单位根下手。我们看单位根的定义：ωnn=1\\omega_n^n=1ωnn​=1有没有关于取模等于 111 的式子？相信大家都想到了费马小定理：ap−1≡1(modp)a^{p-1}\\equiv 1\\pmod pap−1≡1(modp)当然 ppp 得是素数。于是我们可以联立方程：ap−1≡ωnn(modp)a^{p-1}\\equiv\\omega^n_n\\pmod pap−1≡ωnn​(modp)两边同开 nnn 次根号：ap−1n≡ωn(modp)a^{\\frac{p-1}{n}}\\equiv \\omega_n\\pmod panp−1​≡ωn​(modp)如果 n∣p−1n\\mid p-1n∣p−1 的话，那这式子就有趣了：我们可以把 ωn\\omega_nωn​ 换成 ap−1na^{\\frac{p-1}{n}}anp−1​，就可以完成取模操作了。 我们发现在做 FFT 时，nnn一定是 222 的幂次，所以 ppp 只要表示成 2k×t−1(k,t∈N)2^k\\times t-1(k,t\\in \\mathbb{N})2k×t−1(k,t∈N)，且2k≥n2^k\\ge n2k≥n 就可以了。主要用的是 998244353=119×223+1998244353=119\\times2^{23}+1998244353=119×223+1。[11] 这才是真的定义。 ↩︎感谢 majun 大佬 的口胡证明。 ↩︎戳 这里 看真的证明。 ↩︎翻译来自 NaVi_Awson 大佬的 blog，略有改动。 ↩︎ 图片来自 Wikipedia。 ↩︎ 具体可以去看看 luojinyao 大佬的 blog。 ↩︎ 图片来自《算法导论》，有改动。 ↩︎翻译摘自《算法竞赛入门经典 训练指南》，有改动。 ↩︎ ↩︎感谢 sxd666 巨佬 的口胡。 ↩︎图片来自《算法导论》。 ↩︎其它的数可以参考 这里。 ↩︎","categories":[{"name":"小小结","slug":"小小结","permalink":"https://pufanyi.pages.dev/categories/%E5%B0%8F%E5%B0%8F%E7%BB%93/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E5%AD%A6/"},{"name":"FFT","slug":"FFT","permalink":"https://pufanyi.pages.dev/tags/FFT/"}]},{"title":"做题记录","slug":"做题记录","date":"2019-01-11T16:00:00.000Z","updated":"2019-01-11T16:00:00.000Z","comments":true,"path":"做题记录/","link":"","permalink":"https://pufanyi.pages.dev/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"本想没做一道题写一篇题解。刚立下这个flag我就后悔了。于是就写一句话题解吧。事实证明旗子不能随便插啊。","text":"本想没做一道题写一篇题解。刚立下这个 flag 我就后悔了。于是就写一句话题解吧。事实证明旗子不能随便插啊。如果有题目我专门开一篇文章我会加上链接。以前做过的觉得有趣的题目也会一点点地加上来。如果有 CE 的，可以试试 -std=c++11。 Codeforces【CF3D】将每个问号变成左括号和有括号都有一个代价，求是最终串匹配的最小代价。用堆贪心，括号匹配问题。code【CF6E】单调队列。code【CF7D】字符串哈希。code【CF7E】dp，大细节题。code【CF9D】dp 题，询问nnn 个点组成二叉树，高度大于等于 hhh 的有多少个。令 f[i][j]f[i][j]f[i][j] 表示 iii 个节点高度小于等于 jjj 的二叉树有几个。code【CF10D】经典的 dp 题。code【CF13C】O(n2)\\mathcal{O}(n^2)O(n2)dp 可过，但有 O(nlog⁡n)\\mathcal{O}(n\\log n)O(nlogn) 的贪心。dp code greedy code【CF14D】树上问题，树形 dp+ 分类讨论。code【CF22E】求让该图变成强联通图至少增加多少边并输出边。图构造。code【CF57E】打表找规律好题。code【CF77C】树形 dp+ 贪心。code【CF351D】树状数组，HH 的项链的升级版。code【CF434D】网络流，建图。code【CF449C】数论 + 构造。code【CF505E】二分答案 + 贪心。code【CF551C】二分答案 + 贪心。code【CF675E】树状数组 / 线段树优化基于贪心的 dp。code【CF875E】二分答案 + 贪心。code【CF933B】有关多项式的构造题。code【CF986B】贪心 + 数学。code【CF1037D】大力模拟 BFS。 code【CF1045B】一道有趣的数学 + 字符串题。code【CF1096D】打完才发现开错题目了……dp，每个状态是一个类似矩阵的二维数组。先定义 0,1,2,30, 1, 2, 30,1,2,3 四个状态，然后每个二维数组记录的是像邻接表一样的：从 111 状态向 222 状态需要花费多少，然后大力转移。其实可以加强一下支持区间查询（套一只线段树即可），单点修改。code【CF1103B】交互题。需要发现结论：当 x&lt;ax&lt;ax&lt;a 时，x≤2x(moda)⇔x≤a≤2xx \\le 2x\\pmod a\\Leftrightarrow x\\le a\\le 2xx≤2x(moda)⇔x≤a≤2x，然后先倍增枚举 xxx 再定范围，最后二分。还有 111 需要特判。话说这询问次数卡得好紧啊……code UVa【UVa11292】贪心。code【UVa11729】贪心。code【Uva11300】贪心，需要一点数学分析。code【UVa1388】贪心，感觉是假题，结论需要暴搜验证。code【UVa10881】挺有趣的题，需要发现一些结论。code【UVa1030】留坑，还没打。【UVa11464】状压。code【UVa1352】暴搜。书上说要打表，但似乎有点多此一举……code【UVa11210】留坑吧，看不懂题意啊……【UVa11384】二进制分解。code【UVa10795】udebug 上标程好像是假的……被 这组数据 卡了。理所当然错误的程序也过了，于是我的代码也过了……code(wrong)","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"UVa","slug":"UVa","permalink":"https://pufanyi.pages.dev/tags/UVa/"}]},{"title":"CodeForces 449C Jzzhu and Apples","slug":"CF449C","date":"2019-01-04T16:00:00.000Z","updated":"2019-01-04T16:00:00.000Z","comments":true,"path":"CF449C/","link":"","permalink":"https://pufanyi.pages.dev/CF449C/","excerpt":"原题链接给出正整数nnn，你要把1∼n1\\sim n1∼n之间的正整数两两分组，使得每一组两个数的最大公约数大于111。输出能分成最多个组，并按任意顺序输出每组的两个数。","text":"原题链接 给出正整数 nnn，你要把1∼n1\\sim n1∼n 之间的正整数两两分组，使得每一组两个数的最大公约数大于 111。输出能分成最多个组，并按任意顺序输出每组的两个数。 题解 官方题解 说得很简单。就是枚举从大到小质因数 xxx（如果2x≥n2x\\ge n2x≥n 显然就不用管了），找出所有之前没有匹配过得 xxx 的倍数，如果是偶数个就两两匹配，否则把 2x2x2x 除去即可。那为什么这样是对的呢？我们来看最后枚举到 x=2x=2x=2 的情况。如果有偶数个，那正好可以两两匹配，显然最优。如果是奇数个，那我们发现所有 可能被匹配的数 （即所有枚举到的数）有奇数个，即我们至少需要扔掉一个。现在我们只扔掉了一个（因为之前除去的2x2x2x 都在此时被匹配了），所以这种情况是最优的。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;int n, prime[maxn &gt;&gt; 1], p[maxn], cnt;inline void oula(int n)&#123; cnt = 0; for(int i = 2; i &lt;= n; ++i) &#123; if(!p[i]) prime[++cnt] = i; for(int j = 1; j &lt;= cnt &amp;&amp; prime[j] * i &lt;= n; ++j) &#123; p[prime[j] * i] = 1; if(!(i % prime[j])) break; &#125; &#125;&#125;int aa[maxn], cntt, hv[maxn];int ans[maxn][2], anss;int main()&#123; scanf(\"%d\", &amp;n); oula(n &gt;&gt; 1); for(int i = cnt; i; --i) &#123; cntt = 0; for(int j = prime[i]; j &lt;= n; j += prime[i]) if(!hv[j]) aa[++cntt] = j; if(cntt &amp; 1) &#123; swap(aa[cntt], aa[2]); cntt--; &#125; for(int j = 1; j &lt;= cntt; j += 2) &#123; hv[aa[j]] = hv[aa[j + 1]] = 1; ans[++anss][0] = aa[j]; ans[anss][1] = aa[j + 1]; &#125; &#125; printf(\"%d\\n\", anss); for(int i = 1; i &lt;= anss; ++i) printf(\"%d %d\\n\", ans[i][0], ans[i][1]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"数论","slug":"数论","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E8%AE%BA/"},{"name":"构造","slug":"构造","permalink":"https://pufanyi.pages.dev/tags/%E6%9E%84%E9%80%A0/"}]},{"title":"ZJOI2014 璀灿光华","slug":"璀灿光华","date":"2019-01-04T16:00:00.000Z","updated":"2019-01-04T16:00:00.000Z","comments":true,"path":"璀灿光华/","link":"","permalink":"https://pufanyi.pages.dev/%E7%92%80%E7%81%BF%E5%85%89%E5%8D%8E/","excerpt":"题面金先生有一个女朋友没名字。她勤劳勇敢、智慧善良。金先生很喜欢她。为此，金先生用a3a^3a3块1×1×11 \\times 1 \\times 11×1×1的独特的水晶制作了一个边长为aaa的水晶立方体，他要将这个水晶立方体送给他见过最单纯善良的她。由于水晶立方体太太，不好运送，金先生还是将它拆开来送出。他相信拼好这个水晶立方难不倒聪明的她。没名字收到了礼物后果然不一会儿就根据说明将水晶立方体拼好了。没名字发现，有nnn块水晶在漆黑安静的夜晚会随机以等概率向上下左右前后六个方向的一个发出光。被光照到的水晶显得格外好看。没名字给每一块不会发光的水晶定义了一个好看程度。水晶立方体在夜晚中的好看程度就是每块被光照到的水晶的好看程度之和。没名字想知道，水晶立方体在夜晚中的好看程度的最小值和最大值。","text":"题面 金先生有一个女朋友没名字。她勤劳勇敢、智慧善良。金先生很喜欢她。为此，金先生用 a3a^3a3 块1×1×11 \\times 1 \\times 11×1×1的独特的水晶制作了一个边长为 aaa 的水晶立方体，他要将这个水晶立方体送给他见过最单纯善良的她。由于水晶立方体太太，不好运送，金先生还是将它拆开来送出。他相信拼好这个水晶立方难不倒聪明的她。没名字收到了礼物后果然不一会儿就根据说明将水晶立方体拼好了。没名字发现，有 nnn 块水晶在漆黑安静的夜晚会随机以等概率向上下左右前后六个方向的一个发出光。被光照到的水晶显得格外好看。没名字给每一块不会发光的水晶定义了一个好看程度。水晶立方体在夜晚中的好看程度就是每块被光照到的水晶的好看程度之和。没名字想知道，水晶立方体在夜晚中的好看程度的最小值和最大值。 输入格式 第一行是 aaa，表示水晶立方体的边长。接下来 a3a^3a3 行，每行若干整数。第一个数 gig_igi​ 表示第 iii 块水晶的好看程度。如果 gi=0g_i=0gi​=0，代表这块水晶会发光。接下来 3∼63\\sim 63∼6个整数，代表与这块水晶有共同面的水晶编号。 输出格式 两个整数，代表水晶立方体在夜晚好看程度的最小值与最大值。 样例 样例输入12345678920 7 2 30 8 1 44 5 4 18 6 3 216 3 6 732 4 5 81 1 8 52 2 7 6 样例输出10 12 数据范围与提示 对于所有数据，1&lt;a≤70,gi&lt;1000000,n≤81&lt;a\\le 70, g_i&lt;1000000, n\\le 81&lt;a≤70,gi​&lt;1000000,n≤8。 题解 首先，介绍一下 c++ stl 里的神物——stringstream。这东西能像 cin 那样读入，但是是从字符串中读入，所以我们就不用打快读了（虽然慢了一点，但开氧气之后海星）。头文件 &lt;sstream&gt; 大概就是这样读：123456789for(int i = 1; i &lt;= n; ++i)&#123; getline(cin, tmp); stringstream ss(tmp); ss &gt;&gt; dep[i]; int aa; while(ss &gt;&gt; aa) add_edge(i, aa);&#125;题目中的照射不仅只照到了与该水晶相邻的水晶，它把整条射线上的水晶全照到了。所以我们只能考虑建出这个立方体后重新建图。我的思路是这样的：先找到一个度为 3 的点作为一个角的点，用 bfs 求出其道个点的最短路。记以该点为原点的第 iii 个点坐标为 (x1,i,y1,i,z1,i)(x_{1, i}, y_{1, i}, z_{1, i})(x1,i​,y1,i​,z1,i​)，最短路为dist[0][i]dist[0][i]dist[0][i]，显然有dist[0][i]=x1,i−1+y1,i−1+z1,i−1dist[0][i] = x_{1, i} - 1+ y_{1, i} - 1 + z_{1, i} - 1dist[0][i]=x1,i​−1+y1,i​−1+z1,i​−1。 我们任选一个平面，要求包含刚才那个点。我们找到在该平面上该点对角线上的点，其实就是随便找一个度为 3（在角上）且与原点距离 2(n−1)2(n-1)2(n−1)（在该平面上最远）的点。以该点为原点跑一遍最短路，记dist[1][i]dist[1][i]dist[1][i]。 由于我们设计最短路时，可以先走到该点正下方，再往上爬，同样，我们可以设计成先走 yyy，再走xxx，最后走zzz。 我们发现 dist[0][i]+dist[1][i]=2(n−1)dist[0][i] +dist[1][i]=2(n-1)dist[0][i]+dist[1][i]=2(n−1)，我们把它减去，就只剩下2z2z2z 了，于是 zzz 就求出来了：123456789101112131415161718192021/** ddn 是度数 di 是原点 poi 记录点的 x, y, z 这里的 n 已经是点的个数了 tn 才是边长 由于从 1 开始，所以有些地方微调了一下 */for(di[0] = 1; ddn[di[0]] &gt; 3; ++di[0]);bfs(0);for(int i = 1; i &lt;= n; ++i)&#123; if(ddn[i] == 3 &amp;&amp; dist[0][i] == ((tn-1)&lt;&lt;1)) &#123; di[1] = i; break; &#125;&#125;bfs(1);for(int i = 1; i &lt;= n; ++i) poi[i].z = (dist[0][i] + dist[1][i] - ((tn-2)&lt;&lt;1)) &gt;&gt; 1; 我们可以用同样的方法把 xxx 解出来，最后的 yyy 只要减一下就可以了。因为我的坐标是从 1 开始的，所以我对坐标做了一些微调，从 0 开始就没有这个问题。由于之前 bfs 的数据我们还能用，所以我们只需再一遍 bfs 即可 123456789101112for(int i = 1; i &lt;= n; ++i) if(poi[i].z == tn &amp;&amp; dist[0][i] == dist[1][i] &amp;&amp; ddn[i] == 3) di[2] = i;bfs(2);for(int i = 1; i &lt;= n; ++i)&#123; poi[i].x = (dist[0][i] + dist[2][i] - ((tn-1)&lt;&lt;1)) &gt;&gt; 1; poi[i].y = (dist[0][i] - poi[i].x - poi[i].z) + 1; poi[i].x++; poi[i].y++; mmap[poi[i].x][poi[i].y][poi[i].z] = i;&#125; 于是我们就建好图了。后面的大力 dfs 也没什么好说的。下面把 ac 代码贴一下，由于 stringstream 在没有氧气的情况下极慢，所以必须开氧气。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;//stringstream #include &lt;queue&gt;using namespace std;const int maxm = 2058000;// 这里的最大边数我是把点数加起来乘了 6 const int maxn = 75*75*75;const int inf = 0x3f3f3f3f;int n;// 总个数 int tn;// 边长 struct Edge&#123; int to, nxt;&#125; e[maxm&lt;&lt;1];int first[maxn];int cnt;inline void add_edge(int f, int t)&#123; e[++cnt].nxt = first[f]; first[f] = cnt; e[cnt].to = t;&#125;int dirx[] = &#123;1, -1, 0, 0, 0, 0&#125;;int diry[] = &#123;0, 0, 1, -1, 0, 0&#125;;int dirz[] = &#123;0, 0, 0, 0, 1, -1&#125;;int dep[maxn];//\" 好看程度 \"int vis[maxn];int minn = inf;int maxx = -inf;int ll[10];// 会发光的水晶的编号 int ddn[maxn];// 度数 int zl;// 这是个 ddn 的 cnt int mmap[73][73][73]; struct zb&#123; int x, y, z;&#125; poi[maxn];#define pan (x &gt; 0 &amp;&amp; x &lt;= tn &amp;&amp; y &gt; 0 &amp;&amp; y &lt;= tn &amp;&amp; z &gt; 0 &amp;&amp; z &lt;= tn)#define nxxt x += dirx[i], y += diry[i], z += dirz[i]inline int getans(int i, zb a)// 能加多少\" 好看程度 \"&#123; int ans = 0; int x = a.x, y = a.y, z = a.z; for(; pan; nxxt) if(!vis[mmap[x][y][z]]++)// 由于待会儿回溯时要删除，所以懒到家的我就直接用 ++,-- 代替记录了 ans += dep[mmap[x][y][z]]; return ans;&#125;inline void delvis(int i, zb a)// 回溯时把 dfs 前加的 vis 删除 &#123; int x = a.x, y = a.y, z = a.z; for(; pan; nxxt) vis[mmap[x][y][z]]--;&#125;inline void dfs(int now, int ans)// 大力枚举所有情况 &#123; if(now &gt; zl) &#123; minn = min(minn, ans); maxx = max(maxx, ans); return; &#125; for(int i = 0; i &lt; 6; ++i) &#123; dfs(now+1, ans + getans(i, poi[ll[now]])); delvis(i, poi[ll[now]]); &#125;&#125;int dist[4][maxn];int di[4];bool viss[maxn];inline void bfs(int id)// 求最短路 &#123; memset(viss, 0, sizeof(viss)); queue&lt;int&gt; q; int from = di[id]; viss[from] = true; q.push(from); while(!q.empty()) &#123; int now = q.front(); q.pop(); for(int i = first[now]; i; i = e[i].nxt) &#123; int to = e[i].to; if(!viss[to]) &#123; viss[to] = true; dist[id][to] = dist[id][now] + 1; q.push(to); &#125; &#125; &#125;&#125;int main() &#123; ios:: sync_with_stdio(false); cin &gt;&gt; n; tn = n; string tmp; getline(cin, tmp); n *= n * n; for(int i = 1; i &lt;= n; ++i) &#123; getline(cin, tmp); stringstream ss(tmp); ss &gt;&gt; dep[i]; int aa; if(!dep[i]) &#123; vis[i] = true; ll[++zl] = i; &#125; while(ss &gt;&gt; aa) &#123; add_edge(i, aa); ddn[i]++; &#125; &#125; for(di[0] = 1; ddn[di[0]] &gt; 3; ++di[0]); bfs(0); for(int i = 1; i &lt;= n; ++i) &#123; if(ddn[i] == 3 &amp;&amp; dist[0][i] == ((tn-1)&lt;&lt;1)) &#123; di[1] = i; break; &#125; &#125; bfs(1); for(int i = 1; i &lt;= n; ++i)// 得到 z &#123; poi[i].z = (dist[0][i] + dist[1][i] - ((tn-2)&lt;&lt;1)) &gt;&gt; 1; if(poi[i].z == tn &amp;&amp; dist[0][i] == dist[1][i] &amp;&amp; ddn[i] == 3) di[2] = i; &#125; bfs(2); for(int i = 1; i &lt;= n; ++i)// 得到 x, y &#123; poi[i].x = (dist[0][i] + dist[2][i] - ((tn-1)&lt;&lt;1)) &gt;&gt; 1; poi[i].y = (dist[0][i] - poi[i].x - poi[i].z) + 1; poi[i].x++; poi[i].y++; mmap[poi[i].x][poi[i].y][poi[i].z] = i; &#125; dfs(1, 0); cout &lt;&lt; minn &lt;&lt; ' ' &lt;&lt; maxx &lt;&lt; endl; fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://pufanyi.pages.dev/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"ZJOI","slug":"ZJOI","permalink":"https://pufanyi.pages.dev/tags/ZJOI/"},{"name":"搜索","slug":"搜索","permalink":"https://pufanyi.pages.dev/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"CodeForces 1045B Space Isaac","slug":"CF1045B","date":"2018-12-30T16:00:00.000Z","updated":"2018-12-30T16:00:00.000Z","comments":true,"path":"CF1045B/","link":"","permalink":"https://pufanyi.pages.dev/CF1045B/","excerpt":"原题链接0∼m−10\\sim m-10∼m−1的数被分成两个集合，你可以分别从两个集合中取一个数相加并对mmm取模，求0∼m−10\\sim m-10∼m−1中不能构造出的数。","text":"原题链接 0∼m−10\\sim m-10∼m−1 的数被分成两个集合，你可以分别从两个集合中取一个数相加并对 mmm 取模，求 0∼m−10\\sim m-10∼m−1 中不能构造出的数。 题解 感觉如果 sxd666 来做这题肯定能一眼秒，然而他正忙着切其他题。首先我们发现如果要让 a+b≡x(modm)​a + b \\equiv x \\pmod m​a+b≡x(modm)​，如果已知a,x​a, x​a,x​，那b​b​b​ 一定是唯一的。也就是说，假设给定集合是 A​A​A​，与之对应的集合为B​B​B​，如果有a∈A​a\\in A​a∈A​ 但找不到 b∈A​b\\in A​b∈A​ 使得 a+b≡x(modm)​a + b \\equiv x\\pmod m​a+b≡x(modm)​。那么x∈A+B​x\\in A + B​x∈A+B​（定义A+B={a+b:a∈A,b∈B}​A + B = \\{a + b : a\\in A, b\\in B\\}​A+B={a+b:a∈A,b∈B}​）。反过来讲，如果x∉A+B​x\\notin A + B​x∈/​A+B​，那么一定能把A​A​A​ 中所有元素配对（可能两个数相同），也即 x∉A+B ⟺ A=x−A​x\\notin A + B \\iff A = x - A​x∈/​A+B⟺A=x−A​（定义x−A={x−a:a∈A}​x - A= \\{x - a : a\\in A\\}​x−A={x−a:a∈A}​）。 然后我们如果把小于 mmm 的整数看成一个环，如果有两个数 a,ba, ba,b 使a+b≡x(modm)a + b \\equiv x \\pmod ma+b≡x(modm)，aaa顺时针时针移动，bbb肯定逆时针移动（即运动方向相反，且移动的长度应该是相等的（(a+k) mod m+(b−k) mod m≡a+b(modm)(a + k)\\bmod m + (b - k)\\bmod m \\equiv a + b \\pmod m(a+k)modm+(b−k)modm≡a+b(modm)嘛）。于是我们画两个圆，都表示集合 {ai}\\{a_i\\}{ai​}（假设aia_iai​ 已经排好序），我们要把第一个圆的点与第二个圆的点匹配。假设 aia_iai​ 与aja_jaj​匹配。我们把 iii 移动至 i+1i+1i+1，那么根据上面推出的单调性，jjj 必须移至 j−1j-1j−1（因为ai∼ai+1a_i\\sim a_{i+1}ai​∼ai+1​ 之间没有数了，所以 jjj 也只能移动一格），又因为移动距离必须相等，即 ai+1−ai=aj−aj−1a_{i+1} - a_i = a_j - a_{j-1}ai+1​−ai​=aj​−aj−1​。 所以我们令 bi=ai−ai−1b_i = a_{i} - a_{i-1}bi​=ai​−ai−1​（b1=(a1−an) mod mb_1 = (a_1 - a_n)\\bmod mb1​=(a1​−an​)modm），设串s1=bnbn−1bn−2⋯b1,s2=b1b2b3⋯bns_1 = b_nb_{n-1}b_{n-2}\\cdots b_1, s_2 = b_1b_2b_3\\cdots b_ns1​=bn​bn−1​bn−2​⋯b1​,s2​=b1​b2​b3​⋯bn​，我们要找的是s1s_1s1​ 与s2s_2s2​成环后相等，并找到一对匹配的数，他们加起来模 mmm 即为一组解。我们令 s3=s2+s2s_3 = s_2 + s_2s3​=s2​+s2​，找到s3s_3s3​ 中所有等于 s1s_1s1​ 的子串，就得到了所有解，这个问题用 KMP 或是 Z 都能解决。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn = 200005;LL aa[maxn]; // 读入的 aLL bb[maxn]; // 即上面说的 bvector&lt;LL&gt; gou;int in[maxn &lt;&lt; 2];LL Z[maxn &lt;&lt; 2];set&lt;LL&gt; ans;int main()&#123; int n; LL m; scanf(\"%d%lld\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) scanf(\"%lld\", &amp;aa[i]); bb[1] = ((aa[1] - aa[n]) + m) % m; for(int i = 2; i &lt;= n; ++i) bb[i] = ((aa[i] - aa[i-1]) % m + m) % m; for(int i = n; i; --i) // 这里用的是 Z 算法，所以合并成了一个串 &#123; gou.push_back(bb[i]); in[gou.size() - 1] = i; &#125; gou.push_back(-1LL); for(int i = 1; i &lt;= n; ++i) &#123; gou.push_back(bb[i]); in[gou.size() - 1] = i; &#125; for(int i = 1; i &lt;= n; ++i) &#123; gou.push_back(bb[i]); in[gou.size() - 1] = i; &#125; Z[0] = gou.size(); for(int i = 1, j = 1, k; i &lt; (int) gou.size(); i = k) // Z 算法 &#123; j = max(j, i); while(gou[j] == gou[j - i]) ++j; Z[i] = j - i; k = i + 1; while(k + Z[k - i] &lt; j) &#123; Z[k] = Z[k - i]; ++k; &#125; &#125; for(int i = 1; i &lt; (int) gou.size(); ++i) if(Z[i] &gt;= n) // 大力记录答案 ans.insert((aa[in[i] - 1 ? in[i] - 1 : n] + aa[n]) % m); printf(\"%d\\n\", (int) ans.size()); for(auto it = ans.begin(); it != ans.end(); ++it) printf(\"%lld\", *it); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E5%AD%A6/"},{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"字符串","slug":"字符串","permalink":"https://pufanyi.pages.dev/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数论","slug":"数论","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"CodeForces 351D Jeff and Removing Periods","slug":"CF351D","date":"2018-12-30T16:00:00.000Z","updated":"2018-12-30T16:00:00.000Z","comments":true,"path":"CF351D/","link":"","permalink":"https://pufanyi.pages.dev/CF351D/","excerpt":"原题链接有一个长度为n(n≤105)n(n\\le 10^5)n(n≤105)的序列{a}(ai≤105)\\{a\\}(a_i\\le 10^5){a}(ai​≤105)，你可以对它进行操作，操作如下：首先选择三个数v,t,kv, t, kv,t,k，满足av=av+t=av+2t=⋯=av+kta_v = a_{v+t} = a_{v + 2t} = \\cdots = a_{v + kt}av​=av+t​=av+2t​=⋯=av+kt​，然后将其删除，得到一个新的序列。每次操作结束后你都能将新数列重排。现有Q(Q≤105)Q(Q\\le 10^5)Q(Q≤105)个询问，每次询问[l,r][l, r][l,r]表示问要把[l,r][l, r][l,r]删除所需的最小步数。","text":"原题链接 有一个长度为 n(n≤105)n(n\\le 10^5)n(n≤105) 的序列 {a}(ai≤105)\\{a\\}(a_i\\le 10^5){a}(ai​≤105)，你可以对它进行操作，操作如下：首先选择三个数v,t,kv, t, kv,t,k，满足av=av+t=av+2t=⋯=av+kta_v = a_{v+t} = a_{v + 2t} = \\cdots = a_{v + kt}av​=av+t​=av+2t​=⋯=av+kt​，然后将其删除，得到一个新的序列。每次操作结束后你都能将新数列重排。 现有 Q(Q≤105)Q(Q\\le 10^5)Q(Q≤105) 个询问，每次询问 [l,r][l, r][l,r] 表示问要把 [l,r][l, r][l,r] 删除所需的最小步数。（以上翻译改写自 洛谷 ） 题解 感觉像是 HH 的项链 的升级版。不难发现答案就是 [l,r][l, r][l,r] 不同数的个数 +++ 第一次在 [l,r][l,r][l,r] 中是否有一种数被删掉。记两个数组 fa[i]fa[i]fa[i] 与ffa[i]ffa[i]ffa[i]，fa[i]fa[i]fa[i]表示上一次第 iii 个数出现在了那里，ffa[i]ffa[i]ffa[i]表示如果询问的 l≤ffa[i]l\\le ffa[i]l≤ffa[i]，那么在[l,r][l, r][l,r] 区间内与第 iii 个数相同的不可能被一次性删除。大致就是这样一幅图：黑色表示 fa[i]fa[i]fa[i]，红色表示ffa[i]ffa[i]ffa[i]（如果fa[i]fa[i]fa[i] 或ffa[i]ffa[i]ffa[i]连到了 000 就没画）。不难得出如果 i−fa[i]=fa[i]−fa[fa[i]]i - fa[i] = fa[i] - fa[fa[i]]i−fa[i]=fa[i]−fa[fa[i]]，那么ffa[i]=ffa[fa[i]]ffa[i] = ffa[fa[i]]ffa[i]=ffa[fa[i]]，否则ffa[i]=fa[fa[i]]ffa[i] = fa[fa[i]]ffa[i]=fa[fa[i]]。1234567for(int i = 1, aa; i &lt;= n; ++i)&#123; scanf(\"%d\", &amp;aa); fa[i] = lst[aa]; lst[aa] = i; ffa[i] = (fa[i] - fa[fa[i]] == i - fa[i]) ? ffa[fa[i]] : fa[fa[i]];&#125; 我们考虑离线，让询问按 rrr 为关键字排序。考虑查询 [l,r][l, r][l,r]，如果是这样一段序列：1,2,2,2,31, 2, 2, 2, 31,2,2,2,3，我们发现222 出现了 333 次，我们钦定最后一个 222 对答案有贡献。这样我们对所有相同的数，都钦定最后一个对答案有贡献，其余对答案即可。这样没加入一个数，就在线段树 / 树状数组对 iii 位置加 111，在fa[i]fa[i]fa[i] 位置减 111 即可（把前一个数的贡献删去）。对于询问第一次能否完全删除一个数，我们只需查询有多少个数在 [l,r][l, r][l,r] 上不是均匀分布即可。同理，我们钦定最后一个对答案有贡献，没加入一个 iii 时，在 ffa[fa[i]]ffa[fa[i]]ffa[fa[i]] 上−1-1−1，在 ffa[i]ffa[i]ffa[i] 上+1+1+1即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;int n;struct Tree&#123; int no[maxn &lt;&lt; 2]; int K; inline void build_tree() &#123; for(K = 1; K &lt;= n; K &lt;&lt;= 1); &#125; inline void add(int k, int x) &#123; if(!k) return; for(k += K; k; k &gt;&gt;= 1) no[k] += x; &#125; inline int query(int l, int r) &#123; int ans = 0; for(l += K - 1, r += K + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) &#123; if(~l &amp; 1) ans += no[l ^ 1]; if(r &amp; 1) ans += no[r ^ 1]; &#125; return ans; &#125;&#125; tr1, tr2;int fa[maxn], ffa[maxn], lst[maxn];struct ask&#123; int l, r, id; friend bool operator &lt; (ask a, ask b) &#123; return a.r &lt; b.r; &#125;&#125; q[maxn];int ans[maxn];int main()&#123; scanf(\"%d\", &amp;n); tr1.build_tree(), tr2.build_tree(); for(int i = 1, aa; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;aa); fa[i] = lst[aa]; lst[aa] = i; ffa[i] = (fa[i] - fa[fa[i]] == i - fa[i]) ? ffa[fa[i]] : fa[fa[i]]; &#125; int Q; scanf(\"%d\", &amp;Q); for(int i = 1; i &lt;= Q; ++i) &#123; scanf(\"%d%d\", &amp;q[i].l, &amp;q[i].r); q[i].id = i; &#125; sort(q + 1, q + Q + 1); for(int i = 1, now = 0; i &lt;= Q; ++i) &#123; register int l = q[i].l, r = q[i].r; while(now &lt; r) &#123; now++; tr1.add(fa[now], -1); tr1.add(now, 1); tr2.add(ffa[fa[now]], -1); tr2.add(ffa[now], 1); &#125; int tt1 = tr1.query(l, r), tt2 = tr2.query(l, r); ans[q[i].id] = tt1 + (tt1 == tt2); &#125; for(int i = 1; i &lt;= Q; ++i) printf(\"%d\\n\", ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"数据结构","slug":"数据结构","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树状数组/线段树","slug":"树状数组-线段树","permalink":"https://pufanyi.pages.dev/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"CodeForces 986B Petr and Permutations","slug":"CF986B","date":"2018-12-30T16:00:00.000Z","updated":"2018-12-30T16:00:00.000Z","comments":true,"path":"CF986B/","link":"","permalink":"https://pufanyi.pages.dev/CF986B/","excerpt":"原题链接Petr要打乱排列。他首先有一个从111到nnn的顺序排列，然后进行3n3n3n次操作，每次选两个数并交换它们。Alex也要打乱排列。他与Petr唯一的不同是他进行7n+17n+17n+1次操作。给定一个111到nnn的排列。问是由谁打乱的。如果是Petr，输出&quot;Petr&quot;，否则输出&quot;Um_nik&quot;（不是Alex）。","text":"原题链接 Petr 要打乱排列。他首先有一个从111 到nnn的顺序排列，然后进行 3n3n3n 次操作，每次选两个数并交换它们。Alex 也要打乱排列。他与 Petr 唯一的不同是他进行 7n+17n+17n+1 次操作。给定一个 111 到nnn的排列。问是由谁打乱的。如果是 Petr，输出 &quot;Petr&quot;，否则 输出 &quot;Um_nik&quot;（不是 Alex）。（by AKEE） 题解 首先我们考虑怎么快速还原这个序列。很显然的一个贪心策略就是假设序列为 {ai}\\{a_i\\}{ai​}，不断把aaia_{a_i}aai​​ 与aia_iai​交换直到 ai=ia_i=iai​=i。 这样做我们发现交换次数是 O(n)\\mathcal{O}(n)O(n) 级别的，因为 aaia_{a_i}aai​​ 最多被选 nnn 次。然后我们发现要一个序列交换后形成交换前的序列交换次数只能是偶数。所以该交换次数与 Petr 或Alex的奇偶性相同。于是只要判一下奇偶即可。 代码12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1000005;int aa[maxn];int main()&#123; int n; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;aa[i]); int ans = 0; for(int i = 1; i &lt;= n; ++i) &#123; while(aa[i] != i) &#123; swap(aa[aa[i]], aa[i]); ans++; &#125; &#125; if((n &amp; 1) == (ans &amp; 1)) // 判断奇偶性相同 puts(\"Petr\"); else puts(\"Um_nik\"); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"贪心","slug":"贪心","permalink":"https://pufanyi.pages.dev/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"三道大水题","slug":"三道大水题","date":"2018-12-30T16:00:00.000Z","updated":"2018-12-30T16:00:00.000Z","comments":true,"path":"三道大水题/","link":"","permalink":"https://pufanyi.pages.dev/%E4%B8%89%E9%81%93%E5%A4%A7%E6%B0%B4%E9%A2%98/","excerpt":"和sxd出的大水题，T1T2大样例连续出锅快被表死了。","text":"和 sxd 出的大水题，T1T2 大样例连续出锅快被表死了。 题面 完整的选手文件夹 戳这里下载 题解 数据 这里是数据 一点小问题T1 其实不能用 Lucas。 因为模数太小了，求逆元时有锅。所以应将原题模数改大，数据范围改小。然而比赛时两题大样例的出锅已经让我无所畏惧了……","categories":[{"name":"出题","slug":"出题","permalink":"https://pufanyi.pages.dev/categories/%E5%87%BA%E9%A2%98/"}],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://pufanyi.pages.dev/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"数学","slug":"数学","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数据结构","slug":"数据结构","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树状数组/线段树","slug":"树状数组-线段树","permalink":"https://pufanyi.pages.dev/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"出题","slug":"出题","permalink":"https://pufanyi.pages.dev/tags/%E5%87%BA%E9%A2%98/"},{"name":"树的重心","slug":"树的重心","permalink":"https://pufanyi.pages.dev/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"}]},{"title":"CodeForces 551C GukiZ hates Boxes","slug":"CF551C","date":"2018-12-29T11:33:33.000Z","updated":"2018-12-29T11:33:33.000Z","comments":true,"path":"CF551C/","link":"","permalink":"https://pufanyi.pages.dev/CF551C/","excerpt":"原题链接有nnn个位置(1∼n)(1\\sim n)(1∼n)，第iii个位置上有aia_iai​个箱子。有mmm个人，开始在000位置（即在111号位置左边），每一秒钟每个人都可以选择搬走自己位置上的一个箱子或向前走一步（即从位置iii走到位置i+1i+1i+1）。问最少需要多少时间才可以将箱子全部搬完。","text":"原题链接 有nnn个位置 (1∼n)(1\\sim n)(1∼n)，第iii 个位置上有 aia_iai​ 个箱子。有 mmm 个人，开始在 000 位置（即在 111 号位置左边），每一秒钟每个人都可以选择搬走自己位置上的一个箱子或向前走一步（即从位置 iii 走到位置 i+1i+1i+1）。问最少需要多少时间才可以将箱子全部搬完。 输入第一行两个正整数 n,m(n,m≤105)n, m(n, m\\le 10^5)n,m(n,m≤105)，第二行nnn 个整数 ai(0≤ai≤109)a_i(0\\le a_i\\le 10^9)ai​(0≤ai​≤109)。 题解 发现正着做比较麻烦，于是考虑二分答案。如果需要验证的答案为 xxx，那我们就让每个人都有xxx 秒。我们考虑让人一个一个来，一个显然的贪心就是让每个人都拿尽量远的箱子。然后大力模拟即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn = 100005, maxm = 100005;int aa[maxn];int now[maxn];int n, m;inline bool pan(LL x)&#123; for(int i = 1; i &lt;= n; ++i) now[i] = aa[i]; int noww = n; for(int i = 1; i &lt;= m; ++i) &#123; LL tx = x; while(!now[noww] &amp;&amp; noww) noww--; if(!noww) return true; tx -= noww; if(tx &lt; 0) return false; while(tx &gt;= 0) &#123; if(now[noww] &gt; tx) &#123; now[noww] -= tx; break; &#125; else &#123; tx-= now[noww]; now[noww] = 0; while(!now[noww] &amp;&amp; noww) noww--; if(!noww) return true; &#125; &#125; &#125; while(!now[noww] &amp;&amp; noww) noww--; return !noww;&#125;int main()&#123; scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;aa[i]); LL l = 0, r = 0x3f3f3f3f3f3f3f3f; while(l &lt; r) &#123; LL mid = (l + r) &gt;&gt; 1; if(pan(mid)) r = mid; else l = mid + 1; &#125; printf(\"%I64d\\n\", l); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"贪心","slug":"贪心","permalink":"https://pufanyi.pages.dev/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二分","slug":"二分","permalink":"https://pufanyi.pages.dev/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"zkw 线段树优化 dijkstra","slug":"zkw线段树优化dijkstra","date":"2018-12-22T16:00:00.000Z","updated":"2018-12-22T16:00:00.000Z","comments":true,"path":"zkw线段树优化dijkstra/","link":"","permalink":"https://pufanyi.pages.dev/zkw%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96dijkstra/","excerpt":"听说zkw线段树优化dijkstra跑得很快呢，洛谷最优解都是用这个的。然后我就自己打了一发。确实快了许多，但还是被最优解吊着打……但至少能过bzoj3040。","text":"听说 zkw 线段树优化 dijkstra 跑得很快呢，洛谷最优解都是用这个的。然后我就自己打了一发。确实快了许多，但还是被最优解吊着打……但至少能过 bzoj3040。 把普通堆优 dij 的堆改成线段树就可以了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273struct Edge&#123; int to, dist, nxt;&#125; e[maxm &lt;&lt; 1];int first[maxn];inline void add_edge(int from, int to, int dist)&#123; static int cnt = 0; e[++cnt].nxt = first[from]; first[from] = cnt; e[cnt].dist = dist; e[cnt].to = to;&#125;int dist[maxn];struct DIJKSTRA&#123;#define ls(x) (x &lt;&lt; 1)#define rs(x) (x &lt;&lt; 1 | 1) struct Tree &#123; int no[maxn &lt;&lt; 2]; int t; inline void build_tree() &#123; for(t = 1; t &lt;= n; t &lt;&lt;= 1); for(register int i = 1; i &lt;= n; ++i) no[i + t] = i; &#125; inline void change(int k) &#123; for(k += t, k &gt;&gt;= 1; k; k &gt;&gt;= 1) no[k] = dist[no[ls(k)]] &lt; dist[no[rs(k)]] ? no[ls(k)] : no[rs(k)]; &#125; inline void del(int k) &#123; for(no[k += t] = 0, k &gt;&gt;= 1; k; k &gt;&gt;= 1) no[k] = dist[no[ls(k)]] &lt; dist[no[rs(k)]] ? no[ls(k)] : no[rs(k)]; &#125; &#125; tr; inline void dijkstra(int s) &#123; memset(dist, 0x3f, sizeof(dist)); dist[s] = 0; tr.build_tree(); tr.change(s); for(int i = 1; i &lt;= n; ++i) &#123; register int now = tr.no[1]; if(!now || dist[now] &gt;= inf) break; tr.del(now); for(int j = first[now]; j; j = e[j].nxt) &#123; register int to = e[j].to; if(dist[to] &gt; dist[now] + e[j].dist) &#123; dist[to] = dist[now] + e[j].dist; tr.change(to); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"模板","slug":"模板","permalink":"https://pufanyi.pages.dev/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://pufanyi.pages.dev/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","permalink":"https://pufanyi.pages.dev/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"20180524 模拟赛 T3 Word","slug":"20180524模拟赛-word","date":"2018-12-21T16:00:00.000Z","updated":"2018-12-21T16:00:00.000Z","comments":true,"path":"20180524模拟赛-word/","link":"","permalink":"https://pufanyi.pages.dev/20180524%E6%A8%A1%E6%8B%9F%E8%B5%9B-word/","excerpt":"一道有趣的矩乘题。","text":"一道有趣的矩乘题。 题解 显然元辅音可以分开来看，那我们就只看元音。于是我们就可以很自然地推出 ans=∑i=1n(i+1)pians=\\sum_{i=1}^n(i+1)p^ians=∑i=1n​(i+1)pi。由于有一个叫重音的东西，所以系数是i+1i+1i+1。直接算会 T（70 分），于是我们就想到了矩阵快速幂。 首先我们当然想到是推 2×22\\times 22×2 的，于是写出初始矩阵 [02p]\\begin{bmatrix}0 &amp; 2p \\end{bmatrix}[0​2p​]，要转移到[2p3p2+2p]\\begin{bmatrix}2p &amp; 3p^2+2p\\end{bmatrix}[2p​3p2+2p​]。发现矩阵的系数有变化，无法转移。于是我们就需要添加一格来辅助转移。观察两矩阵的系数变化，我们就不难推出辅助的那个应该填什么：[0p2p]→[2pp23p2+2p]\\begin{bmatrix}0&amp;p&amp;2p\\end{bmatrix}\\to \\begin{bmatrix}2p&amp;p^2&amp;3p^2+2p\\end{bmatrix}[0​p​2p​]→[2p​p2​3p2+2p​]。于是得出中间矩阵是[1000pp10p]\\begin{bmatrix}1&amp;0&amp;0\\\\0&amp;p&amp;p\\\\1&amp;0&amp;p\\end{bmatrix}⎣⎡​101​0p0​0pp​⎦⎤​。 然后就用同样的方法算辅音即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;fstream&gt;using namespace std;typedef long long LL;ifstream fin(\"word.in\");ofstream fout(\"word.out\");LL chen[4][4], q, p, n, mod, jg[2][4], tt[4][4];inline void pow(int aa)&#123; while(aa) &#123; if(aa &amp; 1) &#123; for(int j = 1; j &lt;= 3; ++j) &#123; tt[1][j] = 0; for(int k = 1; k &lt;= 3; ++k) tt[1][j] = (tt[1][j] + jg[1][k] * chen[k][j] % mod) %mod; &#125; memcpy(jg, tt, sizeof(jg)); &#125; aa &gt;&gt;= 1; for(int i = 1; i &lt;= 3; ++i) &#123; for(int j = 1; j &lt;= 3; ++j) &#123; tt[i][j] = 0; for(int k = 1; k &lt;= 3; ++k) tt[i][j] = (tt[i][j]+chen[i][k]*chen[k][j]%mod)%mod; &#125; &#125; memcpy(chen, tt, sizeof(chen)); &#125;&#125;int main()&#123; fin &gt;&gt; q &gt;&gt; p &gt;&gt; n &gt;&gt; mod; jg[1][1] = (q&lt;&lt;1) % mod; jg[1][2] = q % mod; chen[1][1] = chen[2][1] = chen[2][2] = q % mod; chen[1][3] = chen[3][3] = 1; pow(n); LL sumy = jg[1][3]; memset(jg, 0, sizeof(jg)); memset(chen, 0, sizeof(chen)); jg[1][1] = (p&lt;&lt;1) % mod; jg[1][2] = p%mod; chen[1][1] = chen[2][1] = chen[2][2] = p % mod; chen[1][3] = chen[3][3] = 1; pow(n); LL sumf = jg[1][3]; LL ans = (sumy * sumf % mod + sumy + sumf) % mod; fout &lt;&lt; ans; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://pufanyi.pages.dev/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"数学","slug":"数学","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"SPOJ1026 Favorite Dice & 赠券收集问题","slug":"SP1026","date":"2018-12-21T16:00:00.000Z","updated":"2018-12-21T16:00:00.000Z","comments":true,"path":"SP1026/","link":"","permalink":"https://pufanyi.pages.dev/SP1026/","excerpt":"原题链接假设有nnn个数，每种每个数获取机率相同，而且每个数亦无限供应。若取ttt个，能集齐这nnn个数的概率是多少？","text":"原题链接 假设有 nnn 个数，每种每个数获取机率相同，而且每个数亦无限供应。若取 ttt 个，能集齐这 nnn 个数的概率是多少？ 题解 我们考虑当你手上已有 iii 种不同的数，从集合中任选一个数得到新数的概率，为 n−i+1n\\frac{n-i+1}{n}nn−i+1​，那期望即为1p=nn−i+1\\frac{1}{p} = \\frac{n}{n-i+1}p1​=n−i+1n​。所以总期望为∑i=1nnn−i+1=∑i=1nni\\sum_{i = 1}^{n}\\frac{n}{n-i+1} = \\sum_{i=1}^{n}\\frac{n}{i}∑i=1n​n−i+1n​=∑i=1n​in​。 当然也可以用概率 dp 来推：我们设 f[i]f[i]f[i] 表示取了 iii 种数时还须取的数的期望。显然 f[n]=0f[n] = 0f[n]=0，答案为f[0]f[0]f[0]，所以为逆推。 又由于选第 iii 个数后再选一个数与已经选过的数不同的概率为 n−in\\frac{n-i}{n}nn−i​，相同为in\\frac{i}{n}ni​。 于是可得 f[i]=n−inf[i+1]+inf[i]+1f[i] = \\frac{n-i}{n}f[i+1]+\\frac{i}{n}f[i] + 1f[i]=nn−i​f[i+1]+ni​f[i]+1。 解得 f[i]=f[i+1]+nn−if[i] = f[i+1] + \\frac{n}{n-i}f[i]=f[i+1]+n−in​。 于是整理一下就变成了f[0]=∑i=1nnif[0] = \\sum_{i=1}^{n}\\frac{n}{i}f[0]=∑i=1n​in​。","categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E5%AD%A6/"},{"name":"DP","slug":"DP","permalink":"https://pufanyi.pages.dev/tags/DP/"},{"name":"SPOJ","slug":"SPOJ","permalink":"https://pufanyi.pages.dev/tags/SPOJ/"}]},{"title":"Hello World!","slug":"hello-world","date":"2018-11-11T04:44:00.000Z","updated":"2018-11-11T04:44:00.000Z","comments":true,"path":"hello-world/","link":"","permalink":"https://pufanyi.pages.dev/hello-world/","excerpt":"作为新博客的开头。","text":"作为新博客的开头。123456#include &lt;iostream&gt;int main() &#123; std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl; return 0;&#125;","categories":[],"tags":[]}],"categories":[{"name":"题解","slug":"题解","permalink":"https://pufanyi.pages.dev/categories/%E9%A2%98%E8%A7%A3/"},{"name":"公告","slug":"公告","permalink":"https://pufanyi.pages.dev/categories/%E5%85%AC%E5%91%8A/"},{"name":"文化课","slug":"文化课","permalink":"https://pufanyi.pages.dev/categories/%E6%96%87%E5%8C%96%E8%AF%BE/"},{"name":"随笔","slug":"随笔","permalink":"https://pufanyi.pages.dev/categories/%E9%9A%8F%E7%AC%94/"},{"name":"小小结","slug":"小小结","permalink":"https://pufanyi.pages.dev/categories/%E5%B0%8F%E5%B0%8F%E7%BB%93/"},{"name":"毒瘤","slug":"毒瘤","permalink":"https://pufanyi.pages.dev/categories/%E6%AF%92%E7%98%A4/"},{"name":"出题","slug":"出题","permalink":"https://pufanyi.pages.dev/categories/%E5%87%BA%E9%A2%98/"},{"name":"模板","slug":"模板","permalink":"https://pufanyi.pages.dev/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"https://pufanyi.pages.dev/tags/CodeForces/"},{"name":"数学","slug":"数学","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E5%AD%A6/"},{"name":"DP","slug":"DP","permalink":"https://pufanyi.pages.dev/tags/DP/"},{"name":"文化课","slug":"文化课","permalink":"https://pufanyi.pages.dev/tags/%E6%96%87%E5%8C%96%E8%AF%BE/"},{"name":"数论","slug":"数论","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E8%AE%BA/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://pufanyi.pages.dev/tags/AtCoder/"},{"name":"博弈","slug":"博弈","permalink":"https://pufanyi.pages.dev/tags/%E5%8D%9A%E5%BC%88/"},{"name":"构造","slug":"构造","permalink":"https://pufanyi.pages.dev/tags/%E6%9E%84%E9%80%A0/"},{"name":"hash","slug":"hash","permalink":"https://pufanyi.pages.dev/tags/hash/"},{"name":"网络流","slug":"网络流","permalink":"https://pufanyi.pages.dev/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"贪心","slug":"贪心","permalink":"https://pufanyi.pages.dev/tags/%E8%B4%AA%E5%BF%83/"},{"name":"图论","slug":"图论","permalink":"https://pufanyi.pages.dev/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","permalink":"https://pufanyi.pages.dev/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"并查集","slug":"并查集","permalink":"https://pufanyi.pages.dev/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"two points","slug":"two-points","permalink":"https://pufanyi.pages.dev/tags/two-points/"},{"name":"数据结构","slug":"数据结构","permalink":"https://pufanyi.pages.dev/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树状数组/线段树","slug":"树状数组-线段树","permalink":"https://pufanyi.pages.dev/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"二分","slug":"二分","permalink":"https://pufanyi.pages.dev/tags/%E4%BA%8C%E5%88%86/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://pufanyi.pages.dev/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"生成树","slug":"生成树","permalink":"https://pufanyi.pages.dev/tags/%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"USACO","slug":"USACO","permalink":"https://pufanyi.pages.dev/tags/USACO/"},{"name":"出题","slug":"出题","permalink":"https://pufanyi.pages.dev/tags/%E5%87%BA%E9%A2%98/"},{"name":"UVa","slug":"UVa","permalink":"https://pufanyi.pages.dev/tags/UVa/"},{"name":"模拟赛","slug":"模拟赛","permalink":"https://pufanyi.pages.dev/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"Lucas","slug":"Lucas","permalink":"https://pufanyi.pages.dev/tags/Lucas/"},{"name":"LCT","slug":"LCT","permalink":"https://pufanyi.pages.dev/tags/LCT/"},{"name":"SPOJ","slug":"SPOJ","permalink":"https://pufanyi.pages.dev/tags/SPOJ/"},{"name":"分块","slug":"分块","permalink":"https://pufanyi.pages.dev/tags/%E5%88%86%E5%9D%97/"},{"name":"卡常","slug":"卡常","permalink":"https://pufanyi.pages.dev/tags/%E5%8D%A1%E5%B8%B8/"},{"name":"模拟","slug":"模拟","permalink":"https://pufanyi.pages.dev/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"FFT","slug":"FFT","permalink":"https://pufanyi.pages.dev/tags/FFT/"},{"name":"ZJOI","slug":"ZJOI","permalink":"https://pufanyi.pages.dev/tags/ZJOI/"},{"name":"搜索","slug":"搜索","permalink":"https://pufanyi.pages.dev/tags/%E6%90%9C%E7%B4%A2/"},{"name":"字符串","slug":"字符串","permalink":"https://pufanyi.pages.dev/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"树的重心","slug":"树的重心","permalink":"https://pufanyi.pages.dev/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"}]}